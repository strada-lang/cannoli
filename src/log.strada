/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Log;


# cannoli/src/log.strada - Logging support
#
# Provides error and access logging with configurable output
# Access log format: Combined Log Format (Apache/nginx compatible)
#   remote_ip - - [timestamp] "method path protocol" status size "referer" "user_agent"
#
# Error log format:
#   [timestamp] [level] message

# Log levels
my int $LOG_ERROR = 1;
my int $LOG_WARN = 2;
my int $LOG_INFO = 3;
my int $LOG_DEBUG = 4;

# Global log settings
my scalar $g_error_log_fd = undef;
my scalar $g_access_log_fd = undef;
my str $g_error_log_file = "";
my str $g_access_log_file = "";
my int $g_log_level = 3;  # Default to INFO
my int $g_log_to_stderr = 1;
my int $g_log_to_stdout = 0;  # For access log to stdout
my str $g_log_format = "%m %p %s %b %Tms";  # Default console format

# Initialize logging
func Cannoli_Log_init(hash %config) void {
    $g_error_log_file = Cannoli::Config::get_str(%config, "log.error_file", "");
    $g_access_log_file = Cannoli::Config::get_str(%config, "log.access_file", "");
    my str $level_str = Cannoli::Config::get_str(%config, "log.level", "info");

    # Set log level
    if ($level_str eq "error") {
        $g_log_level = 1;
    } elsif ($level_str eq "warn") {
        $g_log_level = 2;
    } elsif ($level_str eq "info") {
        $g_log_level = 3;
    } elsif ($level_str eq "debug") {
        $g_log_level = 4;
    }

    # Check if logging to stdout is enabled (--debug flag)
    my str $to_stdout = Cannoli::Config::get_str(%config, "log.to_stdout", "0");
    if ($to_stdout eq "1") {
        $g_log_to_stdout = 1;
        $g_log_to_stderr = 1;
    }

    # Get log format string
    $g_log_format = Cannoli::Config::get_str(%config, "log.format", "%m %p %s %b %Tms");

    # Test open error log
    if (length($g_error_log_file) > 0) {
        my scalar $fh = sys::open($g_error_log_file, "a");
        if (defined($fh)) {
            sys::close($fh);
        } else {
            say("Warning: Could not open error log: " . $g_error_log_file);
            $g_error_log_file = "";
        }
    }

    # Test open access log
    if (length($g_access_log_file) > 0) {
        my scalar $fh = sys::open($g_access_log_file, "a");
        if (defined($fh)) {
            sys::close($fh);
        } else {
            say("Warning: Could not open access log: " . $g_access_log_file);
            $g_access_log_file = "";
        }
    }
}

# Close log files (no-op, we open/close per write for safety in forked processes)
func Cannoli_Log_close() void {
    # Nothing to do - files are opened/closed per write
}

# Get current timestamp in log format
func Cannoli_Log_timestamp() str {
    my int $now = sys::time();
    # Format: [DD/Mon/YYYY:HH:MM:SS +0000]
    # For now, use Unix timestamp as we don't have strftime
    return "[" . $now . "]";
}

# Get timestamp for access log
func Cannoli_Log_access_timestamp() str {
    my int $now = sys::time();
    return "[" . $now . "]";
}

# Write to error log
func Cannoli_Log_write_error(str $level, str $message) void {
    my str $timestamp = ::timestamp();
    my str $line = $timestamp . " [" . $level . "] " . $message . "\n";

    if (length($g_error_log_file) > 0) {
        my scalar $fh = sys::open($g_error_log_file, "a");
        if (defined($fh)) {
            sys::fwrite($fh, $line);
            sys::close($fh);
        }
    }

    if ($g_log_to_stderr == 1) {
        print($line);
    }
}

# Log error message
func Cannoli_Log_error(str $message) void {
    if ($g_log_level >= 1) {
        ::write_error("ERROR", $message);
    }
}

# Log warning message
func Cannoli_Log_warn(str $message) void {
    if ($g_log_level >= 2) {
        ::write_error("WARN", $message);
    }
}

# Log info message
func Cannoli_Log_info(str $message) void {
    if ($g_log_level >= 3) {
        ::write_error("INFO", $message);
    }
}

# Log debug message
func Cannoli_Log_debug(str $message) void {
    if ($g_log_level >= 4) {
        ::write_error("DEBUG", $message);
    }
}

# Format a log line using the format string
# Placeholders: %t=timestamp %m=method %p=path %s=status %b=bytes %T=time_ms
#               %r=referer %a=user_agent %i=remote_ip %P=protocol
func Cannoli_Log_format_line(str $format, str $remote_ip, str $method, str $path, str $protocol, int $status, int $size, str $referer, str $user_agent, int $time_ms) str {
    my str $result = "";
    my str $timestamp = "" . sys::time();
    my str $status_str = "" . $status;
    my str $size_str = "" . $size;
    my str $time_str = "" . $time_ms;

    my int $len = length($format);
    my int $i = 0;

    while ($i < $len) {
        my str $ch = substr($format, $i, 1);

        if ($ch eq "%" && $i + 1 < $len) {
            my str $spec = substr($format, $i + 1, 1);

            if ($spec eq "T") {
                $result = $result . $time_str;
                $i = $i + 2;
            } elsif ($spec eq "t") {
                $result = $result . $timestamp;
                $i = $i + 2;
            } elsif ($spec eq "m") {
                $result = $result . $method;
                $i = $i + 2;
            } elsif ($spec eq "p") {
                $result = $result . $path;
                $i = $i + 2;
            } elsif ($spec eq "s") {
                $result = $result . $status_str;
                $i = $i + 2;
            } elsif ($spec eq "b") {
                $result = $result . $size_str;
                $i = $i + 2;
            } elsif ($spec eq "r") {
                $result = $result . $referer;
                $i = $i + 2;
            } elsif ($spec eq "a") {
                $result = $result . $user_agent;
                $i = $i + 2;
            } elsif ($spec eq "i") {
                $result = $result . $remote_ip;
                $i = $i + 2;
            } elsif ($spec eq "P") {
                $result = $result . $protocol;
                $i = $i + 2;
            } elsif ($spec eq "%") {
                $result = $result . "%";
                $i = $i + 2;
            } else {
                # Unknown placeholder, keep as-is
                $result = $result . $ch;
                $i = $i + 1;
            }
        } else {
            $result = $result . $ch;
            $i = $i + 1;
        }
    }

    return $result;
}

# Log access in Combined Log Format
# remote_ip - - [timestamp] "method path protocol" status size "referer" "user_agent"
func Cannoli_Log_access(str $remote_ip, str $method, str $path, str $protocol, int $status, int $size, str $referer, str $user_agent, int $time_ms) void {
    my str $timestamp = ::access_timestamp();

    # Escape or default values
    if (length($referer) == 0) {
        $referer = "-";
    }
    if (length($user_agent) == 0) {
        $user_agent = "-";
    }

    # Write to file in Combined Log Format (with timing)
    if (length($g_access_log_file) > 0) {
        my str $line = $remote_ip . " - - " . $timestamp . " \"";
        $line = $line . $method . " " . $path . " " . $protocol . "\" ";
        $line = $line . $status . " " . $size . " ";
        $line = $line . "\"" . $referer . "\" \"" . $user_agent . "\" " . $time_ms . "ms\n";

        my scalar $fh = sys::open($g_access_log_file, "a");
        if (defined($fh)) {
            sys::fwrite($fh, $line);
            sys::close($fh);
        }
    }

    # Log to stdout if --debug flag or debug level, using custom format
    if ($g_log_to_stdout == 1 || $g_log_level >= 4) {
        my str $console_line = ::format_line($g_log_format, $remote_ip, $method, $path, $protocol, $status, $size, $referer, $user_agent, $time_ms);
        say($console_line);
    }
}

# Convenience function for logging a request with timing
func Cannoli_Log_request_timed(hash %req, hash %res, int $time_ms) void {
    my str $remote_ip = "127.0.0.1";  # TODO: Get from socket
    my str $method = $req{"method"};
    my str $path = $req{"path"};
    my str $protocol = "HTTP/1.1";
    my int $status = $res{"status"};
    my str $body = $res{"body"};
    my int $size = length($body);
    my str $referer = Cannoli::Request::get_header(%req, "Referer");
    my str $user_agent = Cannoli::Request::get_header(%req, "User-Agent");

    ::access($remote_ip, $method, $path, $protocol, $status, $size, $referer, $user_agent, $time_ms);
}

# Convenience function for logging a Cannoli::Log::request(backwards compatible, 0ms timing)
func Cannoli_Log_request(hash %req, hash %res) void {
    ::request_timed(%req, %res, 0);
}

# ============================================================
# Log Rotation
# ============================================================

# Global rotation settings
my int $g_rotate_size = 10485760;  # 10MB default
my int $g_rotate_keep = 5;         # Keep 5 old files

# Configure log rotation
func Cannoli_Log_set_rotation(int $max_size, int $keep_files) void {
    if ($max_size > 0) {
        $g_rotate_size = $max_size;
    }
    if ($keep_files > 0) {
        $g_rotate_keep = $keep_files;
    }
}

# Get file size (returns 0 if file doesn't exist)
func Cannoli_Log_file_size(str $path) int {
    if (sys::is_file($path) == 0) {
        return 0;
    }
    my str $content = slurp($path);
    return length($content);
}

# Rotate a log file
# Renames: file -> file.1, file.1 -> file.2, etc.
func Cannoli_Log_rotate(str $path) void {
    if (sys::is_file($path) == 0) {
        return;
    }

    # Check if file needs rotation
    my int $size = ::file_size($path);
    if ($size < $g_rotate_size) {
        return;
    }

    # Rotate existing numbered files (work backwards)
    my int $i = $g_rotate_keep - 1;
    while ($i >= 1) {
        my str $old_path = $path . "." . $i;
        my str $new_path = $path . "." . ($i + 1);

        if (sys::is_file($old_path) == 1) {
            if ($i == $g_rotate_keep - 1) {
                # Delete oldest file
                sys::unlink($old_path);
            } else {
                # Rename to next number
                sys::rename($old_path, $new_path);
            }
        }
        $i = $i - 1;
    }

    # Rename current file to .1
    my str $rotated_path = $path . ".1";
    sys::rename($path, $rotated_path);
}

# Check and rotate all log files if needed
func Cannoli_Log_check_rotation() void {
    if (length($g_error_log_file) > 0) {
        ::rotate($g_error_log_file);
    }
    if (length($g_access_log_file) > 0) {
        ::rotate($g_access_log_file);
    }
}

# ============================================================
# JSON Structured Logging
# ============================================================

# Global JSON log flag
my int $g_json_log = 0;

# Enable/disable JSON logging
func Cannoli_Log_set_json_format(int $enabled) void {
    $g_json_log = $enabled;
}

# Log access in JSON format
func Cannoli_Log_access_json(str $remote_ip, str $method, str $path, str $protocol, int $status, int $size, str $referer, str $user_agent, int $time_ms) str {
    my str $timestamp = "" . sys::time();

    my str $json = "{";
    $json = $json . "\"timestamp\":" . $timestamp;
    $json = $json . ",\"type\":\"access\"";
    $json = $json . ",\"remote_ip\":\"" . ::json_escape($remote_ip) . "\"";
    $json = $json . ",\"method\":\"" . $method . "\"";
    $json = $json . ",\"path\":\"" . ::json_escape($path) . "\"";
    $json = $json . ",\"protocol\":\"" . $protocol . "\"";
    $json = $json . ",\"status\":" . $status;
    $json = $json . ",\"size\":" . $size;
    $json = $json . ",\"time_ms\":" . $time_ms;

    if (length($referer) > 0 && $referer ne "-") {
        $json = $json . ",\"referer\":\"" . ::json_escape($referer) . "\"";
    }
    if (length($user_agent) > 0 && $user_agent ne "-") {
        $json = $json . ",\"user_agent\":\"" . ::json_escape($user_agent) . "\"";
    }

    $json = $json . "}";
    return $json;
}

# Log error in JSON format
func Cannoli_Log_error_json(str $level, str $message) str {
    my str $timestamp = "" . sys::time();

    my str $json = "{";
    $json = $json . "\"timestamp\":" . $timestamp;
    $json = $json . ",\"type\":\"error\"";
    $json = $json . ",\"level\":\"" . $level . "\"";
    $json = $json . ",\"message\":\"" . ::json_escape($message) . "\"";
    $json = $json . "}";
    return $json;
}

# JSON string escape helper
func Cannoli_Log_json_escape(str $s) str {
    my str $result = "";
    my int $len = length($s);
    my int $i = 0;

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        my int $code = ord($ch);

        if ($ch eq "\"") {
            $result = $result . "\\\"";
        } elsif ($ch eq "\\") {
            $result = $result . "\\\\";
        } elsif ($code == 10) {
            $result = $result . "\\n";
        } elsif ($code == 13) {
            $result = $result . "\\r";
        } elsif ($code == 9) {
            $result = $result . "\\t";
        } else {
            $result = $result . $ch;
        }
        $i = $i + 1;
    }

    return $result;
}

# Enhanced write to error log with optional JSON format
func Cannoli_Log_write_error_enhanced(str $level, str $message) void {
    my str $line = "";

    if ($g_json_log == 1) {
        $line = ::error_json($level, $message) . "\n";
    } else {
        my str $timestamp = ::timestamp();
        $line = $timestamp . " [" . $level . "] " . $message . "\n";
    }

    if (length($g_error_log_file) > 0) {
        ::check_rotation();  # Check rotation before writing
        my scalar $fh = sys::open($g_error_log_file, "a");
        if (defined($fh)) {
            sys::fwrite($fh, $line);
            sys::close($fh);
        }
    }

    if ($g_log_to_stderr == 1) {
        print($line);
    }
}

# Enhanced access log with optional JSON format
func Cannoli_Log_access_enhanced(str $remote_ip, str $method, str $path, str $protocol, int $status, int $size, str $referer, str $user_agent, int $time_ms) void {
    # Escape or default values
    if (length($referer) == 0) {
        $referer = "-";
    }
    if (length($user_agent) == 0) {
        $user_agent = "-";
    }

    # Write to file
    if (length($g_access_log_file) > 0) {
        ::check_rotation();  # Check rotation before writing

        my str $line = "";
        if ($g_json_log == 1) {
            $line = ::access_json($remote_ip, $method, $path, $protocol, $status, $size, $referer, $user_agent, $time_ms) . "\n";
        } else {
            my str $timestamp = ::access_timestamp();
            $line = $remote_ip . " - - " . $timestamp . " \"";
            $line = $line . $method . " " . $path . " " . $protocol . "\" ";
            $line = $line . $status . " " . $size . " ";
            $line = $line . "\"" . $referer . "\" \"" . $user_agent . "\" " . $time_ms . "ms\n";
        }

        my scalar $fh = sys::open($g_access_log_file, "a");
        if (defined($fh)) {
            sys::fwrite($fh, $line);
            sys::close($fh);
        }
    }

    # Log to stdout if --debug flag or debug level
    if ($g_log_to_stdout == 1 || $g_log_level >= 4) {
        my str $console_line = "";
        if ($g_json_log == 1) {
            $console_line = ::access_json($remote_ip, $method, $path, $protocol, $status, $size, $referer, $user_agent, $time_ms);
        } else {
            $console_line = ::format_line($g_log_format, $remote_ip, $method, $path, $protocol, $status, $size, $referer, $user_agent, $time_ms);
        }
        say($console_line);
    }
}
