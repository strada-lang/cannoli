/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Validation;


# cannoli/src/validation.strada - Request validation
#
# Provides validation rules for request parameters.
#
# Usage:
#   my scalar $v = Cannoli::Validation::new();
#   Cannoli::Validation::add($v, "email", $email, "required");
#   Cannoli::Validation::add($v, "email", $email, "email");
#   Cannoli::Validation::add($v, "password", $password, "min_length", 8);
#
#   if (Cannoli::Validation::validate($v) == 1) {
#       # Valid
#   } else {
#       my hash %errors = Cannoli::Validation::errors($v);
#   }

# ============================================================
# Individual Validation Rules
# ============================================================

# Check if value is present (not empty)
func Cannoli_Validation_required(scalar $value) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;
    if (length($s) == 0) {
        return 0;
    }
    return 1;
}

# Check if value is a valid Cannoli::Validation::email(basic check)
func Cannoli_Validation_email(scalar $value) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;

    # Must contain @ with something before and after
    my int $at = index($s, "@");
    if ($at < 1) {
        return 0;
    }

    # Must have a dot after @
    my str $domain = substr($s, $at + 1, length($s) - $at - 1);
    my int $dot = index($domain, ".");
    if ($dot < 1) {
        return 0;
    }

    # Must have something after the dot
    if ($dot >= length($domain) - 1) {
        return 0;
    }

    return 1;
}

# Check minimum length
func Cannoli_Validation_min_length(scalar $value, int $min) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;
    return length($s) >= $min;
}

# Check maximum length
func Cannoli_Validation_max_length(scalar $value, int $max) int {
    if (!defined($value)) {
        return 1;  # Undefined values pass max_length
    }
    my str $s = "" . $value;
    return length($s) <= $max;
}

# Check if value is Cannoli::Validation::numeric(integer or decimal)
func Cannoli_Validation_numeric(scalar $value) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;
    if (length($s) == 0) {
        return 0;
    }

    my int $i = 0;
    my int $len = length($s);
    my int $has_digit = 0;
    my int $has_dot = 0;

    # Allow leading minus
    if (substr($s, 0, 1) eq "-") {
        $i = 1;
    }

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch ge "0" && $ch le "9") {
            $has_digit = 1;
        } elsif ($ch eq ".") {
            if ($has_dot == 1) {
                return 0;  # Multiple dots
            }
            $has_dot = 1;
        } else {
            return 0;  # Invalid character
        }
        $i = $i + 1;
    }

    return $has_digit;
}

# Check if value is an integer
func Cannoli_Validation_integer(scalar $value) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;
    if (length($s) == 0) {
        return 0;
    }

    my int $i = 0;
    my int $len = length($s);

    # Allow leading minus
    if (substr($s, 0, 1) eq "-") {
        $i = 1;
    }

    if ($i >= $len) {
        return 0;  # Just a minus sign
    }

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch lt "0" || $ch gt "9") {
            return 0;
        }
        $i = $i + 1;
    }

    return 1;
}

# Check if value matches a regex pattern
func Cannoli_Validation_regex(scalar $value, str $pattern) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;
    if ($s =~ /$pattern/) {
        return 1;
    }
    return 0;
}

# Check if value is in a list of allowed values
func Cannoli_Validation_in(scalar $value, scalar $allowed) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;

    my int $i = 0;
    my int $num = scalar(@{$allowed});
    while ($i < $num) {
        my str $item = "" . $allowed->[$i];
        if ($s eq $item) {
            return 1;
        }
        $i = $i + 1;
    }

    return 0;
}

# Check minimum value (numeric)
func Cannoli_Validation_min(scalar $value, int $min) int {
    if (!::numeric($value)) {
        return 0;
    }
    my int $n = $value + 0;
    return $n >= $min;
}

# Check maximum value (numeric)
func Cannoli_Validation_max(scalar $value, int $max) int {
    if (!::numeric($value)) {
        return 0;
    }
    my int $n = $value + 0;
    return $n <= $max;
}

# Check if value equals another value
func Cannoli_Validation_equals(scalar $value, scalar $other) int {
    if (!defined($value) || !defined($other)) {
        return 0;
    }
    my str $s1 = "" . $value;
    my str $s2 = "" . $other;
    return $s1 eq $s2;
}

# Check if value is alphanumeric only
func Cannoli_Validation_alphanumeric(scalar $value) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;
    if (length($s) == 0) {
        return 0;
    }

    my int $i = 0;
    while ($i < length($s)) {
        my str $ch = substr($s, $i, 1);
        my int $valid = 0;
        if ($ch ge "a" && $ch le "z") { $valid = 1; }
        if ($ch ge "A" && $ch le "Z") { $valid = 1; }
        if ($ch ge "0" && $ch le "9") { $valid = 1; }
        if ($valid == 0) {
            return 0;
        }
        $i = $i + 1;
    }

    return 1;
}

# Check if value looks like a URL
func Cannoli_Validation_url(scalar $value) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;

    # Must start with http:// or https://
    if (substr($s, 0, 7) ne "http://" && substr($s, 0, 8) ne "https://") {
        return 0;
    }

    # Must have something after the protocol
    my int $proto_len = 7;
    if (substr($s, 0, 8) eq "https://") {
        $proto_len = 8;
    }

    my str $rest = substr($s, $proto_len, length($s) - $proto_len);
    if (length($rest) < 3) {
        return 0;
    }

    return 1;
}

# ============================================================
# Validator Object
# ============================================================

# Create a new validator
func Cannoli_Validation_new() scalar {
    my hash %validator = ();
    $validator{"rules"} = [];
    $validator{"errors"} = {};
    $validator{"valid"} = 1;
    return \%validator;
}

# Add a validation rule
# Rules: required, email, min_length, max_length, numeric, integer, regex, in, min, max, alphanumeric, url
func Cannoli_Validation_add(scalar $v, str $field, scalar $value, str $rule, scalar $param) void {
    my hash %entry = ();
    $entry{"field"} = $field;
    $entry{"value"} = $value;
    $entry{"rule"} = $rule;
    $entry{"param"} = $param;
    push(@{$v->{"rules"}}, \%entry);
}

# Run validation
func Cannoli_Validation_validate(scalar $v) int {
    my scalar $rules = $v->{"rules"};
    my scalar $errors = $v->{"errors"};
    my int $all_valid = 1;

    my int $i = 0;
    while ($i < scalar(@{$rules})) {
        my scalar $entry = $rules->[$i];
        my str $field = $entry->{"field"};
        my scalar $value = $entry->{"value"};
        my str $rule = $entry->{"rule"};
        my scalar $param = $entry->{"param"};

        my int $valid = 1;
        my str $error_msg = "";

        # Apply validation rule
        if ($rule eq "required") {
            if (::required($value) == 0) {
                $valid = 0;
                $error_msg = $field . " is required";
            }
        } elsif ($rule eq "email") {
            if (::email($value) == 0) {
                $valid = 0;
                $error_msg = $field . " must be a valid email";
            }
        } elsif ($rule eq "min_length") {
            my int $min = $param + 0;
            if (::min_length($value, $min) == 0) {
                $valid = 0;
                $error_msg = $field . " must be at least " . $min . " characters";
            }
        } elsif ($rule eq "max_length") {
            my int $max = $param + 0;
            if (::max_length($value, $max) == 0) {
                $valid = 0;
                $error_msg = $field . " must be at most " . $max . " characters";
            }
        } elsif ($rule eq "numeric") {
            if (::numeric($value) == 0) {
                $valid = 0;
                $error_msg = $field . " must be numeric";
            }
        } elsif ($rule eq "integer") {
            if (::integer($value) == 0) {
                $valid = 0;
                $error_msg = $field . " must be an integer";
            }
        } elsif ($rule eq "regex") {
            my str $pattern = "" . $param;
            if (::regex($value, $pattern) == 0) {
                $valid = 0;
                $error_msg = $field . " is invalid";
            }
        } elsif ($rule eq "in") {
            if (::in($value, $param) == 0) {
                $valid = 0;
                $error_msg = $field . " must be one of the allowed values";
            }
        } elsif ($rule eq "min") {
            my int $min = $param + 0;
            if (::min($value, $min) == 0) {
                $valid = 0;
                $error_msg = $field . " must be at least " . $min;
            }
        } elsif ($rule eq "max") {
            my int $max = $param + 0;
            if (::max($value, $max) == 0) {
                $valid = 0;
                $error_msg = $field . " must be at most " . $max;
            }
        } elsif ($rule eq "alphanumeric") {
            if (::alphanumeric($value) == 0) {
                $valid = 0;
                $error_msg = $field . " must be alphanumeric";
            }
        } elsif ($rule eq "url") {
            if (::url($value) == 0) {
                $valid = 0;
                $error_msg = $field . " must be a valid URL";
            }
        }

        # Record error if invalid
        if ($valid == 0) {
            $all_valid = 0;
            # Store first error per field
            if (!exists(%{$errors}, $field)) {
                $errors->{$field} = $error_msg;
            }
        }

        $i = $i + 1;
    }

    $v->{"valid"} = $all_valid;
    return $all_valid;
}

# Get validation Cannoli::Validation::errors(hash of field => error message)
func Cannoli_Validation_errors(scalar $v) scalar {
    return $v->{"errors"};
}

# Check if validation passed
func Cannoli_Validation_is_valid(scalar $v) int {
    return $v->{"valid"};
}

# Get error for a specific field
func Cannoli_Validation_error(scalar $v, str $field) str {
    my scalar $errors = $v->{"errors"};
    if (exists(%{$errors}, $field)) {
        return $errors->{$field};
    }
    return "";
}

# ============================================================
# Cannoli Integration - Declarative Validation
# ============================================================

# Create validator from a rules hash
# rules format: { "field" => ["rule1", "rule2:param", ...] }
# e.g.: { "email" => ["required", "email"], "age" => ["required", "integer", "min:18"] }
func Cannoli_Validation_from_rules(scalar $params, scalar $rules) scalar {
    my scalar $v = ::new();

    my array @fields = keys(%{$rules});
    my int $i = 0;

    while ($i < scalar(@fields)) {
        my str $field = @fields[$i];
        my scalar $field_rules = $rules->{$field};

        # Get value from params
        my scalar $value = undef;
        if (defined($params) && exists(%{$params}, $field)) {
            $value = $params->{$field};
        }

        # Process each rule
        my int $j = 0;
        while ($j < scalar(@{$field_rules})) {
            my str $rule_spec = "" . $field_rules->[$j];

            # Parse rule:param format
            my str $rule = $rule_spec;
            my scalar $param = undef;
            my int $colon = index($rule_spec, ":");

            if ($colon > 0) {
                $rule = substr($rule_spec, 0, $colon);
                my str $param_str = substr($rule_spec, $colon + 1, length($rule_spec) - $colon - 1);
                $param = $param_str;
            }

            ::add($v, $field, $value, $rule, $param);
            $j = $j + 1;
        }

        $i = $i + 1;
    }

    return $v;
}
