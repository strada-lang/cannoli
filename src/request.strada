/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Request;


# cannoli/src/request.strada - HTTP Request parsing
#
# Parses incoming HTTP requests into a structured format

# Create a new empty request object
func Cannoli_Request_new() hash {
    my hash %req = ();

    $req{"method"} = "GET";
    $req{"uri"} = "/";
    $req{"path"} = "/";
    $req{"query_string"} = "";
    $req{"http_version"} = "HTTP/1.1";
    $req{"headers"} = {};
    $req{"body"} = "";
    $req{"content_length"} = "0";
    $req{"content_type"} = "";
    $req{"params"} = {};
    $req{"captures"} = [];
    $req{"remote_addr"} = "";
    $req{"remote_port"} = "0";

    return %req;
}

# Parse an HTTP request from raw data
func Cannoli_Request_parse(str $data) hash {
    my hash %req = ::new();

    # Split headers and body
    my int $body_start = index($data, "\r\n\r\n");
    my str $header_section = $data;
    my str $body = "";

    if ($body_start >= 0) {
        $header_section = substr($data, 0, $body_start);
        $body = substr($data, $body_start + 4, length($data) - $body_start - 4);
    }

    # Parse request line
    my array @lines = split("\r\n", $header_section);
    if (scalar(@lines) < 1) {
        return %req;
    }

    my str $request_line = @lines[0];
    my array @parts = split(" ", $request_line);

    if (scalar(@parts) >= 3) {
        $req{"method"} = @parts[0];
        $req{"uri"} = @parts[1];
        $req{"http_version"} = @parts[2];

        # Parse path and query string
        my str $uri = @parts[1];
        my int $q_pos = index($uri, "?");
        if ($q_pos >= 0) {
            $req{"path"} = substr($uri, 0, $q_pos);
            $req{"query_string"} = substr($uri, $q_pos + 1, length($uri) - $q_pos - 1);
        } else {
            $req{"path"} = $uri;
        }
    }

    # Parse headers
    my hash %headers = ();
    my int $i = 1;
    while ($i < scalar(@lines)) {
        my str $line = @lines[$i];
        my int $colon = index($line, ":");

        if ($colon > 0) {
            my str $name = substr($line, 0, $colon);
            my str $value = substr($line, $colon + 1, length($line) - $colon - 1);

            # Trim leading space from value
            if (length($value) > 0 && substr($value, 0, 1) eq " ") {
                $value = substr($value, 1, length($value) - 1);
            }

            # Normalize header name to lowercase
            $name = ::header_normalize($name);
            $headers{$name} = $value;
        }

        $i = $i + 1;
    }

    $req{"headers"} = \%headers;
    $req{"body"} = $body;

    # Extract common headers
    if (exists(%headers, "content-length")) {
        $req{"content_length"} = $headers{"content-length"};
    }
    if (exists(%headers, "content-type")) {
        $req{"content_type"} = $headers{"content-type"};
    }

    # Parse query parameters
    if (length($req{"query_string"}) > 0) {
        $req{"params"} = ::parse_query($req{"query_string"});
    }

    # Parse POST/PUT body if form data
    my str $method = $req{"method"};
    if (($method eq "POST" || $method eq "PUT" || $method eq "PATCH") && length($body) > 0) {
        my str $ct = $req{"content_type"};

        if (index($ct, "multipart/form-data") >= 0) {
            # Parse multipart form data (file uploads)
            my str $boundary = ::extract_boundary($ct);
            if (length($boundary) > 0) {
                my hash %multipart = ::parse_multipart($body, $boundary);

                # Store files
                $req{"files"} = $multipart{"files"};

                # Merge form fields with params
                my hash %params = %{$req{"params"}};
                my scalar $mp_params = $multipart{"params"};
                my array @k = keys(%{$mp_params});
                my int $j = 0;
                while ($j < scalar(@k)) {
                    my str $key = @k[$j];
                    $params{$key} = $mp_params->{$key};
                    $j = $j + 1;
                }
                $req{"params"} = \%params;
            }
        } elsif (index($ct, "application/x-www-form-urlencoded") >= 0) {
            my scalar $body_params = ::parse_query($body);
            # Merge with existing params
            my hash %params = %{$req{"params"}};
            my array @k = keys(%{$body_params});
            my int $j = 0;
            while ($j < scalar(@k)) {
                my str $key = @k[$j];
                $params{$key} = $body_params->{$key};
                $j = $j + 1;
            }
            $req{"params"} = \%params;
        }
    }

    # Initialize files hash if not set
    if (!exists(%req, "files")) {
        my hash %empty_files = ();
        $req{"files"} = \%empty_files;
    }

    return %req;
}

# Parse query string into hash
func Cannoli_Request_parse_query(str $qs) scalar {
    my hash %params = ();

    if (length($qs) == 0) {
        return \%params;
    }

    my array @pairs = split("&", $qs);
    my int $i = 0;

    while ($i < scalar(@pairs)) {
        my str $pair = @pairs[$i];
        my int $eq_idx = index($pair, "=");

        if ($eq_idx > 0) {
            my str $key = ::url_decode(substr($pair, 0, $eq_idx));
            my str $val = ::url_decode(substr($pair, $eq_idx + 1, length($pair) - $eq_idx - 1));
            $params{$key} = $val;
        } elsif (length($pair) > 0) {
            $params{::url_decode($pair)} = "";
        }

        $i = $i + 1;
    }

    return \%params;
}

# URL decode a string
func Cannoli_Request_url_decode(str $s) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        if ($ch eq "+") {
            $result = $result . " ";
        } elsif ($ch eq "%" && $i + 2 < $len) {
            my str $hex = substr($s, $i + 1, 2);
            my int $code = ::hex_to_int($hex);
            if ($code >= 0) {
                $result = $result . chr($code);
                $i = $i + 2;
            } else {
                $result = $result . $ch;
            }
        } else {
            $result = $result . $ch;
        }

        $i = $i + 1;
    }

    return $result;
}

# Convert hex string to integer
func Cannoli_Request_hex_to_int(str $hex) int {
    my int $result = 0;
    my int $i = 0;
    my int $len = length($hex);

    while ($i < $len) {
        my str $ch = substr($hex, $i, 1);
        my int $code = ord($ch);
        my int $digit = 0;

        if ($code >= 48 && $code <= 57) {
            # 0-9
            $digit = $code - 48;
        } elsif ($code >= 65 && $code <= 70) {
            # A-F
            $digit = $code - 55;
        } elsif ($code >= 97 && $code <= 102) {
            # a-f
            $digit = $code - 87;
        } else {
            return -1;
        }

        $result = $result * 16 + $digit;
        $i = $i + 1;
    }

    return $result;
}

# Normalize header name (lowercase)
func Cannoli_Request_header_normalize(str $name) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($name);

    while ($i < $len) {
        my str $ch = substr($name, $i, 1);
        my int $code = ord($ch);

        # A-Z -> a-z
        if ($code >= 65 && $code <= 90) {
            $result = $result . chr($code + 32);
        } else {
            $result = $result . $ch;
        }
        $i = $i + 1;
    }

    return $result;
}

# Get a header value (case-insensitive)
func Cannoli_Request_get_header(hash %req, str $name) str {
    my str $normalized = ::header_normalize($name);
    my scalar $headers = $req{"headers"};

    if (exists(%{$headers}, $normalized)) {
        return $headers->{$normalized};
    }
    return "";
}

# Get a parameter value
func Cannoli_Request_get_param(hash %req, str $name) str {
    my scalar $params = $req{"params"};

    if (exists(%{$params}, $name)) {
        return $params->{$name};
    }
    return "";
}

# Check if request is a specific method
func Cannoli_Request_is_get(hash %req) int {
    return $req{"method"} eq "GET";
}

func Cannoli_Request_is_post(hash %req) int {
    return $req{"method"} eq "POST";
}

func Cannoli_Request_is_put(hash %req) int {
    return $req{"method"} eq "PUT";
}

func Cannoli_Request_is_delete(hash %req) int {
    return $req{"method"} eq "DELETE";
}

# Get all headers as a hash reference
func Cannoli_Request_headers(hash %req) scalar {
    return $req{"headers"};
}

# Check if a header exists
func Cannoli_Request_has_header(hash %req, str $name) int {
    my str $normalized = ::header_normalize($name);
    my scalar $headers = $req{"headers"};
    return exists(%{$headers}, $normalized);
}

# Get all header names as an array
func Cannoli_Request_header_names(hash %req) array {
    my scalar $headers = $req{"headers"};
    return keys(%{$headers});
}

# Get a cookie value from the Cookie header
func Cannoli_Request_get_cookie(hash %req, str $name) str {
    my str $cookie_header = ::get_header(%req, "Cookie");
    if (length($cookie_header) == 0) {
        return "";
    }

    # Parse cookies: "name1=value1; name2=value2"
    my array @pairs = split(";", $cookie_header);
    my int $i = 0;
    while ($i < scalar(@pairs)) {
        my str $pair = trim(@pairs[$i]);
        my int $eq_pos = index($pair, "=");
        if ($eq_pos > 0) {
            my str $cookie_name = substr($pair, 0, $eq_pos);
            if ($cookie_name eq $name) {
                return substr($pair, $eq_pos + 1, length($pair) - $eq_pos - 1);
            }
        }
        $i = $i + 1;
    }
    return "";
}

# Get all cookies as a hash
func Cannoli_Request_cookies(hash %req) hash {
    my hash %cookies = ();
    my str $cookie_header = ::get_header(%req, "Cookie");
    if (length($cookie_header) == 0) {
        return %cookies;
    }

    my array @pairs = split(";", $cookie_header);
    my int $i = 0;
    while ($i < scalar(@pairs)) {
        my str $pair = trim(@pairs[$i]);
        my int $eq_pos = index($pair, "=");
        if ($eq_pos > 0) {
            my str $name = substr($pair, 0, $eq_pos);
            my str $value = substr($pair, $eq_pos + 1, length($pair) - $eq_pos - 1);
            $cookies{$name} = $value;
        }
        $i = $i + 1;
    }
    return %cookies;
}

# Get the User-Agent header
func Cannoli_Request_user_agent(hash %req) str {
    return ::get_header(%req, "User-Agent");
}

# Get the Referer header
func Cannoli_Request_referer(hash %req) str {
    return ::get_header(%req, "Referer");
}

# Get the Host header
func Cannoli_Request_host(hash %req) str {
    return ::get_header(%req, "Host");
}

# Check if request accepts JSON
func Cannoli_Request_accepts_json(hash %req) int {
    my str $accept = ::get_header(%req, "Accept");
    if (index($accept, "application/json") >= 0) {
        return 1;
    }
    if (index($accept, "*/*") >= 0) {
        return 1;
    }
    return 0;
}

# Check if request is AJAX/XHR
func Cannoli_Request_is_ajax(hash %req) int {
    my str $xhr = ::get_header(%req, "X-Requested-With");
    return $xhr eq "XMLHttpRequest";
}

# Check if a parameter exists
func Cannoli_Request_has_param(hash %req, str $name) int {
    my scalar $params = $req{"params"};
    return exists(%{$params}, $name);
}

# ============================================================
# Multipart Form Data Parsing (File Uploads)
# ============================================================

# Extract boundary from Content-Type header
# Content-Type: multipart/form-data; boundary=----WebKitFormBoundary...
func Cannoli_Request_extract_boundary(str $content_type) str {
    # Check if multipart
    if (index($content_type, "multipart/form-data") < 0) {
        return "";
    }

    # Find boundary parameter
    my int $bound_pos = index($content_type, "boundary=");
    if ($bound_pos < 0) {
        return "";
    }

    # Extract boundary value (after "boundary=")
    my str $boundary = substr($content_type, $bound_pos + 9, length($content_type) - $bound_pos - 9);

    # Remove quotes if present
    if (length($boundary) > 0 && substr($boundary, 0, 1) eq "\"") {
        $boundary = substr($boundary, 1, length($boundary) - 1);
        my int $quote_end = index($boundary, "\"");
        if ($quote_end >= 0) {
            $boundary = substr($boundary, 0, $quote_end);
        }
    }

    # Remove trailing semicolon or whitespace
    my int $semi_pos = index($boundary, ";");
    if ($semi_pos >= 0) {
        $boundary = substr($boundary, 0, $semi_pos);
    }

    return $boundary;
}

# Extract a parameter value from Content-Disposition header
# e.g., form-data; name="fieldname"; filename="file.txt"
func Cannoli_Request_extract_disposition_param(str $header, str $param_name) str {
    my str $search = $param_name . "=\"";
    my int $pos = index($header, $search);
    if ($pos < 0) {
        # Try without quotes
        $search = $param_name . "=";
        $pos = index($header, $search);
        if ($pos < 0) {
            return "";
        }
        # Extract unquoted value (until ; or end)
        my str $value = substr($header, $pos + length($search), length($header) - $pos - length($search));
        my int $end_pos = index($value, ";");
        if ($end_pos >= 0) {
            $value = substr($value, 0, $end_pos);
        }
        return $value;
    }

    # Extract quoted value
    my str $rest = substr($header, $pos + length($search), length($header) - $pos - length($search));
    my int $quote_end = index($rest, "\"");
    if ($quote_end < 0) {
        return $rest;
    }
    return substr($rest, 0, $quote_end);
}

# Parse a single multipart part
# Returns hash with: name, filename, content_type, content, size
func Cannoli_Request_parse_multipart_part(str $part) hash {
    my hash %result = ();
    $result{"name"} = "";
    $result{"filename"} = "";
    $result{"content_type"} = "text/plain";
    $result{"content"} = "";
    $result{"size"} = 0;

    # Split headers from content (blank line separator)
    my int $split_pos = index($part, "\r\n\r\n");
    if ($split_pos < 0) {
        # Try just \n\n
        $split_pos = index($part, "\n\n");
        if ($split_pos < 0) {
            return %result;
        }
        my str $content = substr($part, $split_pos + 2, length($part) - $split_pos - 2);
        $result{"content"} = $content;
        $result{"size"} = length($content);
        # Note: headers not parsed in \n\n case (simplified handling)
    } else {
        my str $headers_section = substr($part, 0, $split_pos);
        my str $content = substr($part, $split_pos + 4, length($part) - $split_pos - 4);
        $result{"content"} = $content;
        $result{"size"} = length($content);

        # Parse headers
        my array @header_lines = split("\r\n", $headers_section);
        my int $i = 0;
        while ($i < scalar(@header_lines)) {
            my str $line = @header_lines[$i];
            my str $line_lower = ::header_normalize($line);

            if (index($line_lower, "content-disposition:") == 0) {
                # Extract name and filename from Content-Disposition
                $result{"name"} = ::extract_disposition_param($line, "name");
                $result{"filename"} = ::extract_disposition_param($line, "filename");
            } elsif (index($line_lower, "content-type:") == 0) {
                # Extract content type (after "Content-Type: ")
                my int $colon_pos = index($line, ":");
                if ($colon_pos >= 0) {
                    my str $ct = substr($line, $colon_pos + 1, length($line) - $colon_pos - 1);
                    # Trim leading space
                    if (length($ct) > 0 && substr($ct, 0, 1) eq " ") {
                        $ct = substr($ct, 1, length($ct) - 1);
                    }
                    $result{"content_type"} = $ct;
                }
            }
            $i = $i + 1;
        }
    }

    return %result;
}

# Parse multipart form data body
# Returns hash with: params (hash ref), Cannoli::Request::files(hash ref)
func Cannoli_Request_parse_multipart(str $body, str $boundary) hash {
    my hash %result = ();
    my hash %params = ();
    my hash %files = ();

    # Parts are separated by --boundary
    my str $delim = "--" . $boundary;
    my str $end_delim = "--" . $boundary . "--";

    # Remove trailing boundary marker if present
    my int $end_pos = index($body, $end_delim);
    if ($end_pos >= 0) {
        $body = substr($body, 0, $end_pos);
    }

    # Split on delimiter
    my array @parts = split($delim, $body);
    my int $i = 0;

    while ($i < scalar(@parts)) {
        my str $part = @parts[$i];

        # Skip empty parts and preamble
        if (length($part) > 2) {
            # Remove leading \r\n if present
            if (substr($part, 0, 2) eq "\r\n") {
                $part = substr($part, 2, length($part) - 2);
            }
            # Remove trailing \r\n if present
            if (length($part) >= 2 && substr($part, length($part) - 2, 2) eq "\r\n") {
                $part = substr($part, 0, length($part) - 2);
            }

            if (length($part) > 0) {
                my hash %parsed = ::parse_multipart_part($part);
                my str $name = $parsed{"name"};
                my str $filename = $parsed{"filename"};

                if (length($name) > 0) {
                    if (length($filename) > 0) {
                        # This is a file upload
                        $files{$name} = \%parsed;
                    } else {
                        # This is a regular form field
                        $params{$name} = $parsed{"content"};
                    }
                }
            }
        }

        $i = $i + 1;
    }

    $result{"params"} = \%params;
    $result{"files"} = \%files;
    return %result;
}

# Get an uploaded file by field name
func Cannoli_Request_get_file(hash %req, str $name) scalar {
    if (!exists(%req, "files")) {
        return undef;
    }
    my scalar $files = $req{"files"};
    if (exists(%{$files}, $name)) {
        return $files->{$name};
    }
    return undef;
}

# Check if a file was uploaded with the given field name
func Cannoli_Request_has_file(hash %req, str $name) int {
    if (!exists(%req, "files")) {
        return 0;
    }
    my scalar $files = $req{"files"};
    return exists(%{$files}, $name);
}

# Get all uploaded files as a hash reference
func Cannoli_Request_files(hash %req) scalar {
    if (!exists(%req, "files")) {
        my hash %empty = ();
        return \%empty;
    }
    return $req{"files"};
}

# Get file content from a file hash
func Cannoli_Request_file_content(scalar $file) str {
    if (length($file) == 0) {
        return "";
    }
    return $file->{"content"};
}

# Get original filename from a file hash
func Cannoli_Request_file_name(scalar $file) str {
    if (length($file) == 0) {
        return "";
    }
    return $file->{"filename"};
}

# Get file size from a file hash
func Cannoli_Request_file_size(scalar $file) int {
    if (length($file) == 0) {
        return 0;
    }
    return $file->{"size"};
}

# Get content type from a file hash
func Cannoli_Request_file_type(scalar $file) str {
    if (length($file) == 0) {
        return "";
    }
    return $file->{"content_type"};
}

#
# JSON Body Parsing
#

# Check if request has JSON content type
func Cannoli_Request_is_json(hash %req) int {
    my str $ct = $req{"content_type"};
    if (index($ct, "application/json") >= 0) {
        return 1;
    }
    return 0;
}

# Parse JSON body - simple JSON parser
# Returns parsed structure or undef on error
func Cannoli_Request_parse_json_body(hash %req) scalar {
    if (::is_json(%req) == 0) {
        return undef;
    }
    my str $body = $req{"body"};
    if (length($body) == 0) {
        return undef;
    }
    return ::json_parse($body);
}

# Simple JSON parser
# Handles: objects, arrays, strings, numbers, true, false, null
func Cannoli_Request_json_parse(str $json) scalar {
    my int $pos = 0;
    my int $len = length($json);

    # Skip whitespace
    while ($pos < $len) {
        my str $ch = substr($json, $pos, 1);
        if ($ch ne " " && $ch ne "\t" && $ch ne "\n" && $ch ne "\r") {
            last;
        }
        $pos = $pos + 1;
    }

    if ($pos >= $len) {
        return undef;
    }

    my str $ch = substr($json, $pos, 1);

    # Object
    if ($ch eq "{") {
        return ::json_parse_object($json, $pos);
    }

    # Array
    if ($ch eq "[") {
        return ::json_parse_array($json, $pos);
    }

    # String
    if ($ch eq "\"") {
        my scalar $result = ::json_parse_string($json, $pos);
        return $result->{"value"};
    }

    # Number, true, false, null
    return ::json_parse_value($json, $pos);
}

# Parse JSON object starting at pos, returns {value, end_pos}
func Cannoli_Request_json_parse_object(str $json, int $start) scalar {
    my hash %obj = ();
    my int $pos = $start + 1;  # Skip '{'
    my int $len = length($json);

    while ($pos < $len) {
        # Skip whitespace
        while ($pos < $len) {
            my str $ch = substr($json, $pos, 1);
            if ($ch ne " " && $ch ne "\t" && $ch ne "\n" && $ch ne "\r") {
                last;
            }
            $pos = $pos + 1;
        }

        if ($pos >= $len) { last; }

        my str $ch = substr($json, $pos, 1);

        # End of object
        if ($ch eq "}") {
            return \%obj;
        }

        # Expect string key
        if ($ch ne "\"") {
            return undef;
        }

        my scalar $key_result = ::json_parse_string($json, $pos);
        if (!defined($key_result)) { return undef; }
        my str $key = $key_result->{"value"};
        $pos = $key_result->{"end_pos"};

        # Skip whitespace and colon
        while ($pos < $len) {
            my str $c = substr($json, $pos, 1);
            if ($c ne " " && $c ne "\t" && $c ne "\n" && $c ne "\r") {
                last;
            }
            $pos = $pos + 1;
        }

        if ($pos >= $len || substr($json, $pos, 1) ne ":") {
            return undef;
        }
        $pos = $pos + 1;

        # Skip whitespace
        while ($pos < $len) {
            my str $c = substr($json, $pos, 1);
            if ($c ne " " && $c ne "\t" && $c ne "\n" && $c ne "\r") {
                last;
            }
            $pos = $pos + 1;
        }

        # Parse value
        my scalar $val_result = ::json_parse_any($json, $pos);
        if (!defined($val_result)) { return undef; }
        $obj{$key} = $val_result->{"value"};
        $pos = $val_result->{"end_pos"};

        # Skip whitespace
        while ($pos < $len) {
            my str $c = substr($json, $pos, 1);
            if ($c ne " " && $c ne "\t" && $c ne "\n" && $c ne "\r") {
                last;
            }
            $pos = $pos + 1;
        }

        if ($pos >= $len) { last; }

        $ch = substr($json, $pos, 1);
        if ($ch eq "}") {
            return \%obj;
        }
        if ($ch eq ",") {
            $pos = $pos + 1;
        }
    }

    return \%obj;
}

# Parse JSON array starting at pos
func Cannoli_Request_json_parse_array(str $json, int $start) scalar {
    my array @arr = ();
    my int $pos = $start + 1;  # Skip '['
    my int $len = length($json);

    while ($pos < $len) {
        # Skip whitespace
        while ($pos < $len) {
            my str $ch = substr($json, $pos, 1);
            if ($ch ne " " && $ch ne "\t" && $ch ne "\n" && $ch ne "\r") {
                last;
            }
            $pos = $pos + 1;
        }

        if ($pos >= $len) { last; }

        my str $ch = substr($json, $pos, 1);

        # End of array
        if ($ch eq "]") {
            return \@arr;
        }

        # Parse value
        my scalar $val_result = ::json_parse_any($json, $pos);
        if (!defined($val_result)) { return undef; }
        push(@arr, $val_result->{"value"});
        $pos = $val_result->{"end_pos"};

        # Skip whitespace
        while ($pos < $len) {
            my str $c = substr($json, $pos, 1);
            if ($c ne " " && $c ne "\t" && $c ne "\n" && $c ne "\r") {
                last;
            }
            $pos = $pos + 1;
        }

        if ($pos >= $len) { last; }

        $ch = substr($json, $pos, 1);
        if ($ch eq "]") {
            return \@arr;
        }
        if ($ch eq ",") {
            $pos = $pos + 1;
        }
    }

    return \@arr;
}

# Parse JSON string starting at pos, returns {value, end_pos}
func Cannoli_Request_json_parse_string(str $json, int $start) scalar {
    my str $result = "";
    my int $pos = $start + 1;  # Skip opening quote
    my int $len = length($json);

    while ($pos < $len) {
        my str $ch = substr($json, $pos, 1);

        if ($ch eq "\"") {
            my hash %ret = ();
            $ret{"value"} = $result;
            $ret{"end_pos"} = $pos + 1;
            return \%ret;
        }

        if ($ch eq "\\") {
            $pos = $pos + 1;
            if ($pos >= $len) { last; }
            my str $esc = substr($json, $pos, 1);
            if ($esc eq "n") { $result = $result . "\n"; }
            elsif ($esc eq "r") { $result = $result . "\r"; }
            elsif ($esc eq "t") { $result = $result . "\t"; }
            elsif ($esc eq "\"") { $result = $result . "\""; }
            elsif ($esc eq "\\") { $result = $result . "\\"; }
            elsif ($esc eq "/") { $result = $result . "/"; }
            else { $result = $result . $esc; }
        } else {
            $result = $result . $ch;
        }

        $pos = $pos + 1;
    }

    my hash %ret = ();
    $ret{"value"} = $result;
    $ret{"end_pos"} = $pos;
    return \%ret;
}

# Parse any JSON value, returns {value, end_pos}
func Cannoli_Request_json_parse_any(str $json, int $start) scalar {
    my int $pos = $start;
    my int $len = length($json);

    # Skip whitespace
    while ($pos < $len) {
        my str $ch = substr($json, $pos, 1);
        if ($ch ne " " && $ch ne "\t" && $ch ne "\n" && $ch ne "\r") {
            last;
        }
        $pos = $pos + 1;
    }

    if ($pos >= $len) {
        return undef;
    }

    my str $ch = substr($json, $pos, 1);

    # Object
    if ($ch eq "{") {
        my scalar $obj = ::json_parse_object($json, $pos);
        # Find end position by scanning past the object
        my int $end = ::json_find_end($json, $pos, "{", "}");
        my hash %ret = ();
        $ret{"value"} = $obj;
        $ret{"end_pos"} = $end;
        return \%ret;
    }

    # Array
    if ($ch eq "[") {
        my scalar $arr = ::json_parse_array($json, $pos);
        my int $end = ::json_find_end($json, $pos, "[", "]");
        my hash %ret = ();
        $ret{"value"} = $arr;
        $ret{"end_pos"} = $end;
        return \%ret;
    }

    # String
    if ($ch eq "\"") {
        return ::json_parse_string($json, $pos);
    }

    # true, false, null, or number
    if (substr($json, $pos, 4) eq "true") {
        my hash %ret = ();
        $ret{"value"} = 1;
        $ret{"end_pos"} = $pos + 4;
        return \%ret;
    }
    if (substr($json, $pos, 5) eq "false") {
        my hash %ret = ();
        $ret{"value"} = 0;
        $ret{"end_pos"} = $pos + 5;
        return \%ret;
    }
    if (substr($json, $pos, 4) eq "null") {
        my hash %ret = ();
        $ret{"value"} = undef;
        $ret{"end_pos"} = $pos + 4;
        return \%ret;
    }

    # Number
    my str $num_str = "";
    while ($pos < $len) {
        $ch = substr($json, $pos, 1);
        if ($ch eq "-" || $ch eq "+" || $ch eq "." || ($ch ge "0" && $ch le "9") || $ch eq "e" || $ch eq "E") {
            $num_str = $num_str . $ch;
            $pos = $pos + 1;
        } else {
            last;
        }
    }

    my hash %ret = ();
    if (index($num_str, ".") >= 0) {
        $ret{"value"} = 0.0 + $num_str;  # Convert to float
    } else {
        $ret{"value"} = 0 + $num_str;  # Convert to int
    }
    $ret{"end_pos"} = $pos;
    return \%ret;
}

# Find matching end bracket/brace
func Cannoli_Request_json_find_end(str $json, int $start, str $open, str $close) int {
    my int $depth = 0;
    my int $pos = $start;
    my int $len = length($json);
    my int $in_string = 0;

    while ($pos < $len) {
        my str $ch = substr($json, $pos, 1);

        if ($in_string == 1) {
            if ($ch eq "\\") {
                $pos = $pos + 2;
                next;
            }
            if ($ch eq "\"") {
                $in_string = 0;
            }
        } else {
            if ($ch eq "\"") {
                $in_string = 1;
            } elsif ($ch eq $open) {
                $depth = $depth + 1;
            } elsif ($ch eq $close) {
                $depth = $depth - 1;
                if ($depth == 0) {
                    return $pos + 1;
                }
            }
        }

        $pos = $pos + 1;
    }

    return $len;
}

# Parse JSON value (for top-level primitives)
func Cannoli_Request_json_parse_value(str $json, int $pos) scalar {
    my scalar $result = ::json_parse_any($json, $pos);
    if (defined($result)) {
        return $result->{"value"};
    }
    return undef;
}
