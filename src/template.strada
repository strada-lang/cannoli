/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Template;


# cannoli/src/template.strada - Template rendering engine
#
# Simple template rendering with variable substitution.
# Supports {{variable}}, {{obj.field}}, loops, and conditionals.
#
# Usage:
#   Cannoli::Template::init("./templates");
#   my str $html = Cannoli::Template::render("user.html", {"name" => "Alice", "id" => 42});
#
# Template syntax:
#   {{name}}              - simple variable
#   {{user.name}}         - nested object field
#   {{user.address.city}} - deeply nested field
#
#   {{#each items}}       - loop over array (fields merged into scope)
#     {{name}}            - access current item fields directly
#   {{/each}}
#
#   {{#each item in items}} - loop with named variable
#     {{item.name}}         - access via named variable
#     {{@index}}            - current index (0-based)
#     {{@first}}            - true if first iteration
#     {{@last}}             - true if last iteration
#   {{/each}}
#
#   {{#set varname = value}}  - set a variable
#     {{#set name = user.name}}
#     {{#set greeting = "Hello"}}
#     {{#set count = 42}}
#
#   {{#with object}}      - change scope to object
#     {{name}}            - accesses object.name directly
#   {{/with}}
#
#   {{dump varname}}      - debug dump of variable (JSON-like format)
#
#   {{#if condition}}     - conditional (truthy check)
#     ...
#   {{else}}              - optional else clause
#     ...
#   {{/if}}

# Template cache
my hash %g_template_cache = ();
my str $g_template_dir = "./templates";
my int $g_cache_enabled = 1;

# Initialize template system with directory
func Cannoli_Template_init(str $dir) void {
    $g_template_dir = $dir;
}

# Set template directory
func Cannoli_Template_set_dir(str $dir) void {
    $g_template_dir = $dir;
}

# Get template directory
func Cannoli_Template_get_dir() str {
    return $g_template_dir;
}

# Enable/disable template caching
func Cannoli_Template_set_cache(int $enabled) void {
    $g_cache_enabled = $enabled;
}

# Clear template cache
func Cannoli_Template_clear_cache() void {
    %g_template_cache = ();
}

# Load a template file (with caching)
func Cannoli_Template_load(str $name) str {
    # Check cache first
    if ($g_cache_enabled == 1 && exists(%g_template_cache, $name)) {
        return $g_template_cache{$name};
    }

    # Build full path
    my str $path = $g_template_dir . "/" . $name;

    # Check if file exists
    if (sys::is_file($path) == 0) {
        return "";
    }

    # Load file content
    my str $content = slurp($path);

    # Cache if enabled
    if ($g_cache_enabled == 1) {
        $g_template_cache{$name} = $content;
    }

    return $content;
}

# Render a template file with variables
func Cannoli_Template_render(str $name, scalar $vars) str {
    my str $template = ::load($name);
    if (length($template) == 0) {
        return "";
    }
    return ::render_string($template, $vars);
}

# Render a template string with variables
func Cannoli_Template_render_string(str $template, scalar $vars) str {
    my str $result = "";
    my int $len = length($template);
    my int $i = 0;

    while ($i < $len) {
        # Check for {{#each ...}}
        if ($i + 7 < $len) {
            my str $check_each = substr($template, $i, 7);
            if ($check_each eq "{{#each") {
                # Find the closing }} of the opening tag
                my int $tag_end = ::find_closing($template, $i + 7);
                if ($tag_end > $i + 7) {
                    # Extract the each expression
                    my str $each_expr = substr($template, $i + 7, $tag_end - $i - 7);
                    $each_expr = trim($each_expr);

                    # Check for "item in items" syntax
                    my str $loop_var = "";
                    my str $collection_name = $each_expr;
                    my int $in_pos = index($each_expr, " in ");
                    if ($in_pos > 0) {
                        $loop_var = substr($each_expr, 0, $in_pos);
                        $collection_name = substr($each_expr, $in_pos + 4, length($each_expr) - $in_pos - 4);
                        $loop_var = trim($loop_var);
                        $collection_name = trim($collection_name);
                    }

                    # Find matching {{/each}}
                    my int $block_end = ::find_block_end($template, $tag_end + 2, "each");
                    if ($block_end > 0) {
                        # Extract body
                        my str $body = substr($template, $tag_end + 2, $block_end - $tag_end - 2);

                        # Process the each block
                        my str $rendered = ::process_each_named($collection_name, $loop_var, $body, $vars);
                        $result = $result . $rendered;

                        # Skip past {{/each}}
                        $i = $block_end + 9;
                        next;
                    }
                }
            }
        }

        # Check for {{#if ...}}
        if ($i + 5 < $len) {
            my str $check_if = substr($template, $i, 5);
            if ($check_if eq "{{#if") {
                # Find the closing }} of the opening tag
                my int $tag_end = ::find_closing($template, $i + 5);
                if ($tag_end > $i + 5) {
                    # Extract condition variable
                    my str $condition = substr($template, $i + 5, $tag_end - $i - 5);
                    $condition = trim($condition);

                    # Find matching {{/if}}
                    my int $block_end = ::find_block_end($template, $tag_end + 2, "if");
                    if ($block_end > 0) {
                        # Check for {{else}}
                        my int $else_pos = ::find_else($template, $tag_end + 2, $block_end);

                        my str $if_body = "";
                        my str $else_body = "";

                        if ($else_pos > 0) {
                            $if_body = substr($template, $tag_end + 2, $else_pos - $tag_end - 2);
                            $else_body = substr($template, $else_pos + 8, $block_end - $else_pos - 8);
                        } else {
                            $if_body = substr($template, $tag_end + 2, $block_end - $tag_end - 2);
                        }

                        # Process the if block
                        my str $rendered = ::process_if($condition, $if_body, $else_body, $vars);
                        $result = $result . $rendered;

                        # Skip past {{/if}}
                        $i = $block_end + 7;
                        next;
                    }
                }
            }
        }

        # Check for {{#set varname = value}}
        if ($i + 6 < $len) {
            my str $check_set = substr($template, $i, 6);
            if ($check_set eq "{{#set") {
                # Find the closing }}
                my int $tag_end = ::find_closing($template, $i + 6);
                if ($tag_end > $i + 6) {
                    # Extract the set expression: "varname = value"
                    my str $set_expr = substr($template, $i + 6, $tag_end - $i - 6);
                    $set_expr = trim($set_expr);

                    # Parse "varname = value"
                    my int $eq_pos = index($set_expr, "=");
                    if ($eq_pos > 0) {
                        my str $var_name = substr($set_expr, 0, $eq_pos);
                        my str $value_expr = substr($set_expr, $eq_pos + 1, length($set_expr) - $eq_pos - 1);
                        $var_name = trim($var_name);
                        $value_expr = trim($value_expr);

                        # Resolve the value
                        my scalar $value = ::resolve_value($value_expr, $vars);

                        # Set in vars (modify in place)
                        $vars->{$var_name} = $value;
                    }

                    # Skip past }}
                    $i = $tag_end + 2;
                    next;
                }
            }
        }

        # Check for {{#with object}}...{{/with}}
        if ($i + 7 < $len) {
            my str $check_with = substr($template, $i, 7);
            if ($check_with eq "{{#with") {
                # Find the closing }} of the opening tag
                my int $tag_end = ::find_closing($template, $i + 7);
                if ($tag_end > $i + 7) {
                    # Extract object name
                    my str $obj_name = substr($template, $i + 7, $tag_end - $i - 7);
                    $obj_name = trim($obj_name);

                    # Find matching {{/with}}
                    my int $block_end = ::find_block_end($template, $tag_end + 2, "with");
                    if ($block_end > 0) {
                        # Extract body
                        my str $body = substr($template, $tag_end + 2, $block_end - $tag_end - 2);

                        # Get the object and merge into new scope
                        my scalar $obj = ::get_var($obj_name, $vars);
                        my scalar $new_vars = ::merge_scope($vars, $obj);

                        # Render body with merged scope
                        my str $rendered = ::render_string($body, $new_vars);
                        $result = $result . $rendered;

                        # Skip past {{/with}}
                        $i = $block_end + 9;
                        next;
                    }
                }
            }
        }

        # Look for {{ start (simple variable or dump)
        if ($i + 1 < $len) {
            my str $two = substr($template, $i, 2);
            if ($two eq "{{") {
                # Find closing }}
                my int $end = ::find_closing($template, $i + 2);
                if ($end > $i + 2) {
                    # Extract content
                    my str $content = substr($template, $i + 2, $end - $i - 2);
                    $content = trim($content);

                    # Check for {{dump varname}}
                    if (length($content) > 5 && substr($content, 0, 5) eq "dump ") {
                        my str $var_name = substr($content, 5, length($content) - 5);
                        $var_name = trim($var_name);
                        my scalar $val = ::get_var($var_name, $vars);
                        my str $dump_str = ::dump($val, 0);
                        # HTML-escape the dump to prevent template re-parsing
                        $dump_str = ::escape_html($dump_str);
                        $result = $result . "<pre class=\"template-dump\">" . $dump_str . "</pre>";
                        $i = $end + 2;
                        next;
                    }

                    # Regular variable
                    my str $value = ::resolve_var($content, $vars);
                    $result = $result . $value;

                    # Skip past }}
                    $i = $end + 2;
                    next;
                }
            }
        }

        # Regular character
        my str $ch = substr($template, $i, 1);
        $result = $result . $ch;
        $i = $i + 1;
    }

    return $result;
}

# Resolve a value expression (string literal, number, or variable reference)
func Cannoli_Template_resolve_value(str $expr, scalar $vars) scalar {
    # Check for string literal "value" or 'value'
    my int $expr_len = length($expr);
    if ($expr_len >= 2) {
        my str $first_ch = substr($expr, 0, 1);
        my str $last_ch = substr($expr, $expr_len - 1, 1);

        if (($first_ch eq "\"" && $last_ch eq "\"") || ($first_ch eq "'" && $last_ch eq "'")) {
            # String literal - extract content
            return substr($expr, 1, $expr_len - 2);
        }
    }

    # Check for numeric literal
    my int $is_num = 1;
    my int $has_dot = 0;
    my int $j = 0;
    while ($j < $expr_len && $is_num == 1) {
        my str $ch = substr($expr, $j, 1);
        if ($ch eq ".") {
            if ($has_dot == 1) {
                $is_num = 0;
            }
            $has_dot = 1;
        } elsif ($ch eq "-" && $j == 0) {
            # Allow leading minus
        } elsif ($ch ge "0" && $ch le "9") {
            # Digit OK
        } else {
            $is_num = 0;
        }
        $j = $j + 1;
    }

    if ($is_num == 1 && $expr_len > 0) {
        # Return as number
        return $expr + 0;
    }

    # Otherwise treat as variable reference
    return ::get_var($expr, $vars);
}

# Merge an object's fields into a new scope (for {{#with}})
func Cannoli_Template_merge_scope(scalar $parent_vars, scalar $obj) scalar {
    my scalar $new_vars = {};

    # Copy parent vars first
    if (ref($parent_vars) eq "hash") {
        foreach my str $k (keys(%{$parent_vars})) {
            $new_vars->{$k} = $parent_vars->{$k};
        }
    }

    # Merge object fields (overrides parent)
    if (ref($obj) eq "hash") {
        foreach my str $k (keys(%{$obj})) {
            $new_vars->{$k} = $obj->{$k};
        }
    }

    return $new_vars;
}

# Dump a value for debugging (returns formatted string)
# Simple implementation: shows type and top-level contents
func Cannoli_Template_dump(scalar $val, int $indent) str {
    if (!defined($val)) {
        return "undef";
    }

    my str $r = ref($val);

    if ($r eq "hash") {
        my str $out = "{\n";
        foreach my str $k (keys(%{$val})) {
            my scalar $v = $val->{$k};
            $out = $out . "  \"" . $k . "\": " . ::dump_value($v) . ",\n";
        }
        $out = $out . "}";
        return $out;
    }

    if ($r eq "array") {
        my str $out = "[\n";
        my int $arr_len = scalar(@{$val});
        my int $arr_i = 0;
        while ($arr_i < $arr_len) {
            my scalar $v = $val->[$arr_i];
            $out = $out . "  " . ::dump_value($v) . ",\n";
            $arr_i = $arr_i + 1;
        }
        $out = $out . "]";
        return $out;
    }

    # Scalar
    return ::dump_scalar($val);
}

# Dump a nested value (shallow - no further recursion)
func Cannoli_Template_dump_value(scalar $val) str {
    if (!defined($val)) {
        return "undef";
    }

    my str $r = ref($val);

    if ($r eq "hash") {
        my str $out = "{";
        my int $count = 0;
        foreach my str $k (keys(%{$val})) {
            if ($count > 0) {
                $out = $out . ", ";
            }
            $out = $out . "\"" . $k . "\": ...";
            $count = $count + 1;
        }
        $out = $out . "}";
        return $out;
    }

    if ($r eq "array") {
        my int $arr_len = scalar(@{$val});
        return "[" . $arr_len . " items]";
    }

    return ::dump_scalar($val);
}

# Format a scalar value for dump
func Cannoli_Template_dump_scalar(scalar $val) str {
    if (!defined($val)) {
        return "undef";
    }

    my str $s = "" . $val;

    # Check if it looks like a number
    my int $is_num = 1;
    my int $has_dot = 0;
    my int $slen = length($s);
    my int $j = 0;

    if ($slen == 0) {
        return "\"\"";
    }

    while ($j < $slen && $is_num == 1) {
        my str $ch = substr($s, $j, 1);
        if ($ch eq ".") {
            if ($has_dot == 1) {
                $is_num = 0;
            }
            $has_dot = 1;
        } elsif ($ch eq "-" && $j == 0) {
            # OK
        } elsif ($ch ge "0" && $ch le "9") {
            # OK
        } else {
            $is_num = 0;
        }
        $j = $j + 1;
    }

    if ($is_num == 1) {
        return $s;
    }

    # String - quote it
    return "\"" . $s . "\"";
}

# Find closing }} from start position
func Cannoli_Template_find_closing(str $template, int $start) int {
    my int $len = length($template);
    my int $i = $start;

    while ($i + 1 < $len) {
        my str $two = substr($template, $i, 2);
        if ($two eq "}}") {
            return $i;
        }
        $i = $i + 1;
    }

    return -1;
}

# Resolve a variable name (supports dot notation for nested access)
func Cannoli_Template_resolve_var(str $name, scalar $vars) str {
    if (!defined($vars)) {
        return "";
    }

    # Check for dot notation (e.g., user.name, user.address.city)
    my int $dot = index($name, ".");
    if ($dot > 0) {
        # Split on first dot
        my str $first = substr($name, 0, $dot);
        my str $rest = substr($name, $dot + 1, length($name) - $dot - 1);

        # Get nested value
        if (ref($vars) eq "hash" && exists(%{$vars}, $first)) {
            my scalar $nested = $vars->{$first};
            return ::resolve_var($rest, $nested);
        }
        return "";
    }

    # Simple variable lookup
    if (ref($vars) eq "hash" && exists(%{$vars}, $name)) {
        my scalar $value = $vars->{$name};

        # Convert to string
        if (!defined($value)) {
            return "";
        }
        return "" . $value;
    }

    return "";
}

# Get a variable value (not converted to string)
func Cannoli_Template_get_var(str $name, scalar $vars) scalar {
    if (!defined($vars)) {
        return undef;
    }

    # Check for dot notation
    my int $dot = index($name, ".");
    if ($dot > 0) {
        my str $first = substr($name, 0, $dot);
        my str $rest = substr($name, $dot + 1, length($name) - $dot - 1);

        if (ref($vars) eq "hash" && exists(%{$vars}, $first)) {
            my scalar $nested = $vars->{$first};
            return ::get_var($rest, $nested);
        }
        return undef;
    }

    # Simple variable lookup
    if (ref($vars) eq "hash" && exists(%{$vars}, $name)) {
        return $vars->{$name};
    }

    return undef;
}

# Check if a value is truthy
func Cannoli_Template_is_truthy(scalar $val) int {
    if (!defined($val)) {
        return 0;
    }

    my str $r = ref($val);
    if ($r eq "array") {
        my int $len = scalar(@{$val});
        return $len > 0;
    }
    if ($r eq "hash") {
        return 1;
    }

    # String or number
    my str $s = "" . $val;
    if ($s eq "" || $s eq "0") {
        return 0;
    }
    return 1;
}

# Find matching block end tag (handles nesting)
# block_type is "each" or "if"
func Cannoli_Template_find_block_end(str $template, int $start, str $block_type) int {
    my int $len = length($template);
    my int $i = $start;
    my int $depth = 1;
    my str $open_tag = "{{#" . $block_type;
    my str $close_tag = "{{/" . $block_type . "}}";
    my int $open_len = length($open_tag);
    my int $close_len = length($close_tag);

    while ($i < $len && $depth > 0) {
        # Check for nested open tag
        if ($i + $open_len <= $len) {
            my str $check_open = substr($template, $i, $open_len);
            if ($check_open eq $open_tag) {
                $depth = $depth + 1;
                $i = $i + $open_len;
                next;
            }
        }

        # Check for close tag
        if ($i + $close_len <= $len) {
            my str $check_close = substr($template, $i, $close_len);
            if ($check_close eq $close_tag) {
                $depth = $depth - 1;
                if ($depth == 0) {
                    return $i;
                }
                $i = $i + $close_len;
                next;
            }
        }

        $i = $i + 1;
    }

    return -1;
}

# Find {{else}} at current nesting level
func Cannoli_Template_find_else(str $template, int $start, int $block_end) int {
    my int $i = $start;
    my int $depth = 0;

    while ($i < $block_end) {
        # Track nested #if blocks
        if ($i + 5 <= $block_end) {
            my str $check = substr($template, $i, 5);
            if ($check eq "{{#if") {
                $depth = $depth + 1;
                $i = $i + 5;
                next;
            }
        }

        if ($i + 7 <= $block_end) {
            my str $check = substr($template, $i, 7);
            if ($check eq "{{/if}}") {
                $depth = $depth - 1;
                $i = $i + 7;
                next;
            }
        }

        # Look for {{else}} at depth 0
        if ($depth == 0 && $i + 8 <= $block_end) {
            my str $check = substr($template, $i, 8);
            if ($check eq "{{else}}") {
                return $i;
            }
        }

        $i = $i + 1;
    }

    return -1;
}

# Process an #each block with named variable support
# $collection_name: the variable containing the array (e.g., "items" or "user.roles")
# $loop_var: the name for each item (e.g., "item"), empty string for legacy mode
# $body: the template body to render for each item
# $vars: the current variable scope
func Cannoli_Template_process_each_named(str $collection_name, str $loop_var, str $body, scalar $vars) str {
    my scalar $arr = ::get_var($collection_name, $vars);

    if (!defined($arr) || ref($arr) ne "array") {
        return "";
    }

    my str $result = "";
    my int $len = scalar(@{$arr});
    my int $idx = 0;

    foreach my scalar $item (@{$arr}) {
        # Create iteration context
        my scalar $iter_vars = {};

        # Copy parent vars
        if (ref($vars) eq "hash") {
            foreach my str $k (keys(%{$vars})) {
                $iter_vars->{$k} = $vars->{$k};
            }
        }

        # Handle named variable syntax: {{#each item in items}}
        if (length($loop_var) > 0) {
            # Named variable mode: item is accessible as {{loop_var}} or {{loop_var.field}}
            $iter_vars->{$loop_var} = $item;
        } else {
            # Legacy mode: merge hash fields into scope, or use "this" for scalars
            if (ref($item) eq "hash") {
                foreach my str $k (keys(%{$item})) {
                    $iter_vars->{$k} = $item->{$k};
                }
            } else {
                $iter_vars->{"this"} = $item;
            }
        }

        # Add loop metadata
        $iter_vars->{"@index"} = $idx;
        if ($idx == 0) {
            $iter_vars->{"@first"} = 1;
        } else {
            $iter_vars->{"@first"} = 0;
        }
        if ($idx == $len - 1) {
            $iter_vars->{"@last"} = 1;
        } else {
            $iter_vars->{"@last"} = 0;
        }

        # Render body with iteration context
        my str $rendered = ::render_string($body, $iter_vars);
        $result = $result . $rendered;

        $idx = $idx + 1;
    }

    return $result;
}

# Process an #if block
func Cannoli_Template_process_if(str $condition, str $if_body, str $else_body, scalar $vars) str {
    my scalar $val = ::get_var($condition, $vars);
    my int $truthy = ::is_truthy($val);

    if ($truthy == 1) {
        return ::render_string($if_body, $vars);
    } else {
        if (length($else_body) > 0) {
            return ::render_string($else_body, $vars);
        }
        return "";
    }
}

# HTML escape a string
func Cannoli_Template_escape_html(str $s) str {
    my str $result = "";
    my int $len = length($s);
    my int $i = 0;

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        if ($ch eq "&") {
            $result = $result . "&amp;";
        } elsif ($ch eq "<") {
            $result = $result . "&lt;";
        } elsif ($ch eq ">") {
            $result = $result . "&gt;";
        } elsif ($ch eq "\"") {
            $result = $result . "&quot;";
        } elsif ($ch eq "'") {
            $result = $result . "&#39;";
        } else {
            $result = $result . $ch;
        }

        $i = $i + 1;
    }

    return $result;
}

# Render with HTML escaping for variables
func Cannoli_Template_render_safe(str $name, scalar $vars) str {
    my str $template = ::load($name);
    if (length($template) == 0) {
        return "";
    }
    return ::render_string_safe($template, $vars);
}

# Render string with HTML escaping
func Cannoli_Template_render_string_safe(str $template, scalar $vars) str {
    my str $result = "";
    my int $len = length($template);
    my int $i = 0;

    while ($i < $len) {
        # Look for {{ start
        if ($i + 1 < $len) {
            my str $two = substr($template, $i, 2);
            if ($two eq "{{") {
                # Find closing }}
                my int $end = ::find_closing($template, $i + 2);
                if ($end > $i + 2) {
                    # Extract variable name
                    my str $var_name = substr($template, $i + 2, $end - $i - 2);
                    $var_name = trim($var_name);

                    # Check for raw output marker {{{var}}}
                    my int $raw = 0;
                    if (length($var_name) > 0 && substr($var_name, 0, 1) eq "{") {
                        # Check if this is {{{ which means raw
                        if ($i + 2 < $len && substr($template, $i, 3) eq "{{{") {
                            my int $raw_end = ::find_triple_closing($template, $i + 3);
                            if ($raw_end > 0) {
                                $var_name = substr($template, $i + 3, $raw_end - $i - 3);
                                $var_name = trim($var_name);
                                my str $value = ::resolve_var($var_name, $vars);
                                $result = $result . $value;
                                $i = $raw_end + 3;
                                next;
                            }
                        }
                    }

                    # Resolve and escape variable
                    my str $value = ::resolve_var($var_name, $vars);
                    $result = $result . ::escape_html($value);

                    # Skip past }}
                    $i = $end + 2;
                    next;
                }
            }
        }

        # Regular character
        my str $ch = substr($template, $i, 1);
        $result = $result . $ch;
        $i = $i + 1;
    }

    return $result;
}

# Find triple closing }}}
func Cannoli_Template_find_triple_closing(str $template, int $start) int {
    my int $len = length($template);
    my int $i = $start;

    while ($i + 2 < $len) {
        my str $three = substr($template, $i, 3);
        if ($three eq "}}}") {
            return $i;
        }
        $i = $i + 1;
    }

    return -1;
}

# Include another template (for partials/layouts)
func Cannoli_Template_include(str $name, scalar $vars) str {
    return ::render($name, $vars);
}

# Render a template with a layout
# Layout should have {{content}} placeholder
func Cannoli_Template_render_with_layout(str $template_name, str $layout_name, scalar $vars) str {
    # First render the main template
    my str $content = ::render($template_name, $vars);

    # Add content to vars
    if (!defined($vars)) {
        $vars = {};
    }
    $vars->{"content"} = $content;

    # Render the layout with the content
    return ::render($layout_name, $vars);
}
