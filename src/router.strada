/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Router;


# cannoli/src/router.strada - URL Router with regex support
#
# Routes incoming requests to handler functions based on:
# - Exact path matching
# - Regex pattern matching with captures
# - HTTP method filtering
#
# Usage:
#   my scalar $router = Cannoli::Router::new();
#   Cannoli::Router::get($router, "/", \&home_handler);
#   Cannoli::Router::get($router, "/users/([0-9]+)", \&user_handler);
#   Cannoli::Router::post($router, "/api/submit", \&submit_handler);

# Create a new router
func Cannoli_Router_new() scalar {
    my hash %router = ();
    $router{"routes"} = [];
    $router{"not_found_handler"} = undef;
    $router{"error_handler"} = undef;
    $router{"error_code_handlers"} = {};  # Handlers by status code (404, 500, etc.)
    $router{"global_middleware"} = [];    # Middleware run before all routes
    $router{"after_middleware"} = [];     # Middleware run after all routes
    return \%router;
}

# Add global middleware (runs before route handler)
func Cannoli_Router_use(scalar $router, scalar $middleware) void {
    push(@{$router->{"global_middleware"}}, $middleware);
}

# Add global after-middleware (runs after route handler)
func Cannoli_Router_use_after(scalar $router, scalar $middleware) void {
    push(@{$router->{"after_middleware"}}, $middleware);
}

# Internal: Add a route
func Cannoli_Router_add_route(scalar $router, str $method, str $pattern, scalar $handler) void {
    ::add_route_full($router, $method, $pattern, $handler, 0, undef);
}

# Internal: Add a route with Cannoli flag
func Cannoli_Router_add_route_ex(scalar $router, str $method, str $pattern, scalar $handler, int $use_cannoli) void {
    ::add_route_full($router, $method, $pattern, $handler, $use_cannoli, undef);
}

# Internal: Add a route with Cannoli flag and middleware
func Cannoli_Router_add_route_full(scalar $router, str $method, str $pattern, scalar $handler, int $use_cannoli, scalar $middleware) void {
    my hash %route = ();
    $route{"method"} = $method;
    $route{"handler"} = $handler;
    $route{"use_cannoli"} = $use_cannoli;
    $route{"original_pattern"} = $pattern;  # Store original for debugging
    $route{"param_names"} = [];

    # Check for named parameters like :id, :name
    my int $has_named = ::contains_named_params($pattern);

    if ($has_named == 1) {
        # Extract parameter names and convert to regex
        $route{"param_names"} = ::extract_param_names($pattern);
        $route{"pattern"} = ::convert_named_params($pattern);
        $route{"is_regex"} = 1;  # Named params require regex matching
    } else {
        $route{"pattern"} = $pattern;
        $route{"is_regex"} = ::contains_regex_chars($pattern);
    }

    # Store route-specific middleware
    if (defined($middleware)) {
        $route{"middleware"} = $middleware;
    } else {
        $route{"middleware"} = [];
    }

    my scalar $routes = $router->{"routes"};
    push(@{$routes}, \%route);
}

# Check if pattern contains regex special characters
func Cannoli_Router_contains_regex_chars(str $pattern) int {
    # Check for common regex patterns
    if (index($pattern, "(") >= 0) { return 1; }
    if (index($pattern, "[") >= 0) { return 1; }
    if (index($pattern, "*") >= 0) { return 1; }
    if (index($pattern, "+") >= 0) { return 1; }
    if (index($pattern, "?") >= 0) { return 1; }
    if (index($pattern, "^") >= 0) { return 1; }
    if (index($pattern, "$") >= 0) { return 1; }
    if (index($pattern, "|") >= 0) { return 1; }
    if (index($pattern, ".") >= 0) { return 1; }
    return 0;
}

# Check if pattern contains named parameters (e.g., :id, :name)
func Cannoli_Router_contains_named_params(str $pattern) int {
    if (index($pattern, ":") >= 0) { return 1; }
    return 0;
}

# Extract parameter names from pattern (e.g., "/users/:id/posts/:post_id" -> ["id", "post_id"])
func Cannoli_Router_extract_param_names(str $pattern) scalar {
    my array @names = ();
    my int $len = length($pattern);
    my int $i = 0;

    while ($i < $len) {
        my str $ch = substr($pattern, $i, 1);

        if ($ch eq ":") {
            # Found start of param name, extract until / or end
            my str $name = "";
            $i = $i + 1;

            while ($i < $len) {
                $ch = substr($pattern, $i, 1);
                if ($ch eq "/" || $ch eq "-" || $ch eq ".") {
                    last;
                }
                $name = $name . $ch;
                $i = $i + 1;
            }

            if (length($name) > 0) {
                push(@names, $name);
            }
        } else {
            $i = $i + 1;
        }
    }

    return \@names;
}

# Convert named params to regex: "/users/:id/posts/:post_id" -> "/users/([^/]+)/posts/([^/]+)"
func Cannoli_Router_convert_named_params(str $pattern) str {
    my str $result = "";
    my int $len = length($pattern);
    my int $i = 0;

    while ($i < $len) {
        my str $ch = substr($pattern, $i, 1);

        if ($ch eq ":") {
            # Replace :param with capture group
            $result = $result . "([^/]+)";

            # Skip the parameter name
            $i = $i + 1;
            while ($i < $len) {
                $ch = substr($pattern, $i, 1);
                if ($ch eq "/" || $ch eq "-" || $ch eq ".") {
                    last;
                }
                $i = $i + 1;
            }
        } else {
            $result = $result . $ch;
            $i = $i + 1;
        }
    }

    return $result;
}

# Add GET route
func Cannoli_Router_get(scalar $router, str $pattern, scalar $handler) void {
    ::add_route($router, "GET", $pattern, $handler);
}

# Add POST route
func Cannoli_Router_post(scalar $router, str $pattern, scalar $handler) void {
    ::add_route($router, "POST", $pattern, $handler);
}

# Add PUT route
func Cannoli_Router_put(scalar $router, str $pattern, scalar $handler) void {
    ::add_route($router, "PUT", $pattern, $handler);
}

# Add DELETE route
func Cannoli_Router_delete_route(scalar $router, str $pattern, scalar $handler) void {
    ::add_route($router, "DELETE", $pattern, $handler);
}

# Add route for any method
func Cannoli_Router_any(scalar $router, str $pattern, scalar $handler) void {
    ::add_route($router, "*", $pattern, $handler);
}

# Set 404 handler
func Cannoli_Router_set_not_found(scalar $router, scalar $handler) void {
    $router->{"not_found_handler"} = $handler;
}

# Set error handler (generic catch-all)
func Cannoli_Router_set_error_handler(scalar $router, scalar $handler) void {
    $router->{"error_handler"} = $handler;
}

# Set error handler for specific status code (404, 500, etc.)
func Cannoli_Router_set_error_code_handler(scalar $router, int $code, scalar $handler) void {
    my scalar $handlers = $router->{"error_code_handlers"};
    my str $code_key = "" . $code;
    $handlers->{$code_key} = $handler;
}

# Get error handler for a specific code
func Cannoli_Router_get_error_handler(scalar $router, int $code) scalar {
    my scalar $handlers = $router->{"error_code_handlers"};
    my str $code_key = "" . $code;
    if (exists(%{$handlers}, $code_key)) {
        return $handlers->{$code_key};
    }
    return undef;
}

#
# Cannoli-style route registration (handlers receive Cannoli object)
#

# Add GET route with Cannoli handler
func Cannoli_Router_get_c(scalar $router, str $pattern, scalar $handler) void {
    ::add_route_ex($router, "GET", $pattern, $handler, 1);
}

# Add POST route with Cannoli handler
func Cannoli_Router_post_c(scalar $router, str $pattern, scalar $handler) void {
    ::add_route_ex($router, "POST", $pattern, $handler, 1);
}

# Add PUT route with Cannoli handler
func Cannoli_Router_put_c(scalar $router, str $pattern, scalar $handler) void {
    ::add_route_ex($router, "PUT", $pattern, $handler, 1);
}

# Add DELETE route with Cannoli handler
func Cannoli_Router_delete_c(scalar $router, str $pattern, scalar $handler) void {
    ::add_route_ex($router, "DELETE", $pattern, $handler, 1);
}

# Add PATCH route with Cannoli handler
func Cannoli_Router_patch_c(scalar $router, str $pattern, scalar $handler) void {
    ::add_route_ex($router, "PATCH", $pattern, $handler, 1);
}

# Add route for any method with Cannoli handler
func Cannoli_Router_any_c(scalar $router, str $pattern, scalar $handler) void {
    ::add_route_ex($router, "*", $pattern, $handler, 1);
}

#
# Cannoli-style route registration with middleware
#

# Add GET route with Cannoli handler and middleware
func Cannoli_Router_get_m(scalar $router, str $pattern, scalar $handler, scalar $middleware) void {
    ::add_route_full($router, "GET", $pattern, $handler, 1, $middleware);
}

# Add POST route with Cannoli handler and middleware
func Cannoli_Router_post_m(scalar $router, str $pattern, scalar $handler, scalar $middleware) void {
    ::add_route_full($router, "POST", $pattern, $handler, 1, $middleware);
}

# Add PUT route with Cannoli handler and middleware
func Cannoli_Router_put_m(scalar $router, str $pattern, scalar $handler, scalar $middleware) void {
    ::add_route_full($router, "PUT", $pattern, $handler, 1, $middleware);
}

# Add DELETE route with Cannoli handler and middleware
func Cannoli_Router_delete_m(scalar $router, str $pattern, scalar $handler, scalar $middleware) void {
    ::add_route_full($router, "DELETE", $pattern, $handler, 1, $middleware);
}

# Add PATCH route with Cannoli handler and middleware
func Cannoli_Router_patch_m(scalar $router, str $pattern, scalar $handler, scalar $middleware) void {
    ::add_route_full($router, "PATCH", $pattern, $handler, 1, $middleware);
}

# Add route for any method with Cannoli handler and middleware
func Cannoli_Router_any_m(scalar $router, str $pattern, scalar $handler, scalar $middleware) void {
    ::add_route_full($router, "*", $pattern, $handler, 1, $middleware);
}

# Match a request against routes and return the matching route
func Cannoli_Router_match(scalar $router, hash %req) scalar {
    my str $method = $req{"method"};
    my str $path = $req{"path"};
    my scalar $routes = $router->{"routes"};
    my int $num_routes = scalar(@{$routes});

    my int $i = 0;
    while ($i < $num_routes) {
        my scalar $route = $routes->[$i];
        my str $route_method = $route->{"method"};
        my str $route_pattern = $route->{"pattern"};

        # Check method (or * for any)
        # HEAD requests also match GET routes (per HTTP spec)
        my int $method_match = 0;
        if ($route_method eq "*") {
            $method_match = 1;
        } elsif ($route_method eq $method) {
            $method_match = 1;
        } elsif ($route_method eq "GET" && $method eq "HEAD") {
            $method_match = 1;
        }
        if ($method_match == 0) {
            $i = $i + 1;
            next;
        }

        # Check pattern
        my int $is_regex = $route->{"is_regex"};

        if ($is_regex == 0) {
            # Exact match
            if ($path eq $route_pattern) {
                my hash %result = ();
                $result{"route"} = $route;
                $result{"captures"} = [];
                return \%result;
            }
        } else {
            # Regex match
            my str $regex_pattern = "^" . $route_pattern . "$";

            if ($path =~ /$regex_pattern/) {
                # Try to extract captures
                my scalar $caps = capture($path, $regex_pattern);
                my hash %result = ();
                $result{"route"} = $route;

                if (defined($caps) && scalar(@{$caps}) > 1) {
                    # Skip index 0 (full match), return only capture groups
                    my array @groups = ();
                    my int $j = 1;
                    my int $num_caps = scalar(@{$caps});
                    while ($j < $num_caps) {
                        push(@groups, $caps->[$j]);
                        $j = $j + 1;
                    }
                    $result{"captures"} = \@groups;
                } else {
                    $result{"captures"} = [];
                }

                return \%result;
            }
        }

        $i = $i + 1;
    }

    return undef;
}

# Execute middleware chain recursively
# $middlewares: array of middleware functions
# $c: Cannoli object
# $idx: current index in middleware array
# $final_handler: the route handler to call after all middleware
func Cannoli_Router_run_middleware_chain(scalar $middlewares, scalar $c, int $idx, scalar $final_handler) hash {
    my int $num_middleware = scalar(@{$middlewares});

    # If we've run all middleware, call the final handler
    if ($idx >= $num_middleware) {
        $final_handler->($c);
        return $c->build_response();
    }

    # Get current middleware
    my scalar $mw = $middlewares->[$idx];

    # Create the next function that continues the chain
    my scalar $next_fn = func (scalar $ctx) {
        return ::run_middleware_chain($middlewares, $ctx, $idx + 1, $final_handler);
    };

    # Call middleware with context and next function
    return $mw->($c, $next_fn);
}

# Dispatch a request to the appropriate handler (with middleware support)
func Cannoli_Router_dispatch(scalar $router, hash %req) hash {
    my scalar $match_result = ::match($router, %req);

    if (!defined($match_result)) {
        # No route matched - check for custom 404 handlers
        # First try error code handler
        my scalar $code_handler = ::get_error_handler($router, 404);
        if (defined($code_handler)) {
            my scalar $c = Cannoli::new(%req);
            $c->{"_error_code"} = 404;
            $code_handler->($c);
            return $c->build_response();
        }

        # Then try the legacy not_found_handler
        my scalar $not_found = $router->{"not_found_handler"};
        if (defined($not_found)) {
            return $not_found->(%req);
        }

        # Default 404 response
        return Cannoli::Response::not_found();
    }

    # Get the matched route and captures
    my scalar $route = $match_result->{"route"};
    my scalar $captures = $match_result->{"captures"};

    # Store captures in request
    $req{"captures"} = $captures;

    # Map captures to named parameters if route has param_names
    my scalar $param_names = $route->{"param_names"};
    if (defined($param_names) && scalar(@{$param_names}) > 0) {
        # Ensure params hash exists
        if (!exists(%req, "params")) {
            $req{"params"} = {};
        }
        my scalar $params = $req{"params"};

        # Map each capture to its named parameter
        my int $num_params = scalar(@{$param_names});
        my int $num_captures = scalar(@{$captures});
        my int $p = 0;

        while ($p < $num_params && $p < $num_captures) {
            my str $name = $param_names->[$p];
            my str $value = $captures->[$p];
            $params->{$name} = $value;
            $p = $p + 1;
        }
    }

    # Get handler and check if it uses Cannoli object
    my scalar $handler = $route->{"handler"};
    my int $use_cannoli = $route->{"use_cannoli"};

    # Execute handler with error handling
    try {
        if ($use_cannoli == 1) {
            # Cannoli-style handler: receives Cannoli object
            my scalar $c = Cannoli::new(%req);

            # Build middleware chain: global -> route-specific -> handler
            my array @all_middleware = ();

            # Add global middleware
            my scalar $global_mw = $router->{"global_middleware"};
            my int $i = 0;
            while ($i < scalar(@{$global_mw})) {
                push(@all_middleware, $global_mw->[$i]);
                $i = $i + 1;
            }

            # Add route-specific middleware
            my scalar $route_mw = $route->{"middleware"};
            if (defined($route_mw)) {
                $i = 0;
                while ($i < scalar(@{$route_mw})) {
                    push(@all_middleware, $route_mw->[$i]);
                    $i = $i + 1;
                }
            }

            # If there's middleware, run the chain
            if (scalar(@all_middleware) > 0) {
                my hash %result = ::run_middleware_chain(\@all_middleware, $c, 0, $handler);

                # Run after-middleware (doesn't affect response, just for cleanup/logging)
                my scalar $after_mw = $router->{"after_middleware"};
                $i = 0;
                while ($i < scalar(@{$after_mw})) {
                    my scalar $mw = $after_mw->[$i];
                    # After middleware just receives $c, no next
                    $mw->($c);
                    $i = $i + 1;
                }

                return %result;
            } else {
                # No middleware, call handler directly
                $handler->($c);

                # Run after-middleware
                my scalar $after_mw = $router->{"after_middleware"};
                $i = 0;
                while ($i < scalar(@{$after_mw})) {
                    my scalar $mw = $after_mw->[$i];
                    $mw->($c);
                    $i = $i + 1;
                }

                return $c->build_response();
            }
        } else {
            # Classic handler: receives hash, returns hash (no middleware support)
            my hash %result = $handler->(%req);
            return %result;
        }
    } catch ($error) {
        # Handler threw an exception - use 500 error handler
        # First try error code handler
        my scalar $code_handler = ::get_error_handler($router, 500);
        if (defined($code_handler)) {
            my scalar $c = Cannoli::new(%req);
            $c->{"_error_code"} = 500;
            $c->{"_error_message"} = $error;
            $code_handler->($c);
            return $c->build_response();
        }

        # Then try generic error handler
        my scalar $err_handler = $router->{"error_handler"};
        if (defined($err_handler)) {
            $req{"_error"} = $error;
            return $err_handler->(%req);
        }

        # Default 500 response
        return Cannoli::Response::internal_error($error);
    }
}

# Print all registered routes (for debugging)
func Cannoli_Router_dump_routes(scalar $router) void {
    say("=== Registered Routes ===");
    my scalar $routes = $router->{"routes"};
    my int $num_routes = scalar(@{$routes});
    my int $i = 0;

    while ($i < $num_routes) {
        my scalar $route = $routes->[$i];
        my str $method = $route->{"method"};
        my str $pattern = $route->{"pattern"};
        my int $is_regex = $route->{"is_regex"};
        my scalar $param_names = $route->{"param_names"};

        my str $type = "exact";
        if ($is_regex == 1) {
            $type = "regex";
        }

        # Use original pattern for display if it has named params
        my str $display_pattern = $pattern;
        if (exists(%{$route}, "original_pattern")) {
            my str $orig = $route->{"original_pattern"};
            if ($orig ne $pattern) {
                $display_pattern = $orig;
            }
        }

        my str $line = "  " . $method . " " . $display_pattern . " (" . $type . ")";

        # Show param names if present
        if (defined($param_names) && scalar(@{$param_names}) > 0) {
            $line = $line . " params: ";
            my int $j = 0;
            while ($j < scalar(@{$param_names})) {
                if ($j > 0) { $line = $line . ", "; }
                $line = $line . ":" . $param_names->[$j];
                $j = $j + 1;
            }
        }

        say($line);
        $i = $i + 1;
    }
    say("");
}

# Group routes under a common prefix
func Cannoli_Router_group(scalar $router, str $prefix, scalar $setup_func) void {
    # Create a sub-router that prefixes all patterns
    my scalar $sub_router = ::new();

    # Call the setup function to register routes on sub-router
    $setup_func->($sub_router);

    # Copy routes from sub-router to main router with prefix
    my scalar $sub_routes = $sub_router->{"routes"};
    my int $num = scalar(@{$sub_routes});
    my int $i = 0;

    while ($i < $num) {
        my scalar $route = $sub_routes->[$i];
        my str $pattern = $prefix . $route->{"pattern"};
        ::add_route($router, $route->{"method"}, $pattern, $route->{"handler"});
        $i = $i + 1;
    }
}

# Guess content type from file extension
func Cannoli_Router_guess_content_type(str $filename) str {
    my str $ext = sys::file_ext($filename);

    if ($ext eq "html" || $ext eq "htm") { return "text/html; charset=utf-8"; }
    if ($ext eq "css") { return "text/css"; }
    if ($ext eq "js") { return "application/javascript"; }
    if ($ext eq "json") { return "application/json"; }
    if ($ext eq "xml") { return "application/xml"; }
    if ($ext eq "txt") { return "text/plain"; }
    if ($ext eq "png") { return "image/png"; }
    if ($ext eq "jpg" || $ext eq "jpeg") { return "image/jpeg"; }
    if ($ext eq "gif") { return "image/gif"; }
    if ($ext eq "svg") { return "image/svg+xml"; }
    if ($ext eq "ico") { return "image/x-icon"; }
    if ($ext eq "pdf") { return "application/pdf"; }
    if ($ext eq "zip") { return "application/zip"; }

    return "application/octet-stream";
}

# ============================================================
# Built-in Middleware
# ============================================================

# Compression middleware - automatically compresses responses
# Usage: Cannoli::Router::use($router, \&Cannoli_Router_compression_middleware);
func Cannoli_Router_compression_middleware(scalar $c, scalar $next_fn) hash {
    # Enable auto-compression based on Accept-Encoding
    $c->auto_compress();

    # Continue to next handler
    return $next_fn->($c);
}

# Logging middleware - logs all requests
# Usage: Cannoli::Router::use($router, \&Cannoli_Router_logging_middleware);
func Cannoli_Router_logging_middleware(scalar $c, scalar $next_fn) hash {
    my str $method = $c->method();
    my str $path = $c->path();
    my str $remote = $c->remote_addr();

    # Log request start
    say("[" . $remote . "] " . $method . " " . $path);

    # Continue to handler
    return $next_fn->($c);
}

# CORS middleware - adds CORS headers
# Usage: Cannoli::Router::use($router, Cannoli::Router::cors_middleware("*"));
func Cannoli_Router_cors_middleware(str $origin) scalar {
    return func (scalar $c, scalar $next_fn) {
        # Add CORS headers
        $c->set_header("Access-Control-Allow-Origin", $origin);
        $c->set_header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS");
        $c->set_header("Access-Control-Allow-Headers", "Content-Type, Authorization");

        # Handle preflight OPTIONS request
        if ($c->method() eq "OPTIONS") {
            $c->status(204);
            return $c->build_response();
        }

        return $next_fn->($c);
    };
}

# Session middleware - ensures session is saved after request
# Usage: Cannoli::Router::use_after($router, \&Cannoli_Router_session_middleware);
func Cannoli_Router_session_middleware(scalar $c) void {
    # Save session if it was accessed
    $c->session_save();
}

# ============================================================
# Rate Limiting Middleware
# ============================================================

# Global rate limit storage (in-memory, resets on restart)
# Format: { "ip:key" => { "count" => N, "reset_at" => timestamp } }
my hash %g_rate_limits = ();

# Rate limiting middleware factory
# $requests: max requests allowed
# $window: time window in seconds
# $key: optional key for different limiters (default: "default")
#
# Usage:
#   Cannoli::Router::use($router, Cannoli::Router::rate_limit(100, 60));  # 100 req/min
#   Cannoli::Router::use($router, Cannoli::Router::rate_limit(10, 60, "api"));  # 10 req/min for API
#
func Cannoli_Router_rate_limit(int $requests, int $window, str $key) scalar {
    if (length($key) == 0) {
        $key = "default";
    }

    return func (scalar $c, scalar $next_fn) {
        my str $ip = $c->remote_addr();
        my str $limit_key = $ip . ":" . $key;
        my int $now = sys::time();

        # Get or create rate limit entry
        my scalar $entry = undef;
        if (exists(%g_rate_limits, $limit_key)) {
            $entry = $g_rate_limits{$limit_key};
        }

        # Check if window expired and reset
        if (defined($entry)) {
            my int $reset_at = $entry->{"reset_at"};
            if ($now >= $reset_at) {
                # Window expired, reset counter
                $entry->{"count"} = 0;
                $entry->{"reset_at"} = $now + $window;
            }
        } else {
            # Create new entry
            $entry = {
                "count" => 0,
                "reset_at" => $now + $window
            };
            $g_rate_limits{$limit_key} = $entry;
        }

        # Increment counter
        my int $count = $entry->{"count"} + 1;
        $entry->{"count"} = $count;

        # Calculate remaining
        my int $remaining = $requests - $count;
        if ($remaining < 0) {
            $remaining = 0;
        }

        # Add rate limit headers
        $c->set_header("X-RateLimit-Limit", "" . $requests);
        $c->set_header("X-RateLimit-Remaining", "" . $remaining);
        $c->set_header("X-RateLimit-Reset", "" . $entry->{"reset_at"});

        # Check if over limit
        if ($count > $requests) {
            my int $retry_after = $entry->{"reset_at"} - $now;
            $c->set_header("Retry-After", "" . $retry_after);
            $c->status(429);
            $c->content_type("application/json");
            $c->write_body("{\"error\":\"Too Many Requests\",\"retry_after\":" . $retry_after . "}");
            return $c->build_response();
        }

        # Continue to next handler
        return $next_fn->($c);
    };
}

# Simple rate limit middleware with default key
# Usage: Cannoli::Router::use($router, Cannoli::Router::rate_limit_simple(100, 60));  # 100 req/min
func Cannoli_Router_rate_limit_simple(int $requests, int $window) scalar {
    return ::rate_limit($requests, $window, "default");
}

# Note: rate_limit_path removed due to compiler bug with regex interpolation
# in closures. Use rate_limit with a custom key instead, and check paths
# manually in your middleware if needed.

# Clear rate limit for an IP (useful for testing or after successful auth)
func Cannoli_Router_rate_limit_clear(str $ip, str $key) void {
    if (length($key) == 0) {
        $key = "default";
    }
    my str $limit_key = $ip . ":" . $key;
    if (exists(%g_rate_limits, $limit_key)) {
        # Set to undef to effectively remove (can't delete from global hash in closure)
        $g_rate_limits{$limit_key} = undef;
    }
}

# Get current rate limit status for an IP
func Cannoli_Router_rate_limit_status(str $ip, str $key) scalar {
    if (length($key) == 0) {
        $key = "default";
    }
    my str $limit_key = $ip . ":" . $key;
    if (exists(%g_rate_limits, $limit_key)) {
        return $g_rate_limits{$limit_key};
    }
    return undef;
}

# ============================================================
# Basic Auth Middleware
# ============================================================

# Basic auth middleware with simple username/password check
# Usage: Cannoli::Router::use($router, Cannoli::Router::basic_auth("admin", "secret", "Admin Area"));
func Cannoli_Router_basic_auth(str $username, str $password, str $realm) scalar {
    if (length($realm) == 0) {
        $realm = "Protected Area";
    }

    return func (scalar $c, scalar $next_fn) {
        if ($c->check_basic_auth($username, $password) == 1) {
            return $next_fn->($c);
        }
        return $c->require_basic_auth($realm);
    };
}

# Basic auth middleware with validator callback
# Usage: Cannoli::Router::use($router, Cannoli::Router::basic_auth_validate(\&check_user, "Members Only"));
# Validator receives (username, password) and returns 1 if valid
func Cannoli_Router_basic_auth_validate(scalar $validator, str $realm) scalar {
    if (length($realm) == 0) {
        $realm = "Protected Area";
    }

    return func (scalar $c, scalar $next_fn) {
        if ($c->validate_basic_auth($validator) == 1) {
            return $next_fn->($c);
        }
        return $c->require_basic_auth($realm);
    };
}

# Basic auth middleware with user hash lookup
# Usage: Cannoli::Router::use($router, Cannoli::Router::basic_auth_users(\%users, "Admin Panel"));
# Users hash: {"username" => "password", ...}
func Cannoli_Router_basic_auth_users(scalar $users, str $realm) scalar {
    if (length($realm) == 0) {
        $realm = "Protected Area";
    }

    return func (scalar $c, scalar $next_fn) {
        my scalar $creds = $c->basic_auth_credentials();

        if (!defined($creds)) {
            return $c->require_basic_auth($realm);
        }

        my str $user = $creds->{"username"};
        my str $pass = $creds->{"password"};

        if (exists(%{$users}, $user)) {
            my str $expected = $users->{$user};
            if ($pass eq $expected) {
                # Store authenticated user in stash for later access
                $c->stash("auth_user", $user);
                return $next_fn->($c);
            }
        }

        return $c->require_basic_auth($realm);
    };
}
