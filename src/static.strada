/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Static;


# cannoli/src/static.strada - Static file server

func Cannoli_Static_new() scalar {
    my hash %s = ();
    $s{"document_root"} = ".";
    $s{"index_files"} = "index.html,index.htm";
    $s{"directory_listing"} = 0;
    my hash %aliases = ();
    $s{"aliases"} = \%aliases;
    return \%s;
}

func Cannoli_Static_resolve_path(scalar $srv, str $url) str {
    my scalar $aliases = $srv->{"aliases"};
    my array @keys = keys(%{$aliases});
    my str $best = "";
    my str $target = "";
    my int $i = 0;
    while ($i < scalar(@keys)) {
        my str $prefix = $keys[$i];
        my int $plen = length($prefix);
        my int $ulen = length($url);
        if ($ulen >= $plen) {
            my str $url_prefix = substr($url, 0, $plen);
            if ($url_prefix eq $prefix) {
                my int $blen = length($best);
                if ($plen > $blen) {
                    $best = $prefix;
                    $target = $aliases->{$prefix};
                }
            }
        }
        $i = $i + 1;
    }
    my int $best_len = length($best);
    if ($best_len > 0) {
        my str $rest = "";
        my int $url_len = length($url);
        if ($url_len > $best_len) {
            $rest = substr($url, $best_len, $url_len - $best_len);
        }
        return $target . $rest;
    }
    return $srv->{"document_root"} . $url;
}

func Cannoli_Static_is_safe(str $path) int {
    my int $dotdot = index($path, "..");
    if ($dotdot >= 0) { return 0; }
    return 1;
}

func Cannoli_Static_find_index(scalar $srv, str $dir) str {
    my str $idx_list = $srv->{"index_files"};
    my array @idx = split(",", $idx_list);
    my int $i = 0;
    while ($i < scalar(@idx)) {
        my str $name = trim($idx[$i]);
        my str $path = $dir . "/" . $name;
        if (sys::is_file($path)) { return $path; }
        $i = $i + 1;
    }
    return "";
}

func Cannoli_Static_format_size(int $size) str {
    if ($size < 1024) {
        return $size . " B";
    }
    if ($size < 1048576) {
        my int $kb = $size / 1024;
        return $kb . " KB";
    }
    if ($size < 1073741824) {
        my int $mb = $size / 1048576;
        return $mb . " MB";
    }
    my int $gb = $size / 1073741824;
    return $gb . " GB";
}

func Cannoli_Static_dir_listing(str $dir, str $url) str {
    my str $html = "<!DOCTYPE html>\n<html>\n<head>\n";
    $html = $html . "<title>Index of " . $url . "</title>\n";
    $html = $html . "<style>\n";
    $html = $html . "body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; }\n";
    $html = $html . "h1 { color: #333; border-bottom: 1px solid #ddd; padding-bottom: 10px; }\n";
    $html = $html . "table { border-collapse: collapse; width: 100%; }\n";
    $html = $html . "th, td { text-align: left; padding: 8px 12px; border-bottom: 1px solid #eee; }\n";
    $html = $html . "th { background: #f5f5f5; font-weight: 600; }\n";
    $html = $html . "tr:hover { background: #f9f9f9; }\n";
    $html = $html . "a { color: #0066cc; text-decoration: none; }\n";
    $html = $html . "a:hover { text-decoration: underline; }\n";
    $html = $html . ".icon { margin-right: 8px; }\n";
    $html = $html . ".size { color: #666; }\n";
    $html = $html . "</style>\n</head>\n<body>\n";
    $html = $html . "<h1>Index of " . $url . "</h1>\n";
    $html = $html . "<table>\n<tr><th>Name</th><th>Size</th></tr>\n";

    # Parent directory link
    if ($url ne "/") {
        $html = $html . "<tr><td><span class=\"icon\">&#128193;</span><a href=\"..\">..</a></td><td>-</td></tr>\n";
    }

    # Read directory entries
    my array @entries = sys::readdir_full($dir);
    my int $i = 0;
    while ($i < scalar(@entries)) {
        my str $full_entry = $entries[$i];
        # Extract just the filename from the full path
        my str $name = sys::basename($full_entry);

        # Skip hidden files and . / ..
        my str $first = substr($name, 0, 1);
        if ($first ne ".") {
            my str $href = $name;
            my str $icon = "&#128196;";  # File icon
            my str $size_str = "-";

            if (sys::is_dir($full_entry)) {
                $icon = "&#128193;";  # Folder icon
                $href = $name . "/";
            } else {
                my int $size = sys::file_size($full_entry);
                $size_str = ::format_size($size);
            }

            $html = $html . "<tr><td><span class=\"icon\">" . $icon . "</span>";
            $html = $html . "<a href=\"" . $href . "\">" . $name . "</a></td>";
            $html = $html . "<td class=\"size\">" . $size_str . "</td></tr>\n";
        }
        $i = $i + 1;
    }

    $html = $html . "</table>\n</body>\n</html>\n";
    return $html;
}

func Cannoli_Static_handle_request(scalar $srv, str $method, str $url) hash {
    my hash %res = ();
    if ($method ne "GET" && $method ne "HEAD") { return %res; }

    my int $safe = ::is_safe($url);
    if ($safe == 0) { return Cannoli::Response::error_page(403, "Forbidden"); }

    my str $fs = ::resolve_path($srv, $url);

    if (sys::is_dir($fs)) {
        my str $idx = ::find_index($srv, $fs);
        my int $idx_len = length($idx);
        if ($idx_len > 0) {
            $fs = $idx;
        } else {
            # Check if directory listing is enabled
            my int $listing_enabled = $srv->{"directory_listing"};
            if ($listing_enabled == 1) {
                my str $listing = ::dir_listing($fs, $url);
                $res{"status"} = 200;
                $res{"content_type"} = "text/html";
                $res{"body"} = $listing;
                return %res;
            }
            return Cannoli::Response::error_page(403, "Directory listing disabled");
        }
    }

    if (!sys::is_file($fs)) { return Cannoli::Response::not_found(); }

    my str $content = slurp($fs);
    my str $mime = Cannoli::Mime::type($fs);
    $res{"status"} = 200;
    $res{"content_type"} = $mime;
    $res{"body"} = $content;
    return %res;
}
