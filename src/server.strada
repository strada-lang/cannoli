/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Server;


# cannoli/src/server.strada - Preforking HTTP server
#
# A preforking server that spawns multiple worker processes to handle
# incoming HTTP connections. Based on the classic Unix preforking model.
#
# Features:
#   - Dynamic library loading (multiple libraries supported, comma-separated)
#   - SSL/HTTPS support
#   - Regex and prefix matching with path_info
#
# Library interface:
#   cannoli_dispatch($c) -> response_body
#   cannoli_after_request($c, $elapsed_ms) -> void  (optional, called after response sent)
#   $c is a Cannoli object with all request data and response methods

# Create a new server from configuration
# Returns a reference to the server hash
func Cannoli_Server_new(hash %config) scalar {
    my hash %server = ();

    $server{"host"} = Cannoli::Config::get_str(%config, "server.host", "0.0.0.0");
    $server{"port"} = Cannoli::Config::get_int(%config, "server.port", 8080);
    $server{"num_workers"} = Cannoli::Config::get_int(%config, "server.workers", 5);
    $server{"max_requests"} = Cannoli::Config::get_int(%config, "server.max_requests", 1000);
    $server{"timeout"} = Cannoli::Config::get_int(%config, "server.timeout", 30);
    $server{"backlog"} = Cannoli::Config::get_int(%config, "server.backlog", 128);
    $server{"max_body_size"} = Cannoli::Config::get_int(%config, "server.max_body_size", 10485760);
    $server{"max_header_size"} = Cannoli::Config::get_int(%config, "server.max_header_size", 8192);
    $server{"router"} = undef;
    $server{"server_sock"} = undef;
    $server{"running"} = 0;
    $server{"worker_pids"} = [];

    # SSL configuration
    $server{"ssl_enabled"} = Cannoli::Config::get_bool(%config, "ssl.enabled", 0);
    $server{"ssl_port"} = Cannoli::Config::get_int(%config, "ssl.port", 443);
    $server{"ssl_cert"} = Cannoli::Config::get_str(%config, "ssl.cert", "");
    $server{"ssl_key"} = Cannoli::Config::get_str(%config, "ssl.key", "");

    $server{"ssl_ctx"} = undef;
    $server{"ssl_server"} = undef;
    $server{"ssl_lib"} = undef;
    $server{"ssl_accept_fn"} = undef;
    $server{"ssl_read_fn"} = undef;
    $server{"ssl_write_fn"} = undef;
    $server{"ssl_close_fn"} = undef;

    # Dynamic library support
    # New style: library./prefix = path.so (prefix-based routing)
    # Old style: app.library = path1.so,path2.so (chain of responsibility)
    $server{"app_library"} = Cannoli::Config::get_str(%config, "app.library", "");
    $server{"lib_handles"} = [];       # Array of library handles
    $server{"dispatch_funcs"} = [];    # Array of dispatch functions (old style)
    $server{"after_funcs"} = [];       # Array of after-request functions (old style)
    $server{"library_routes"} = [];    # Array of {prefix, dispatch_func} (new style)

    # Load SSL library if SSL is enabled
    if ($server{"ssl_enabled"} == 1) {
        my str $ssl_lib_path = "../lib/ssl/libstrada_ssl.so";
        say("Loading SSL library: " . $ssl_lib_path);
        my scalar $ssl_lib = sys::dl_open($ssl_lib_path);
        if (defined($ssl_lib)) {
            $server{"ssl_lib"} = $ssl_lib;
            $server{"ssl_server_fn"} = sys::dl_sym($ssl_lib, "strada_ssl_server_sv");
            $server{"ssl_accept_fn"} = sys::dl_sym($ssl_lib, "strada_ssl_accept_sv");
            $server{"ssl_read_fn"} = sys::dl_sym($ssl_lib, "strada_ssl_read_str");
            $server{"ssl_write_fn"} = sys::dl_sym($ssl_lib, "strada_ssl_write_str");
            $server{"ssl_close_fn"} = sys::dl_sym($ssl_lib, "strada_ssl_close");
            $server{"ssl_fd_fn"} = sys::dl_sym($ssl_lib, "strada_ssl_fd");
            say("  SSL library loaded");
            if (defined($server{"ssl_server_fn"})) {
                say("  Found strada_ssl_server_sv");
            } else {
                say("  ERROR: strada_ssl_server_sv not found!");
            }
        } else {
            say("  Warning: Could not load SSL library");
            $server{"ssl_enabled"} = 0;
        }
    }

    # Load dynamic libraries if specified
    my str $lib_paths = $server{"app_library"};
    if (length($lib_paths) > 0) {
        my array @paths = split(",", $lib_paths);
        my int $i = 0;
        while ($i < scalar(@paths)) {
            my str $lib_spec = trim($paths[$i]);
            if (length($lib_spec) > 0) {
                # Parse library spec: path.so or path.so:config
                my str $lib_path = $lib_spec;
                my str $lib_config = "";

                # Find first colon (config separator)
                my int $colon_pos = -1;
                my int $k = 0;
                while ($k < length($lib_spec)) {
                    if (substr($lib_spec, $k, 1) eq ":") {
                        $colon_pos = $k;
                        last;
                    }
                    $k = $k + 1;
                }

                if ($colon_pos > 0) {
                    $lib_path = substr($lib_spec, 0, $colon_pos);
                    $lib_config = substr($lib_spec, $colon_pos + 1, length($lib_spec) - $colon_pos - 1);
                }

                say("Loading library: " . $lib_path);
                if (length($lib_config) > 0) {
                    say("  Config: " . $lib_config);
                }

                my scalar $lib = sys::dl_open($lib_path);
                if (defined($lib)) {
                    # Call cannoli_init if it exists (for libraries that need configuration)
                    my scalar $init_sym = sys::dl_sym($lib, "cannoli_init");
                    if (defined($init_sym)) {
                        my int $init_result = sys::dl_call_int_sv($init_sym, [$lib_config]);
                        if ($init_result == 0) {
                            say("  Error: cannoli_init failed");
                            $i = $i + 1;
                            next;
                        }
                        say("  Initialized: cannoli_init");
                    }

                    my scalar $sym = sys::dl_sym($lib, "cannoli_dispatch");
                    if (defined($sym)) {
                        push(@{$server{"lib_handles"}}, $lib);
                        push(@{$server{"dispatch_funcs"}}, $sym);
                        say("  Loaded: cannoli_dispatch");

                        my scalar $after_sym = sys::dl_sym($lib, "cannoli_after_request");
                        push(@{$server{"after_funcs"}}, $after_sym);
                        if (defined($after_sym)) {
                            say("  Loaded: cannoli_after_request");
                        }
                    } else {
                        say("  Warning: cannoli_dispatch not found");
                    }
                } else {
                    say("  Error: Could not load library");
                }
            }
            $i = $i + 1;
        }
    }

    # Load prefix-based library routes (new style: library./prefix = path.so:config)
    my scalar $lib_routes = Cannoli::Config::get_library_routes(%config);
    my int $num_routes = scalar(@{$lib_routes});
    if ($num_routes > 0) {
        say("=== Library Routes ===");
        my int $j = 0;
        while ($j < $num_routes) {
            my scalar $route = $lib_routes->[$j];
            my str $prefix = $route->{"prefix"};
            my str $lib_spec = $route->{"path"};

            # Parse library spec: path.so or path.so:config
            my str $lib_path = $lib_spec;
            my str $lib_config = "";

            my int $colon_pos = -1;
            my int $k = 0;
            while ($k < length($lib_spec)) {
                if (substr($lib_spec, $k, 1) eq ":") {
                    $colon_pos = $k;
                    last;
                }
                $k = $k + 1;
            }

            if ($colon_pos > 0) {
                $lib_path = substr($lib_spec, 0, $colon_pos);
                $lib_config = substr($lib_spec, $colon_pos + 1, length($lib_spec) - $colon_pos - 1);
            }

            say("  " . $prefix . " -> " . $lib_path);
            if (length($lib_config) > 0) {
                say("    Config: " . $lib_config);
            }

            my scalar $lib = sys::dl_open($lib_path);
            if (defined($lib)) {
                # Call cannoli_init if it exists
                my scalar $init_sym = sys::dl_sym($lib, "cannoli_init");
                if (defined($init_sym)) {
                    my int $init_result = sys::dl_call_int_sv($init_sym, [$lib_config]);
                    if ($init_result == 0) {
                        say("    Error: cannoli_init failed");
                        $j = $j + 1;
                        next;
                    }
                    say("    Initialized: cannoli_init");
                }

                my scalar $sym = sys::dl_sym($lib, "cannoli_dispatch");
                if (defined($sym)) {
                    push(@{$server{"lib_handles"}}, $lib);
                    my hash %lib_route = ();
                    $lib_route{"prefix"} = $prefix;
                    $lib_route{"dispatch"} = $sym;
                    $lib_route{"after"} = sys::dl_sym($lib, "cannoli_after_request");
                    push(@{$server{"library_routes"}}, \%lib_route);
                    say("    Loaded: cannoli_dispatch");
                    if (defined($lib_route{"after"})) {
                        say("    Loaded: cannoli_after_request");
                    }
                } else {
                    say("    Warning: cannoli_dispatch not found");
                }
            } else {
                say("    Error: Could not load library");
            }
            $j = $j + 1;
        }
        say("");
    }

    return \%server;
}

# Set the router for the server
func Cannoli_Server_set_router(scalar $server_ref, scalar $router) void {
    $server_ref->{"router"} = $router;
}

# Create the SSL listening socket
func Cannoli_Server_create_ssl_socket(scalar $server_ref) scalar {
    my int $ssl_port = $server_ref->{"ssl_port"};
    my str $cert = $server_ref->{"ssl_cert"};
    my str $key = $server_ref->{"ssl_key"};
    my scalar $ssl_server_fn = $server_ref->{"ssl_server_fn"};


    if (!defined($ssl_server_fn)) {
        say("Error: SSL library not loaded");
        return undef;
    }

    if (length($cert) == 0 || length($key) == 0) {
        say("Error: SSL cert and key paths required");
        return undef;
    }

    # Call strada_ssl_server(port, cert, key)
    my scalar $ssl_server = sys::dl_call_sv($ssl_server_fn, [$ssl_port, $cert, $key]);

    if (!defined($ssl_server)) {
        say("Error: Could not create SSL server on port " . $ssl_port);
        return undef;
    }

    $server_ref->{"ssl_server"} = $ssl_server;
    say("SSL listening on " . $server_ref->{"host"} . ":" . $ssl_port);

    return $ssl_server;
}

# Create the listening socket
func Cannoli_Server_create_socket(scalar $server_ref) scalar {
    my str $host = $server_ref->{"host"};
    my int $port = $server_ref->{"port"};
    my int $backlog = $server_ref->{"backlog"};

    my scalar $server_sock = sys::socket_server_backlog($port, $backlog);

    if (!defined($server_sock)) {
        say("Error: Could not create server socket on port " . $port);
        return undef;
    }

    # Set non-blocking to prevent thundering herd problem with multiple workers
    # When select() wakes all workers, only one will get the connection;
    # others will get EAGAIN from accept() instead of blocking
    sys::socket_set_nonblocking($server_sock, 1);

    $server_ref->{"server_sock"} = $server_sock;
    say("Listening on " . $host . ":" . $port . " (backlog=" . $backlog . ")");

    return $server_sock;
}

# Serialize request headers hash to string format: "name:value\nname:value\n..."
func Cannoli_Server_serialize_headers(scalar $headers_ref) str {
    my str $result = "";
    my array @keys = keys(%{$headers_ref});
    my int $i = 0;
    while ($i < scalar(@keys)) {
        my str $name = $keys[$i];
        my str $value = $headers_ref->{$name};
        $result = $result . $name . ":" . $value . "\n";
        $i = $i + 1;
    }
    return $result;
}

# Parse a response body from a library into a response hash
# Supports special prefixes:
#   STATUS:xxx:content - custom status code
#   REDIRECT:url - redirect response
#   RESPONSE:status:headers_len:headers:body - full response with headers
# Auto-detects JSON (starts with { or [) and HTML (starts with <)
func Cannoli_Server_parse_response(str $response_body) hash {
    my hash %res = ();

    if (substr($response_body, 0, 9) eq "RESPONSE:") {
        # RESPONSE:status:headers_len:headers:body - full response with custom headers
        # Note: index() with offset arg is buggy, so we use substr + index workaround
        my str $rest = substr($response_body, 9, length($response_body) - 9);
        my int $colon1 = index($rest, ":");
        if ($colon1 > 0) {
            my str $status_str = substr($rest, 0, $colon1);
            my int $status = $status_str + 0;

            $rest = substr($rest, $colon1 + 1, length($rest) - $colon1 - 1);
            my int $colon2 = index($rest, ":");
            if ($colon2 > 0) {
                my str $headers_len_str = substr($rest, 0, $colon2);
                my int $headers_len = $headers_len_str + 0;

                $rest = substr($rest, $colon2 + 1, length($rest) - $colon2 - 1);
                my str $headers_str = substr($rest, 0, $headers_len);

                # Body is after headers and the separating colon
                my str $content = substr($rest, $headers_len + 1, length($rest) - $headers_len - 1);

                # Start with text response, then override headers
                %res = Cannoli::Response::text($status, $content);
                my scalar $res_headers = $res{"headers"};

                # Parse and apply custom headers (Content-Type:value\nHeader:value...)
                my array @header_lines = split("\n", $headers_str);
                my int $j = 0;
                while ($j < scalar(@header_lines)) {
                    my str $line = $header_lines[$j];
                    my int $colon = index($line, ":");
                    if ($colon > 0) {
                        my str $name = substr($line, 0, $colon);
                        my str $value = substr($line, $colon + 1, length($line) - $colon - 1);
                        # Set header directly in the headers hash
                        $res_headers->{$name} = $value;
                    }
                    $j = $j + 1;
                }
            } else {
                %res = Cannoli::Response::text(200, $response_body);
            }
        } else {
            %res = Cannoli::Response::text(200, $response_body);
        }
    } elsif (substr($response_body, 0, 7) eq "STATUS:") {
        # STATUS:xxx:content - custom status code
        my int $colon1 = 7;
        my int $colon2 = index($response_body, ":", $colon1);
        if ($colon2 > $colon1) {
            my str $status_str = substr($response_body, $colon1, $colon2 - $colon1);
            my int $status = $status_str + 0;
            my str $content = substr($response_body, $colon2 + 1, length($response_body) - $colon2 - 1);
            %res = Cannoli::Response::text($status, $content);
        } else {
            %res = Cannoli::Response::text(200, $response_body);
        }
    } elsif (substr($response_body, 0, 9) eq "REDIRECT:") {
        # REDIRECT:url - redirect response
        my str $url = substr($response_body, 9, length($response_body) - 9);
        %res = Cannoli::Response::redirect($url, 0);
    } elsif (substr($response_body, 0, 1) eq "{" || substr($response_body, 0, 1) eq "[") {
        # JSON response
        %res = Cannoli::Response::json(200, $response_body);
    } elsif (substr($response_body, 0, 1) eq "<") {
        # HTML response
        %res = Cannoli::Response::html(200, $response_body);
    } else {
        # Plain text
        %res = Cannoli::Response::text(200, $response_body);
    }

    return %res;
}

# Build an error result for read_request
func Cannoli_Server_read_error(str $code, int $limit) scalar {
    my hash %result = ();
    $result{"error"} = $code;
    $result{"limit"} = $limit;
    return \%result;
}

# Parse Content-Length from request headers (returns 0 if missing)
func Cannoli_Server_parse_content_length(str $header_section) int {
    my array @lines = split("\r\n", $header_section);
    my int $i = 1;  # skip request line
    while ($i < scalar(@lines)) {
        my str $line = $lines[$i];
        my int $colon = index($line, ":");
        if ($colon > 0) {
            my str $name = trim(substr($line, 0, $colon));
            my str $value = trim(substr($line, $colon + 1, length($line) - $colon - 1));
            $name = lc($name);
            if ($name eq "content-length") {
                return $value + 0;
            }
        }
        $i = $i + 1;
    }
    return 0;
}

# Decide if the connection should be kept alive
func Cannoli_Server_should_keep_alive(hash %req) int {
    my str $version = $req{"http_version"};
    my str $conn = lc(Cannoli::Request::get_header(%req, "Connection"));

    if ($version eq "HTTP/1.1") {
        if (index($conn, "close") >= 0) {
            return 0;
        }
        return 1;
    }

    if ($version eq "HTTP/1.0") {
        if (index($conn, "keep-alive") >= 0) {
            return 1;
        }
        return 0;
    }

    return 0;
}

# Read and parse a full HTTP request from a socket (supports keep-alive buffer)
func Cannoli_Server_read_request(scalar $server_ref, scalar $client, str $buffer) scalar {
    my int $max_header = $server_ref->{"max_header_size"};
    my int $max_body = $server_ref->{"max_body_size"};
    my int $timeout_ms = $server_ref->{"timeout"} * 1000;

    if (length($buffer) == 0) {
        my int $client_fd = sys::socket_fd($client);

        # During keep-alive wait, also monitor the server socket so this
        # worker can break out and accept new connections if needed
        my scalar $server_sock = $server_ref->{"server_sock"};
        my int $server_fd = defined($server_sock) ? sys::socket_fd($server_sock) : -1;

        my array @fds = ($client_fd);
        if ($server_fd >= 0) {
            push(@fds, $server_fd);
        }

        my array @ready = sys::select_fds(\@fds, $timeout_ms);
        if (scalar(@ready) == 0) {
            return undef;
        }

        # If server socket is ready but client is not, a new connection is
        # waiting and this worker should drop keep-alive to go accept it
        my int $client_ready = 0;
        my int $j = 0;
        while ($j < scalar(@ready)) {
            if ($ready[$j] == $client_fd) {
                $client_ready = 1;
            }
            $j++;
        }
        if ($client_ready == 0) {
            return undef;
        }
    }

    my int $header_end = index($buffer, "\r\n\r\n");
    while ($header_end < 0) {
        if (length($buffer) > $max_header) {
            return ::read_error("header_too_large", $max_header);
        }
        my str $chunk = sys::socket_recv($client, 65536);
        if (length($chunk) == 0) {
            return undef;
        }
        $buffer = $buffer . $chunk;
        $header_end = index($buffer, "\r\n\r\n");
    }

    if ($header_end > $max_header) {
        return ::read_error("header_too_large", $max_header);
    }

    my str $header_section = substr($buffer, 0, $header_end);
    my int $content_len = ::parse_content_length($header_section);
    if ($content_len > $max_body) {
        return ::read_error("body_too_large", $max_body);
    }

    my int $total_needed = $header_end + 4 + $content_len;
    while (length($buffer) < $total_needed) {
        my str $chunk = sys::socket_recv($client, 65536);
        if (length($chunk) == 0) {
            return undef;
        }
        $buffer = $buffer . $chunk;
    }

    my str $request_data = substr($buffer, 0, $total_needed);
    my int $remaining_len = length($buffer) - $total_needed;
    my str $remaining = "";
    if ($remaining_len > 0) {
        $remaining = substr($buffer, $total_needed, $remaining_len);
    }

    my hash %req = Cannoli::Request::parse($request_data);
    my hash %result = ();
    $result{"req"} = \%req;
    $result{"buffer"} = $remaining;
    return \%result;
}

# Read and parse a full HTTP request from an SSL connection
func Cannoli_Server_read_ssl_request(scalar $server_ref, scalar $ssl_conn, scalar $ssl_read_fn, int $ssl_fd, str $buffer) scalar {
    my int $max_header = $server_ref->{"max_header_size"};
    my int $max_body = $server_ref->{"max_body_size"};
    my int $timeout_ms = $server_ref->{"timeout"} * 1000;

    if (length($buffer) == 0 && $ssl_fd > 0) {
        # During keep-alive wait, also monitor the server socket
        my scalar $server_sock = $server_ref->{"server_sock"};
        my int $server_fd = defined($server_sock) ? sys::socket_fd($server_sock) : -1;

        my array @fds = ($ssl_fd);
        if ($server_fd >= 0) {
            push(@fds, $server_fd);
        }

        my array @ready = sys::select_fds(\@fds, $timeout_ms);
        if (scalar(@ready) == 0) {
            return undef;
        }

        # If server socket is ready but client is not, drop keep-alive
        my int $client_ready = 0;
        my int $j = 0;
        while ($j < scalar(@ready)) {
            if ($ready[$j] == $ssl_fd) {
                $client_ready = 1;
            }
            $j++;
        }
        if ($client_ready == 0) {
            return undef;
        }
    }

    my int $header_end = index($buffer, "\r\n\r\n");
    while ($header_end < 0) {
        if (length($buffer) > $max_header) {
            return ::read_error("header_too_large", $max_header);
        }
        my str $chunk = sys::dl_call_str_sv($ssl_read_fn, [$ssl_conn, 65536]);
        if (length($chunk) == 0) {
            return undef;
        }
        $buffer = $buffer . $chunk;
        $header_end = index($buffer, "\r\n\r\n");
    }

    if ($header_end > $max_header) {
        return ::read_error("header_too_large", $max_header);
    }

    my str $header_section = substr($buffer, 0, $header_end);
    my int $content_len = ::parse_content_length($header_section);
    if ($content_len > $max_body) {
        return ::read_error("body_too_large", $max_body);
    }

    my int $total_needed = $header_end + 4 + $content_len;
    while (length($buffer) < $total_needed) {
        my str $chunk = sys::dl_call_str_sv($ssl_read_fn, [$ssl_conn, 65536]);
        if (length($chunk) == 0) {
            return undef;
        }
        $buffer = $buffer . $chunk;
    }

    my str $request_data = substr($buffer, 0, $total_needed);
    my int $remaining_len = length($buffer) - $total_needed;
    my str $remaining = "";
    if ($remaining_len > 0) {
        $remaining = substr($buffer, $total_needed, $remaining_len);
    }

    my hash %req = Cannoli::Request::parse($request_data);
    my hash %result = ();
    $result{"req"} = \%req;
    $result{"buffer"} = $remaining;
    return \%result;
}

# Handle a single client connection
func Cannoli_Server_handle_client(scalar $server_ref, scalar $client) void {
    my scalar $router = $server_ref->{"router"};
    my scalar $dispatch_funcs = $server_ref->{"dispatch_funcs"};
    my scalar $after_funcs = $server_ref->{"after_funcs"};
    my scalar $library_routes = $server_ref->{"library_routes"};
    my int $client_fd = sys::socket_fd($client);
    my str $buffer = "";

    while (1) {
        my scalar $read_result = ::read_request($server_ref, $client, $buffer);
        if (!defined($read_result)) {
            last;
        }

        if (exists(%{$read_result}, "error")) {
            my str $err = $read_result->{"error"};
            my int $limit = $read_result->{"limit"};
            my hash %err_res = ();
            if ($err eq "header_too_large") {
                %err_res = Cannoli::Response::header_too_large($limit);
            } elsif ($err eq "body_too_large") {
                %err_res = Cannoli::Response::payload_too_large($limit);
            } else {
                %err_res = Cannoli::Response::error_page(400, "Bad Request");
            }
            my str $err_data = Cannoli::Response::build(%err_res);
            sys::socket_send($client, $err_data);
            last;
        }

        $buffer = $read_result->{"buffer"};
        my hash %req = %{$read_result->{"req"}};

        # Set remote address from socket
        my scalar $peer = sys::getpeername(sys::socket_fd($client));
        if (defined($peer)) {
            $req{"remote_addr"} = $peer->{"addr"};
        }

        # Start timing
        my hash %start_time = sys::gettimeofday();
        my int $start_sec = $start_time{"sec"};
        my int $start_usec = $start_time{"usec"};

        my str $method = $req{"method"};
        my str $path = $req{"path"};
        my str $body = $req{"body"};

        # Check request size limits
        my int $max_body = $server_ref->{"max_body_size"};
        my int $content_len = $req{"content_length"} + 0;
        my int $body_len = length($body);

        # Check Content-Length header against limit
        if ($content_len > $max_body) {
            my hash %err_res = Cannoli::Response::payload_too_large($max_body);
            my str $err_data = Cannoli::Response::build(%err_res);
            sys::socket_send($client, $err_data);
            last;
        }

        # Check actual body size against limit
        if ($body_len > $max_body) {
            my hash %err_res = Cannoli::Response::payload_too_large($max_body);
            my str $err_data = Cannoli::Response::build(%err_res);
            sys::socket_send($client, $err_data);
            last;
        }

        # Store client fd in request for chunked responses
        $req{"_fd"} = $client_fd;
        $req{"_client"} = $client;

        my hash %res = ();
        my int $handled = 0;
        my scalar $c = undef;
        my scalar $after_func = undef;

        # Try prefix-based library routes first (new style)
        my int $num_routes = scalar(@{$library_routes});
        if ($num_routes > 0 && $handled == 0) {
            my int $i = 0;
            while ($i < $num_routes && $handled == 0) {
                my scalar $route = $library_routes->[$i];
                my str $prefix = $route->{"prefix"};
                my scalar $dispatch = $route->{"dispatch"};

                # Check if path starts with prefix
                my int $prefix_len = length($prefix);
                my int $matches = 0;

                if ($prefix eq "/") {
                    # Root prefix matches everything
                    $matches = 1;
                } elsif (length($path) >= $prefix_len) {
                    my str $path_prefix = substr($path, 0, $prefix_len);
                    if ($path_prefix eq $prefix) {
                        # Ensure it's a proper prefix (followed by / or end of path)
                        if (length($path) == $prefix_len) {
                            $matches = 1;
                        } elsif (substr($path, $prefix_len, 1) eq "/") {
                            $matches = 1;
                        } elsif (substr($prefix, $prefix_len - 1, 1) eq "/") {
                            # Prefix ends with /, already matched
                            $matches = 1;
                        }
                    }
                }

                if ($matches == 1) {
                    # Calculate path_info (part of path after prefix)
                    my str $path_info = "";
                    if ($prefix eq "/") {
                        $path_info = $path;
                    } elsif (length($path) > $prefix_len) {
                        $path_info = substr($path, $prefix_len, length($path) - $prefix_len);
                    } else {
                        $path_info = "/";
                    }

                    # Create Cannoli object and pass to dispatch
                    $req{"path_info"} = $path_info;
                    $c = Cannoli::new(%req);

                    my scalar $result = sys::dl_call_sv($dispatch, [$c]);
                    my str $response_body = defined($result) ? ("" . $result) : "";

                    if (length($response_body) > 0) {
                        %res = ::parse_response($response_body);
                        $handled = 1;
                        $after_func = $route->{"after"};
                    }
                }
                $i = $i + 1;
            }
        }

        # Try chain-of-responsibility dispatch (old style: app.library)
        my int $num_funcs = scalar(@{$dispatch_funcs});
        if ($num_funcs > 0 && $handled == 0) {
            # Create Cannoli object once for all dispatch attempts
            $req{"path_info"} = "";  # Libraries handle their own prefix matching
            $c = Cannoli::new(%req);

            my int $i = 0;
            while ($i < $num_funcs && $handled == 0) {
                my scalar $dispatch = $dispatch_funcs->[$i];

                # Call: cannoli_dispatch($c) - pass Cannoli object
                my scalar $result = sys::dl_call_sv($dispatch, [$c]);
                my str $response_body = defined($result) ? ("" . $result) : "";

                if (length($response_body) > 0) {
                    %res = ::parse_response($response_body);
                    $handled = 1;
                    $after_func = $after_funcs->[$i];
                }
                $i = $i + 1;
            }
        }

        # Fall back to router if no library handled the request
        if ($handled == 0 && defined($router)) {
            %res = Cannoli::Router::dispatch($router, %req);
            $handled = 1;
        }

        # Default response
        if ($handled == 0) {
            %res = Cannoli::Response::not_found();
        }

        my int $keep_alive = ::should_keep_alive(%req);

        # Build and send response (skip if already sent, e.g., chunked)
        if ($res{"sent"} != 1) {
            if ($keep_alive == 1) {
                Cannoli::Response::header(%res, "Connection", "keep-alive");
                Cannoli::Response::header(%res, "Keep-Alive", "timeout=" . $server_ref->{"timeout"});
            } else {
                Cannoli::Response::header(%res, "Connection", "close");
            }
            my str $response = Cannoli::Response::build(%res);
            sys::socket_send($client, $response);
        }

        # Calculate elapsed time in milliseconds
        my hash %end_time = sys::gettimeofday();
        my int $end_sec = $end_time{"sec"};
        my int $end_usec = $end_time{"usec"};
        my int $elapsed_ms = ($end_sec - $start_sec) * 1000 + ($end_usec - $start_usec) / 1000;

        # Log the request with timing
        Cannoli::Log::request_timed(%req, %res, $elapsed_ms);

        # Call after-request hook if defined
        if (defined($after_func) && defined($c)) {
            sys::dl_call_void_sv($after_func, [$c, $elapsed_ms]);
        }

        if ($res{"sent"} == 1) {
            last;
        }

        if ($keep_alive == 0) {
            last;
        }
    }

    # Close connection
    sys::socket_close($client);
}

# Handle a single SSL client connection
func Cannoli_Server_handle_ssl_client(scalar $server_ref, scalar $ssl_conn) void {
    my scalar $router = $server_ref->{"router"};
    my scalar $dispatch_funcs = $server_ref->{"dispatch_funcs"};
    my scalar $after_funcs = $server_ref->{"after_funcs"};
    my scalar $library_routes = $server_ref->{"library_routes"};
    my scalar $ssl_read_fn = $server_ref->{"ssl_read_fn"};
    my scalar $ssl_write_fn = $server_ref->{"ssl_write_fn"};
    my scalar $ssl_close_fn = $server_ref->{"ssl_close_fn"};
    my scalar $ssl_fd_fn = $server_ref->{"ssl_fd_fn"};
    my int $ssl_fd = -1;
    if (defined($ssl_fd_fn)) {
        $ssl_fd = sys::dl_call_int_sv($ssl_fd_fn, [$ssl_conn]);
    }
    my str $buffer = "";

    while (1) {
        my scalar $read_result = ::read_ssl_request($server_ref, $ssl_conn, $ssl_read_fn, $ssl_fd, $buffer);
        if (!defined($read_result)) {
            last;
        }

        if (exists(%{$read_result}, "error")) {
            my str $err = $read_result->{"error"};
            my int $limit = $read_result->{"limit"};
            my hash %err_res = ();
            if ($err eq "header_too_large") {
                %err_res = Cannoli::Response::header_too_large($limit);
            } elsif ($err eq "body_too_large") {
                %err_res = Cannoli::Response::payload_too_large($limit);
            } else {
                %err_res = Cannoli::Response::error_page(400, "Bad Request");
            }
            my str $err_data = Cannoli::Response::build(%err_res);
            sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $err_data]);
            last;
        }

        $buffer = $read_result->{"buffer"};
        my hash %req = %{$read_result->{"req"}};

        # Set remote address from SSL socket
        if ($ssl_fd >= 0) {
            my scalar $peer = sys::getpeername($ssl_fd);
            if (defined($peer)) {
                $req{"remote_addr"} = $peer->{"addr"};
            }
        }

        # Start timing
        my hash %start_time = sys::gettimeofday();
        my int $start_sec = $start_time{"sec"};
        my int $start_usec = $start_time{"usec"};

        my str $method = $req{"method"};
        my str $path = $req{"path"};
        my str $body = $req{"body"};

        # Check request size limits
        my int $max_body = $server_ref->{"max_body_size"};
        my int $content_len = $req{"content_length"} + 0;
        my int $body_len = length($body);

        # Check Content-Length header against limit
        if ($content_len > $max_body) {
            my hash %err_res = Cannoli::Response::payload_too_large($max_body);
            my str $err_data = Cannoli::Response::build(%err_res);
            sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $err_data]);
            last;
        }

        # Check actual body size against limit
        if ($body_len > $max_body) {
            my hash %err_res = Cannoli::Response::payload_too_large($max_body);
            my str $err_data = Cannoli::Response::build(%err_res);
            sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $err_data]);
            last;
        }

        # Store SSL connection info in request for chunked responses
        $req{"_ssl"} = 1;
        $req{"_ssl_conn"} = $ssl_conn;
        $req{"_ssl_read_fn"} = $ssl_read_fn;
        $req{"_ssl_write_fn"} = $ssl_write_fn;
        $req{"_ssl_close_fn"} = $ssl_close_fn;

        my hash %res = ();
        my int $handled = 0;
        my scalar $c = undef;
        my scalar $after_func = undef;

        # Try prefix-based library routes first (new style)
        my int $num_routes = scalar(@{$library_routes});
        if ($num_routes > 0 && $handled == 0) {
            my int $i = 0;
            while ($i < $num_routes && $handled == 0) {
                my scalar $route = $library_routes->[$i];
                my str $prefix = $route->{"prefix"};
                my scalar $dispatch = $route->{"dispatch"};

                # Check if path starts with prefix
                my int $prefix_len = length($prefix);
                my int $matches = 0;

                if ($prefix eq "/") {
                    $matches = 1;
                } elsif (length($path) >= $prefix_len) {
                    my str $path_prefix = substr($path, 0, $prefix_len);
                    if ($path_prefix eq $prefix) {
                        if (length($path) == $prefix_len) {
                            $matches = 1;
                        } elsif (substr($path, $prefix_len, 1) eq "/") {
                            $matches = 1;
                        } elsif (substr($prefix, $prefix_len - 1, 1) eq "/") {
                            $matches = 1;
                        }
                    }
                }

                if ($matches == 1) {
                    my str $path_info = "";
                    if ($prefix eq "/") {
                        $path_info = $path;
                    } elsif (length($path) > $prefix_len) {
                        $path_info = substr($path, $prefix_len, length($path) - $prefix_len);
                    } else {
                        $path_info = "/";
                    }

                    # Create Cannoli object and pass to dispatch
                    $req{"path_info"} = $path_info;
                    $c = Cannoli::new(%req);

                    my scalar $result = sys::dl_call_sv($dispatch, [$c]);
                    my str $response_body = defined($result) ? ("" . $result) : "";

                    if (length($response_body) > 0) {
                        %res = ::parse_response($response_body);
                        $handled = 1;
                        $after_func = $route->{"after"};
                    }
                }
                $i = $i + 1;
            }
        }

        # Try chain-of-responsibility dispatch (old style: app.library)
        my int $num_funcs = scalar(@{$dispatch_funcs});
        if ($num_funcs > 0 && $handled == 0) {
            # Create Cannoli object once for all dispatch attempts
            $req{"path_info"} = "";  # Libraries handle their own prefix matching
            $c = Cannoli::new(%req);

            my int $i = 0;
            while ($i < $num_funcs && $handled == 0) {
                my scalar $dispatch = $dispatch_funcs->[$i];

                # Call: cannoli_dispatch($c) - pass Cannoli object
                my scalar $result = sys::dl_call_sv($dispatch, [$c]);
                my str $response_body = defined($result) ? ("" . $result) : "";

                if (length($response_body) > 0) {
                    %res = ::parse_response($response_body);
                    $handled = 1;
                    $after_func = $after_funcs->[$i];
                }
                $i = $i + 1;
            }
        }

        # Fall back to router if no library handled the request
        if ($handled == 0 && defined($router)) {
            %res = Cannoli::Router::dispatch($router, %req);
            $handled = 1;
        }

        # Default response
        if ($handled == 0) {
            %res = Cannoli::Response::not_found();
        }

        # Build and send response via SSL (skip if already sent, e.g., chunked)
        my int $keep_alive = ::should_keep_alive(%req);
        if ($res{"sent"} != 1) {
            if ($keep_alive == 1) {
                Cannoli::Response::header(%res, "Connection", "keep-alive");
                Cannoli::Response::header(%res, "Keep-Alive", "timeout=" . $server_ref->{"timeout"});
            } else {
                Cannoli::Response::header(%res, "Connection", "close");
            }
            my str $response = Cannoli::Response::build(%res);
            sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $response]);
        }

        # Calculate elapsed time in milliseconds
        my hash %end_time = sys::gettimeofday();
        my int $end_sec = $end_time{"sec"};
        my int $end_usec = $end_time{"usec"};
        my int $elapsed_ms = ($end_sec - $start_sec) * 1000 + ($end_usec - $start_usec) / 1000;

        # Log the request with timing
        Cannoli::Log::request_timed(%req, %res, $elapsed_ms);

        # Call after-request hook if defined
        if (defined($after_func) && defined($c)) {
            sys::dl_call_void_sv($after_func, [$c, $elapsed_ms]);
        }

        if ($res{"sent"} == 1) {
            last;
        }

        if ($keep_alive == 0) {
            last;
        }
    }

    # Close SSL connection
    sys::dl_call_void_sv($ssl_close_fn, [$ssl_conn]);
}

# Worker process main loop
func Cannoli_Server_worker_loop(scalar $server_ref) void {
    my scalar $server_sock = $server_ref->{"server_sock"};
    my scalar $ssl_server = $server_ref->{"ssl_server"};
    my int $max_requests = $server_ref->{"max_requests"};
    my int $requests_handled = 0;

    # Save parent PID to detect if master dies
    my int $parent_pid = sys::getppid();

    my int $http_fd = sys::socket_fd($server_sock);
    my int $ssl_fd = -1;
    if (defined($ssl_server)) {
        my scalar $ssl_fd_fn = $server_ref->{"ssl_fd_fn"};
        $ssl_fd = sys::dl_call_int_sv($ssl_fd_fn, [$ssl_server]);
    }

    while ($requests_handled < $max_requests) {
        # Check if master process died (orphaned worker)
        my int $current_ppid = sys::getppid();
        if ($current_ppid != $parent_pid) {
            # Master died, exit cleanly
            exit(0);
        }

        # Build array of file descriptors to monitor
        my array @fds = ($http_fd);
        if ($ssl_fd >= 0) {
            push(\@fds, $ssl_fd);
        }

        # Wait for connections on either socket
        my array @ready = sys::select_fds(\@fds, 1000);
        my int $num_ready = scalar(@ready);

        if ($num_ready == 0) {
            next;
        }

        my int $i = 0;
        while ($i < $num_ready) {
            my int $ready_fd = $ready[$i];

            if ($ready_fd == $http_fd) {
                # HTTP connection
                my scalar $client = sys::socket_accept($server_sock);
                if (defined($client)) {
                    ::handle_client($server_ref, $client);
                    $requests_handled = $requests_handled + 1;
                }
            } elsif ($ready_fd == $ssl_fd) {
                # HTTPS connection
                my scalar $ssl_accept_fn = $server_ref->{"ssl_accept_fn"};
                my scalar $ssl_conn = sys::dl_call_sv($ssl_accept_fn, [$ssl_server]);
                if (defined($ssl_conn)) {
                    ::handle_ssl_client($server_ref, $ssl_conn);
                    $requests_handled = $requests_handled + 1;
                }
            }

            $i = $i + 1;
        }
    }

    # Worker exits after max requests (will be respawned by master)
}

# Spawn worker processes
func Cannoli_Server_spawn_workers(scalar $server_ref) void {
    my int $num_workers = $server_ref->{"num_workers"};
    my scalar $pids = $server_ref->{"worker_pids"};

    my int $i = 0;
    while ($i < $num_workers) {
        my int $pid = sys::fork();

        if ($pid == 0) {
            # Child process - set worker title and run worker loop
            sys::setproctitle("cannoli [worker]");
            # Install worker signal handlers
            sys::signal("TERM", \&Cannoli_Server_worker_handle_term);
            sys::signal("INT", "IGNORE");  # Let master handle Ctrl+C
            ::worker_loop($server_ref);
            exit(0);
        } elsif ($pid > 0) {
            # Parent - track child PID
            push(@{$pids}, $pid);
            say("Spawned worker " . ($i + 1) . " with PID " . $pid);
        } else {
            say("Error: fork() failed");
        }

        $i = $i + 1;
    }
}

# Global server reference for signal handlers
my scalar $_g_server_ref = undef;

# Worker signal handler for SIGTERM - exit cleanly
func Cannoli_Server_worker_handle_term(int $sig) void {
    defined($sig);
    exit(0);
}

# Signal handler for SIGINT (Ctrl+C)
func Cannoli_Server_handle_sigint(int $sig) void {
    defined($sig);
    if (defined($_g_server_ref)) {
        ::graceful_shutdown($_g_server_ref);
    }
}

# Signal handler for SIGTERM
func Cannoli_Server_handle_sigterm(int $sig) void {
    defined($sig);
    if (defined($_g_server_ref)) {
        ::graceful_shutdown($_g_server_ref);
    }
}

# Install signal handlers for graceful shutdown
func Cannoli_Server_install_signal_handlers(scalar $server_ref) void {
    $_g_server_ref = $server_ref;
    sys::signal("INT", \&Cannoli_Server_handle_sigint);
    sys::signal("TERM", \&Cannoli_Server_handle_sigterm);
    sys::signal("PIPE", "IGNORE");  # Ignore broken pipe
}

# Graceful shutdown - close sockets, wait for workers, cleanup
func Cannoli_Server_graceful_shutdown(scalar $server_ref) void {
    # Prevent multiple shutdown calls
    if ($server_ref->{"running"} == 0) {
        return;
    }

    say("\nGraceful shutdown initiated...");
    $server_ref->{"running"} = 0;

    # Close listening sockets first to stop accepting new connections
    my scalar $server_sock = $server_ref->{"server_sock"};
    if (defined($server_sock)) {
        say("Closing HTTP listening socket...");
        sys::socket_close($server_sock);
        $server_ref->{"server_sock"} = undef;
    }

    # Close SSL socket if present
    if ($server_ref->{"ssl_enabled"} == 1) {
        my scalar $ssl_server = $server_ref->{"ssl_server"};
        if (defined($ssl_server)) {
            say("Closing HTTPS listening socket...");
            my scalar $ssl_close_fn = $server_ref->{"ssl_close_fn"};
            if (defined($ssl_close_fn)) {
                sys::dl_call_void_sv($ssl_close_fn, [$ssl_server]);
            }
            $server_ref->{"ssl_server"} = undef;
        }
    }

    # Send SIGTERM to all workers
    my scalar $pids = $server_ref->{"worker_pids"};
    my int $num = scalar(@{$pids});
    my int $i = 0;

    if ($num > 0) {
        say("Sending SIGTERM to " . $num . " workers...");
        while ($i < $num) {
            my int $pid = $pids->[$i];
            sys::kill($pid, 15);  # SIGTERM
            $i = $i + 1;
        }

        # Wait for workers with timeout
        my int $timeout = 30;  # seconds
        my int $start = sys::time();
        my int $remaining = $num;

        say("Waiting for workers to exit (timeout: " . $timeout . "s)...");

        while ($remaining > 0) {
            my int $status = 0;
            my int $pid = sys::waitpid(-1, $status);

            if ($pid > 0) {
                $remaining = $remaining - 1;
                say("Worker " . $pid . " exited (" . $remaining . " remaining)");
            }

            # Check timeout
            my int $elapsed = sys::time() - $start;
            if ($elapsed > $timeout) {
                say("Timeout reached, force-killing remaining workers...");
                $i = 0;
                while ($i < scalar(@{$pids})) {
                    my int $kill_pid = $pids->[$i];
                    sys::kill($kill_pid, 9);  # SIGKILL
                    $i = $i + 1;
                }
                last;
            }

            sys::usleep(100000);  # 100ms
        }
    }

    say("Shutdown complete");

    # In single-process dev mode (no workers), exit immediately
    # Otherwise the main loop may try to use closed sockets
    if ($num == 0) {
        exit(0);
    }
}

# Legacy signal handler for graceful Cannoli::Server::shutdown(kept for compatibility)
func Cannoli_Server_shutdown(scalar $server_ref) void {
    ::graceful_shutdown($server_ref);
}

# Master process loop - monitor and respawn workers
func Cannoli_Server_master_loop(scalar $server_ref) void {
    $server_ref->{"running"} = 1;

    while ($server_ref->{"running"} == 1) {
        # Wait for any child to exit
        my int $status = 0;
        my int $pid = sys::waitpid(-1, $status);

        if ($pid > 0 && $server_ref->{"running"} == 1) {
            # A worker exited, respawn it
            say("Worker " . $pid . " exited, respawning...");

            # Remove old PID from list
            my scalar $pids = $server_ref->{"worker_pids"};
            my array @new_pids = ();
            my int $i = 0;
            my int $num = scalar(@{$pids});

            while ($i < $num) {
                my int $p = $pids->[$i];
                if ($p != $pid) {
                    push(\@new_pids, $p);
                }
                $i = $i + 1;
            }

            $server_ref->{"worker_pids"} = \@new_pids;

            # Fork new worker
            my int $new_pid = sys::fork();

            if ($new_pid == 0) {
                # Child - set worker title and signal handlers
                sys::setproctitle("cannoli [worker]");
                sys::signal("TERM", \&Cannoli_Server_worker_handle_term);
                sys::signal("INT", "IGNORE");
                ::worker_loop($server_ref);
                exit(0);
            } elsif ($new_pid > 0) {
                # Parent
                push(@{$server_ref->{"worker_pids"}}, $new_pid);
                say("Respawned worker with PID " . $new_pid);
            }
        }

        sys::usleep(100000);
    }
}

# Run the server in preforking mode
func Cannoli_Server_run(scalar $server_ref) int {
    # Create HTTP listening socket
    my scalar $server_sock = ::create_socket($server_ref);
    if (!defined($server_sock)) {
        return 1;
    }

    # Create SSL listening socket if SSL is enabled
    if ($server_ref->{"ssl_enabled"} == 1) {
        ::create_ssl_socket($server_ref);
    }

    # Install signal handlers for graceful Cannoli::Server::shutdown(before spawning workers)
    ::install_signal_handlers($server_ref);

    # Set master process title
    sys::setproctitle("cannoli [master]");

    say("Starting " . $server_ref->{"num_workers"} . " worker processes...");

    # Spawn workers
    ::spawn_workers($server_ref);

    # Run master loop
    ::master_loop($server_ref);

    return 0;
}

# Run the server in single-process mode (for development)
func Cannoli_Server_run_single(scalar $server_ref) int {
    # Create HTTP listening socket
    my scalar $server_sock = ::create_socket($server_ref);
    if (!defined($server_sock)) {
        return 1;
    }

    # Create SSL listening socket if SSL is enabled
    my scalar $ssl_server = undef;
    my int $ssl_fd = -1;
    if ($server_ref->{"ssl_enabled"} == 1) {
        $ssl_server = ::create_ssl_socket($server_ref);
        if (defined($ssl_server)) {
            my scalar $ssl_fd_fn = $server_ref->{"ssl_fd_fn"};
            $ssl_fd = sys::dl_call_int_sv($ssl_fd_fn, [$ssl_server]);
        }
    }

    # Install signal handlers for graceful shutdown
    ::install_signal_handlers($server_ref);

    say("Running in single-process development mode");
    say("Press Ctrl+C to stop");

    $server_ref->{"running"} = 1;
    my int $http_fd = sys::socket_fd($server_sock);

    while ($server_ref->{"running"} == 1) {
        # Build array of file descriptors to monitor
        my array @fds = ($http_fd);
        if ($ssl_fd >= 0) {
            push(\@fds, $ssl_fd);
        }

        # Wait for connections on either socket
        my array @ready = sys::select_fds(\@fds, 1000);
        my int $num_ready = scalar(@ready);
        my int $i = 0;

        while ($i < $num_ready) {
            my int $ready_fd = $ready[$i];

            if ($ready_fd == $http_fd) {
                # HTTP connection
                my scalar $client = sys::socket_accept($server_sock);
                if (defined($client)) {
                    ::handle_client($server_ref, $client);
                }
            } elsif ($ready_fd == $ssl_fd) {
                # HTTPS connection
                my scalar $ssl_accept_fn = $server_ref->{"ssl_accept_fn"};
                my scalar $ssl_conn = sys::dl_call_sv($ssl_accept_fn, [$ssl_server]);
                if (defined($ssl_conn)) {
                    ::handle_ssl_client($server_ref, $ssl_conn);
                }
            }

            $i = $i + 1;
        }
    }

    sys::socket_close($server_sock);
    if (defined($ssl_server)) {
        my scalar $ssl_close_fn = $server_ref->{"ssl_close_fn"};
        sys::dl_call_void_sv($ssl_close_fn, [$ssl_server]);
    }
    return 0;
}
