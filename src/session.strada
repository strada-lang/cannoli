/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# cannoli/src/session.strada - Session management
#
# File-based session storage with cookie tracking.
# Sessions are stored in /tmp/cannoli_sessions/ directory.
#
# Usage:
#   my scalar $session = Session_new();
#   Session_set($session, "user_id", "42");
#   Session_save($session);
#
#   my scalar $loaded = Session_load($session_id);
#   my str $user = Session_get($loaded, "user_id");

# Session directory
my str $g_session_dir = "/tmp/cannoli_sessions";
my str $g_session_cookie = "cannoli_session";
my int $g_session_ttl = 3600;  # 1 hour default TTL

# Initialize session system (creates directory if needed)
func Session_init() void {
    if (sys::is_dir($g_session_dir) == 0) {
        sys::mkdir($g_session_dir);
    }
}

# Configure session settings
func Session_configure(str $dir, str $cookie_name, int $ttl) void {
    if (length($dir) > 0) {
        $g_session_dir = $dir;
    }
    if (length($cookie_name) > 0) {
        $g_session_cookie = $cookie_name;
    }
    if ($ttl > 0) {
        $g_session_ttl = $ttl;
    }
    Session_init();
}

# Generate a secure session ID (32 hex characters)
func Session_generate_id() str {
    my str $id = "";
    my int $i = 0;
    my str $hex = "0123456789abcdef";

    # Use random() to generate 32 hex chars
    while ($i < 32) {
        # math::rand() returns 0-1, scale to 0-15
        my num $rand = math::rand();
        my int $r = math::floor($rand * 16);
        if ($r > 15) { $r = 15; }
        my str $ch = substr($hex, $r, 1);
        $id = $id . $ch;
        $i = $i + 1;
    }

    return $id;
}

# Get session file path
func Session_file_path(str $id) str {
    return $g_session_dir . "/sess_" . $id;
}

# Create a new session
func Session_new() scalar {
    Session_init();

    my hash %session = ();
    $session{"id"} = Session_generate_id();
    $session{"created"} = sys::time();
    $session{"modified"} = sys::time();
    $session{"data"} = {};

    return \%session;
}

# Load a session by ID
func Session_load(str $id) scalar {
    # Validate session ID (only hex chars allowed)
    if (length($id) != 32) {
        return undef;
    }

    my str $path = Session_file_path($id);

    if (sys::is_file($path) == 0) {
        return undef;
    }

    # Read and parse session file
    my str $content = slurp($path);
    if (length($content) == 0) {
        return undef;
    }

    # Parse session data (simple key=value format)
    my hash %session = ();
    $session{"id"} = $id;
    $session{"data"} = {};

    my array @lines = split($content, "\n");
    my int $i = 0;
    my int $in_data = 0;

    while ($i < scalar(@lines)) {
        my str $line = @lines[$i];

        if (length($line) == 0) {
            $i = $i + 1;
            next;
        }

        # Parse key=value
        my int $eq_pos = index($line, "=");
        if ($eq_pos > 0) {
            my str $key = substr($line, 0, $eq_pos);
            my str $value = substr($line, $eq_pos + 1, length($line) - $eq_pos - 1);

            if ($key eq "_created") {
                $session{"created"} = $value + 0;
            } elsif ($key eq "_modified") {
                $session{"modified"} = $value + 0;
            } else {
                # User data
                my scalar $data = $session{"data"};
                $data->{$key} = Session_decode_value($value);
            }
        }

        $i = $i + 1;
    }

    # Check TTL
    my int $now = sys::time();
    my int $modified = $session{"modified"} + 0;
    if ($now - $modified > $g_session_ttl) {
        # Session expired
        Session_destroy($id);
        return undef;
    }

    return \%session;
}

# Save a session to file
func Session_save(scalar $session) int {
    Session_init();

    my str $id = $session->{"id"};
    my str $path = Session_file_path($id);

    # Update modified time
    $session->{"modified"} = sys::time();

    # Build file content
    my str $content = "";
    $content = $content . "_created=" . $session->{"created"} . "\n";
    $content = $content . "_modified=" . $session->{"modified"} . "\n";

    # Save data fields
    my scalar $data = $session->{"data"};
    my array @keys = keys(%{$data});
    my int $i = 0;

    while ($i < scalar(@keys)) {
        my str $key = @keys[$i];
        my str $value = Session_encode_value($data->{$key});
        $content = $content . $key . "=" . $value . "\n";
        $i = $i + 1;
    }

    # Write to file
    spew($path, $content);
    return 1;
}

# Destroy a session
func Session_destroy(str $id) void {
    my str $path = Session_file_path($id);
    if (sys::is_file($path) == 1) {
        sys::unlink($path);
    }
}

# Get a value from session
func Session_get(scalar $session, str $key) scalar {
    my scalar $data = $session->{"data"};
    if (exists(%{$data}, $key)) {
        return $data->{$key};
    }
    return undef;
}

# Set a value in session
func Session_set(scalar $session, str $key, scalar $value) void {
    my scalar $data = $session->{"data"};
    $data->{$key} = $value;
}

# Delete a value from session
# Note: Sets value to undef rather than removing key
func Session_delete(scalar $session, str $key) void {
    my scalar $data = $session->{"data"};
    if (exists(%{$data}, $key)) {
        $data->{$key} = undef;
    }
}

# Check if session has a key
func Session_has(scalar $session, str $key) int {
    my scalar $data = $session->{"data"};
    if (exists(%{$data}, $key)) {
        return 1;
    }
    return 0;
}

# Get session ID
func Session_id(scalar $session) str {
    return $session->{"id"};
}

# Get cookie name
func Session_cookie_name() str {
    return $g_session_cookie;
}

# Get TTL
func Session_ttl() int {
    return $g_session_ttl;
}

# Encode a value for storage (escape newlines and equals)
func Session_encode_value(scalar $value) str {
    if (!defined($value)) {
        return "";
    }

    my str $s = "" . $value;

    # Escape special chars: \ -> \\, newline -> \n, = -> \e
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        if ($ch eq "\\") {
            $result = $result . "\\\\";
        } elsif ($ch eq "\n") {
            $result = $result . "\\n";
        } elsif ($ch eq "=") {
            $result = $result . "\\e";
        } else {
            $result = $result . $ch;
        }

        $i = $i + 1;
    }

    return $result;
}

# Decode a stored value
func Session_decode_value(str $s) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        if ($ch eq "\\" && $i + 1 < $len) {
            my str $next_ch = substr($s, $i + 1, 1);
            if ($next_ch eq "\\") {
                $result = $result . "\\";
                $i = $i + 2;
                next;
            } elsif ($next_ch eq "n") {
                $result = $result . "\n";
                $i = $i + 2;
                next;
            } elsif ($next_ch eq "e") {
                $result = $result . "=";
                $i = $i + 2;
                next;
            }
        }

        $result = $result . $ch;
        $i = $i + 1;
    }

    return $result;
}

# Clean up expired sessions (call periodically)
func Session_cleanup() int {
    if (sys::is_dir($g_session_dir) == 0) {
        return 0;
    }

    my int $now = sys::time();
    my int $cleaned = 0;

    my array @files = sys::readdir($g_session_dir);
    my int $i = 0;

    while ($i < scalar(@files)) {
        my str $file = @files[$i];

        # Only process session files
        if (substr($file, 0, 5) eq "sess_") {
            my str $path = $g_session_dir . "/" . $file;

            # Check modification time via file content
            my str $content = slurp($path);
            my int $modified = 0;

            # Find _modified= line
            my int $pos = index($content, "_modified=");
            if ($pos >= 0) {
                my str $rest = substr($content, $pos + 10, 20);
                my int $nl = index($rest, "\n");
                if ($nl > 0) {
                    my str $ts = substr($rest, 0, $nl);
                    $modified = $ts + 0;
                }
            }

            # Remove if expired
            if ($modified > 0 && $now - $modified > $g_session_ttl) {
                sys::unlink($path);
                $cleaned = $cleaned + 1;
            }
        }

        $i = $i + 1;
    }

    return $cleaned;
}
