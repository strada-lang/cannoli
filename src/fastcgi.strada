/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::FastCGI;


# cannoli/src/fastcgi.strada - FastCGI protocol implementation
#
# Implements the FastCGI protocol for use with web servers like nginx

# FastCGI record types
func FCGI_BEGIN_REQUEST() int { return 1; }
func FCGI_ABORT_REQUEST() int { return 2; }
func FCGI_END_REQUEST() int { return 3; }
func FCGI_PARAMS() int { return 4; }
func FCGI_STDIN() int { return 5; }
func FCGI_STDOUT() int { return 6; }
func FCGI_STDERR() int { return 7; }
func FCGI_DATA() int { return 8; }
func FCGI_GET_VALUES() int { return 9; }
func FCGI_GET_VALUES_RESULT() int { return 10; }

# FastCGI roles
func FCGI_RESPONDER() int { return 1; }
func FCGI_AUTHORIZER() int { return 2; }
func FCGI_FILTER() int { return 3; }

# FastCGI protocol status
func FCGI_REQUEST_COMPLETE() int { return 0; }
func FCGI_CANT_MPX_CONN() int { return 1; }
func FCGI_OVERLOADED() int { return 2; }
func FCGI_UNKNOWN_ROLE() int { return 3; }

# Helper: integer modulo (a mod b)
func fcgi_mod(int $a, int $b) int {
    my int $div = $a / $b;
    return $a - ($div * $b);
}

# Create a FastCGI header (8 bytes)
func Cannoli_FastCGI_make_header(int $type, int $request_id, int $content_len, int $padding_len) str {
    my str $header = "";

    # Version (1)
    $header = $header . chr(1);

    # Type
    $header = $header . chr($type);

    # Request ID (big-endian 16-bit)
    my int $req_high = $request_id / 256;
    $req_high = fcgi_mod($req_high, 256);
    my int $req_low = fcgi_mod($request_id, 256);
    $header = $header . chr($req_high);
    $header = $header . chr($req_low);

    # Content length (big-endian 16-bit)
    my int $len_high = $content_len / 256;
    $len_high = fcgi_mod($len_high, 256);
    my int $len_low = fcgi_mod($content_len, 256);
    $header = $header . chr($len_high);
    $header = $header . chr($len_low);

    # Padding length
    $header = $header . chr($padding_len);

    # Reserved
    $header = $header . chr(0);

    return $header;
}

# Parse a FastCGI header
func Cannoli_FastCGI_parse_header(str $data) hash {
    my hash %header = ();

    if (length($data) < 8) {
        $header{"valid"} = 0;
        return %header;
    }

    $header{"valid"} = 1;
    $header{"version"} = ord(substr($data, 0, 1));
    $header{"type"} = ord(substr($data, 1, 1));
    $header{"request_id"} = ord(substr($data, 2, 1)) * 256 + ord(substr($data, 3, 1));
    $header{"content_length"} = ord(substr($data, 4, 1)) * 256 + ord(substr($data, 5, 1));
    $header{"padding_length"} = ord(substr($data, 6, 1));

    return %header;
}

# Parse FastCGI name-value pairs (FCGI_PARAMS)
func Cannoli_FastCGI_parse_params(str $data) hash {
    my hash %params = ();
    my int $pos = 0;
    my int $len = length($data);

    while ($pos < $len) {
        # Read name length
        my int $name_len = ord(substr($data, $pos, 1));
        $pos = $pos + 1;

        if ($name_len > 127) {
            # 4-byte length
            my int $b0 = fcgi_mod($name_len, 128);
            my int $b1 = ord(substr($data, $pos, 1));
            my int $b2 = ord(substr($data, $pos + 1, 1));
            my int $b3 = ord(substr($data, $pos + 2, 1));
            $name_len = ($b0 * 16777216) + ($b1 * 65536) + ($b2 * 256) + $b3;
            $pos = $pos + 3;
        }

        if ($pos >= $len) { last; }

        # Read value length
        my int $value_len = ord(substr($data, $pos, 1));
        $pos = $pos + 1;

        if ($value_len > 127) {
            # 4-byte length
            my int $b0 = fcgi_mod($value_len, 128);
            my int $b1 = ord(substr($data, $pos, 1));
            my int $b2 = ord(substr($data, $pos + 1, 1));
            my int $b3 = ord(substr($data, $pos + 2, 1));
            $value_len = ($b0 * 16777216) + ($b1 * 65536) + ($b2 * 256) + $b3;
            $pos = $pos + 3;
        }

        if ($pos + $name_len + $value_len > $len) { last; }

        # Extract name and value
        my str $name = substr($data, $pos, $name_len);
        $pos = $pos + $name_len;

        my str $value = substr($data, $pos, $value_len);
        $pos = $pos + $value_len;

        $params{$name} = $value;
    }

    return %params;
}

# Build FastCGI params from CGI environment to request hash
func Cannoli_FastCGI_params_to_request(hash %params) hash {
    my hash %req = Cannoli::Request::new();

    # Map CGI variables to request object
    if (exists(%params, "REQUEST_METHOD")) {
        $req{"method"} = $params{"REQUEST_METHOD"};
    }
    if (exists(%params, "REQUEST_URI")) {
        $req{"uri"} = $params{"REQUEST_URI"};
    }
    if (exists(%params, "DOCUMENT_URI")) {
        $req{"path"} = $params{"DOCUMENT_URI"};
    } elsif (exists(%params, "SCRIPT_NAME")) {
        $req{"path"} = $params{"SCRIPT_NAME"};
    }
    if (exists(%params, "QUERY_STRING")) {
        $req{"query_string"} = $params{"QUERY_STRING"};
        $req{"params"} = Cannoli::Request::parse_query($params{"QUERY_STRING"});
    }
    if (exists(%params, "CONTENT_TYPE")) {
        $req{"content_type"} = $params{"CONTENT_TYPE"};
    }
    if (exists(%params, "CONTENT_LENGTH")) {
        $req{"content_length"} = $params{"CONTENT_LENGTH"};
    }
    if (exists(%params, "REMOTE_ADDR")) {
        $req{"remote_addr"} = $params{"REMOTE_ADDR"};
    }
    if (exists(%params, "REMOTE_PORT")) {
        $req{"remote_port"} = $params{"REMOTE_PORT"};
    }

    # Map HTTP headers
    my hash %headers = ();
    my array @k = keys(%params);
    my int $i = 0;

    while ($i < scalar(@k)) {
        my str $key = @k[$i];
        if (substr($key, 0, 5) eq "HTTP_") {
            my str $header_name = substr($key, 5, length($key) - 5);
            # Convert HTTP_CONTENT_TYPE to content-type
            $header_name = ::header_from_cgi($header_name);
            $headers{$header_name} = $params{$key};
        }
        $i = $i + 1;
    }

    $req{"headers"} = \%headers;

    return %req;
}

# Convert CGI header name to HTTP header name
func Cannoli_FastCGI_header_from_cgi(str $name) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($name);
    my int $next_upper = 1;

    while ($i < $len) {
        my str $ch = substr($name, $i, 1);

        if ($ch eq "_") {
            $result = $result . "-";
            $next_upper = 1;
        } elsif ($next_upper == 1) {
            $result = $result . $ch;
            $next_upper = 0;
        } else {
            # Lowercase
            my int $code = ord($ch);
            if ($code >= 65 && $code <= 90) {
                $result = $result . chr($code + 32);
            } else {
                $result = $result . $ch;
            }
        }

        $i = $i + 1;
    }

    return $result;
}

# Build FCGI_STDOUT response
func Cannoli_FastCGI_build_response(hash %res, int $request_id) str {
    # Build HTTP response
    my str $http_response = Cannoli::Response::build(%res);

    # Build FCGI_STDOUT record(s)
    my str $output = "";
    my int $pos = 0;
    my int $len = length($http_response);

    while ($pos < $len) {
        my int $chunk_size = $len - $pos;
        if ($chunk_size > 65535) {
            $chunk_size = 65535;
        }

        my str $chunk = substr($http_response, $pos, $chunk_size);

        # Calculate padding
        my int $mod8 = fcgi_mod($chunk_size, 8);
        my int $padding = 8 - $mod8;
        $padding = fcgi_mod($padding, 8);

        # Header
        $output = $output . ::make_header(FCGI_STDOUT(), $request_id, $chunk_size, $padding);

        # Content
        $output = $output . $chunk;

        # Padding
        my int $p = 0;
        while ($p < $padding) {
            $output = $output . chr(0);
            $p = $p + 1;
        }

        $pos = $pos + $chunk_size;
    }

    # Empty FCGI_STDOUT to signal end
    $output = $output . ::make_header(FCGI_STDOUT(), $request_id, 0, 0);

    # FCGI_END_REQUEST
    my str $end_body = "";
    # App status (4 bytes, big-endian)
    $end_body = $end_body . chr(0) . chr(0) . chr(0) . chr(0);
    # Protocol status
    $end_body = $end_body . chr(FCGI_REQUEST_COMPLETE());
    # Reserved (3 bytes)
    $end_body = $end_body . chr(0) . chr(0) . chr(0);

    $output = $output . ::make_header(FCGI_END_REQUEST(), $request_id, 8, 0);
    $output = $output . $end_body;

    return $output;
}

# Handle a single FastCGI connection
func Cannoli_FastCGI_handle_connection(int $fd, scalar $router) void {
    my hash %params = ();
    my str $stdin_data = "";
    my int $request_id = 0;
    my int $done = 0;

    while ($done == 0) {
        # Read header
        my str $header_data = sys::read_fd($fd, 8);
        if (length($header_data) < 8) {
            last;
        }

        my hash %header = ::parse_header($header_data);
        if ($header{"valid"} == 0) {
            last;
        }

        $request_id = $header{"request_id"};
        my int $content_len = $header{"content_length"};
        my int $padding_len = $header{"padding_length"};

        # Read content
        my str $content = "";
        if ($content_len > 0) {
            $content = sys::read_fd($fd, $content_len);
        }

        # Skip padding bytes
        if ($padding_len > 0) {
            sys::read_fd($fd, $padding_len);
        }

        # Handle record type
        my int $rec_type = $header{"type"};

        if ($rec_type == FCGI_BEGIN_REQUEST()) {
            # New request
        } elsif ($rec_type == FCGI_PARAMS()) {
            if ($content_len > 0) {
                my hash %new_params = ::parse_params($content);
                my array @k = keys(%new_params);
                my int $i = 0;
                while ($i < scalar(@k)) {
                    my str $key = @k[$i];
                    $params{$key} = $new_params{$key};
                    $i = $i + 1;
                }
            }
        } elsif ($rec_type == FCGI_STDIN()) {
            if ($content_len > 0) {
                $stdin_data = $stdin_data . $content;
            } else {
                # Empty STDIN means end of request
                $done = 1;
            }
        } elsif ($rec_type == FCGI_ABORT_REQUEST()) {
            last;
        }
    }

    # Build request from params
    my hash %req = ::params_to_request(%params);
    $req{"body"} = $stdin_data;

    # Dispatch to router
    my hash %res = ();
    if (defined($router)) {
        %res = Cannoli::Router::dispatch($router, %req);
    } else {
        %res = Cannoli::Response::text(200, "Cannoli FastCGI server running");
    }

    # Send response
    my str $response = ::build_response(%res, $request_id);
    sys::write_fd($fd, $response);

    sys::close_fd($fd);
}

# FastCGI worker loop
func Cannoli_FastCGI_worker_loop(int $listen_fd, scalar $router, int $max_requests) void {
    my int $requests_handled = 0;

    while ($requests_handled < $max_requests) {
        my int $fd = sys::socket_accept($listen_fd);

        if ($fd < 0) {
            sys::usleep(10000);
            next;
        }

        ::handle_connection($fd, $router);
        $requests_handled = $requests_handled + 1;
    }
}

# Run FastCGI server (TCP mode - nginx connects via TCP)
# Note: Unix sockets would require additional runtime support
func Cannoli_FastCGI_run(str $socket_path, scalar $router, int $num_workers) int {
    # For now, use TCP port 9000 (standard FastCGI port)
    # socket_path is ignored - would need Unix socket support in runtime
    length($socket_path);
    my int $port = 9000;

    my int $fd = sys::socket_server($port, 128);

    if ($fd < 0) {
        say("Error: Could not create FastCGI socket on port " . $port);
        return 1;
    }

    say("FastCGI listening on TCP port " . $port);
    say("Note: Configure nginx with 'fastcgi_pass 127.0.0.1:9000;'");
    say("Starting " . $num_workers . " worker processes...");

    # Fork workers
    my int $i = 0;
    while ($i < $num_workers) {
        my int $pid = sys::fork();

        if ($pid == 0) {
            # Child
            ::worker_loop($fd, $router, 1000);
            exit(0);
        } elsif ($pid > 0) {
            say("Spawned FastCGI worker " . ($i + 1) . " with PID " . $pid);
        }

        $i = $i + 1;
    }

    # Master waits for children
    while (1) {
        my int $status = 0;
        my int $pid = sys::waitpid(-1, $status);

        if ($pid > 0) {
            say("FastCGI worker " . $pid . " exited, respawning...");

            my int $new_pid = sys::fork();
            if ($new_pid == 0) {
                ::worker_loop($fd, $router, 1000);
                exit(0);
            } elsif ($new_pid > 0) {
                say("Respawned FastCGI worker with PID " . $new_pid);
            }
        }

        sys::usleep(100000);
    }

    return 0;
}
