/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

package Cannoli;


# cannoli_obj.strada - Request/Response object for Strada handlers
#
# This module provides an object-oriented interface for handling
# HTTP requests in Cannoli Strada handlers, matching the Perl Cannoli interface.
#
# Usage:
#   func handle(scalar $c) hash {
#       my str $method = $c->method();
#       my str $path = $c->path();
#       $c->status(200);
#       $c->content_type("application/json");
#       $c->write_body('{"ok":true}');
#       return $c->build_response();
#   }

# Methods are defined on the Cannoli object package

# Constructor - create from request hash
func Cannoli_new(hash %req) scalar {
    my hash %self = ();

    # Request data
    $self{"_method"} = $req{"method"};
    $self{"_path"} = $req{"path"};
    $self{"_path_info"} = $req{"path_info"};
    $self{"_query_string"} = $req{"query_string"};
    $self{"_body"} = $req{"body"};
    $self{"_headers"} = $req{"headers"};
    $self{"_remote_addr"} = $req{"remote_addr"};
    $self{"_content_type"} = $req{"content_type"};
    $self{"_params"} = $req{"params"};
    $self{"_captures"} = $req{"captures"};
    $self{"_files"} = $req{"files"};
    $self{"_variables"} = {};
    $self{"_document_root"} = "";

    # Extract Accept-Encoding for compression support
    my str $accept_enc = Cannoli::Request::get_header(%req, "Accept-Encoding");
    $self{"_req_accept_encoding"} = $accept_enc;

    # Socket/connection info for chunked responses
    if (exists(%req, "_fd")) {
        $self{"_fd"} = $req{"_fd"};
    }
    if (exists(%req, "_client")) {
        $self{"_client"} = $req{"_client"};
    }
    if (exists(%req, "_ssl")) {
        $self{"_ssl"} = $req{"_ssl"};
        $self{"_ssl_conn"} = $req{"_ssl_conn"};
        if (exists(%req, "_ssl_read_fn")) {
            $self{"_ssl_read_fn"} = $req{"_ssl_read_fn"};
        }
        $self{"_ssl_write_fn"} = $req{"_ssl_write_fn"};
        if (exists(%req, "_ssl_close_fn")) {
            $self{"_ssl_close_fn"} = $req{"_ssl_close_fn"};
        }
    }

    # Response data
    $self{"_res_status"} = 200;
    $self{"_res_content_type"} = "";
    $self{"_res_headers"} = {};
    $self{"_res_body"} = "";
    $self{"_res_redirect"} = "";
    $self{"_allow_ranges"} = 0;

    return bless(\%self, "Cannoli");
}

#
# Request Accessors
#

func Cannoli_method(scalar $self) str {
    return $self->{"_method"};
}

func Cannoli_path(scalar $self) str {
    return $self->{"_path"};
}

func Cannoli_path_info(scalar $self) str {
    return $self->{"_path_info"};
}

func Cannoli_query_string(scalar $self) str {
    return $self->{"_query_string"};
}

func Cannoli_body(scalar $self) str {
    return $self->{"_body"};
}

# Get parsed JSON Cannoli_body(lazy parsing)
func Cannoli_json_body(scalar $self) scalar {
    # Return cached if already parsed
    if (exists(%{$self}, "_json_body_parsed")) {
        return $self->{"_json_body"};
    }

    # Check content type
    my str $ct = $self->{"_content_type"};
    if (index($ct, "application/json") < 0) {
        $self->{"_json_body_parsed"} = 1;
        $self->{"_json_body"} = undef;
        return undef;
    }

    # Parse JSON body
    my str $body_str = $self->{"_body"};
    if (length($body_str) == 0) {
        $self->{"_json_body_parsed"} = 1;
        $self->{"_json_body"} = undef;
        return undef;
    }

    my scalar $parsed = Cannoli::Request::json_parse($body_str);
    $self->{"_json_body_parsed"} = 1;
    $self->{"_json_body"} = $parsed;
    return $parsed;
}

# Get a value from JSON body by key
func Cannoli_json_param(scalar $self, str $key) scalar {
    my scalar $json = $self->json_body();
    if (!defined($json)) {
        return undef;
    }
    if (ref($json) ne "hash") {
        return undef;
    }
    if (exists(%{$json}, $key)) {
        return $json->{$key};
    }
    return undef;
}

# Check if request has JSON content type
func Cannoli_is_json(scalar $self) int {
    my str $ct = $self->{"_content_type"};
    return index($ct, "application/json") >= 0;
}

func Cannoli_remote_addr(scalar $self) str {
    return $self->{"_remote_addr"};
}

func Cannoli_request_content_type(scalar $self) str {
    return $self->{"_content_type"};
}

# Get all request headers as hash ref
func Cannoli_headers(scalar $self) scalar {
    return $self->{"_headers"};
}

# Get a specific request Cannoli_header(case-insensitive)
func Cannoli_header(scalar $self, str $name) str {
    my str $lc_name = lc($name);
    my scalar $hdrs = $self->{"_headers"};
    if (exists(%{$hdrs}, $lc_name)) {
        return $hdrs->{$lc_name};
    }
    return "";
}

# Check if request has a header
func Cannoli_has_header(scalar $self, str $name) int {
    my str $lc_name = lc($name);
    return exists(%{$self->{"_headers"}}, $lc_name);
}

# Get all parsed parameters
func Cannoli_params(scalar $self) scalar {
    return $self->{"_params"};
}

# Get a specific parameter
func Cannoli_param(scalar $self, str $name) str {
    my scalar $p = $self->{"_params"};
    if (exists(%{$p}, $name)) {
        return $p->{$name};
    }
    return "";
}

# Check if parameter exists
func Cannoli_has_param(scalar $self, str $name) int {
    return exists(%{$self->{"_params"}}, $name);
}

#
# File Upload Accessors
#

# Get an uploaded file by field name
# Returns hash with: name, filename, content_type, content, size
func Cannoli_file(scalar $self, str $name) scalar {
    my scalar $files = $self->{"_files"};
    if (!defined($files)) {
        return undef;
    }
    if (exists(%{$files}, $name)) {
        return $files->{$name};
    }
    return undef;
}

# Get all uploaded files as hash ref
func Cannoli_files(scalar $self) scalar {
    my scalar $files = $self->{"_files"};
    if (!defined($files)) {
        my hash %empty = ();
        return \%empty;
    }
    return $files;
}

# Check if a file was uploaded with the given field name
func Cannoli_has_file(scalar $self, str $name) int {
    my scalar $files = $self->{"_files"};
    if (!defined($files)) {
        return 0;
    }
    return exists(%{$files}, $name);
}

# Get file content by field name
func Cannoli_file_content(scalar $self, str $name) str {
    my scalar $file = $self->file($name);
    if (!defined($file)) {
        return "";
    }
    return $file->{"content"};
}

# Get original filename by field name
func Cannoli_file_name(scalar $self, str $name) str {
    my scalar $file = $self->file($name);
    if (!defined($file)) {
        return "";
    }
    return $file->{"filename"};
}

# Get file size by field name
func Cannoli_file_size(scalar $self, str $name) int {
    my scalar $file = $self->file($name);
    if (!defined($file)) {
        return 0;
    }
    return $file->{"size"};
}

# Get file content type by field name
func Cannoli_file_type(scalar $self, str $name) str {
    my scalar $file = $self->file($name);
    if (!defined($file)) {
        return "";
    }
    return $file->{"content_type"};
}

# Get route captures
func Cannoli_captures(scalar $self) scalar {
    return $self->{"_captures"};
}

# Get a specific capture by index
func Cannoli_capture(scalar $self, int $idx) str {
    my scalar $caps = $self->{"_captures"};
    if ($idx < scalar(@{$caps})) {
        return $caps->[$idx];
    }
    return "";
}

# Check request method helpers
func Cannoli_is_get(scalar $self) int {
    return $self->{"_method"} eq "GET";
}

func Cannoli_is_post(scalar $self) int {
    return $self->{"_method"} eq "POST";
}

func Cannoli_is_put(scalar $self) int {
    return $self->{"_method"} eq "PUT";
}

func Cannoli_is_delete(scalar $self) int {
    return $self->{"_method"} eq "DELETE";
}

func Cannoli_is_patch(scalar $self) int {
    return $self->{"_method"} eq "PATCH";
}

func Cannoli_is_head(scalar $self) int {
    return $self->{"_method"} eq "HEAD";
}

func Cannoli_is_options(scalar $self) int {
    return $self->{"_method"} eq "OPTIONS";
}

# Check if AJAX request
func Cannoli_is_ajax(scalar $self) int {
    return $self->header("x-requested-with") eq "XMLHttpRequest";
}

# Get user agent
func Cannoli_user_agent(scalar $self) str {
    return $self->header("user-agent");
}

# Get referer
func Cannoli_referer(scalar $self) str {
    return $self->header("referer");
}

# Get host
func Cannoli_host(scalar $self) str {
    return $self->header("host");
}

#
# nginx-compatible aliases
#

# $r->args - returns request arguments (query string)
func Cannoli_args(scalar $self) str {
    return $self->{"_query_string"};
}

# $r->uri - returns request URI (path)
func Cannoli_uri(scalar $self) str {
    return $self->{"_path"};
}

# $r->request_method - returns HTTP method
func Cannoli_request_method(scalar $self) str {
    return $self->{"_method"};
}

# $r->request_body - returns client request body
func Cannoli_request_body(scalar $self) str {
    return $self->{"_body"};
}

# $r->header_in(field) - returns value of client request header
func Cannoli_header_in(scalar $self, str $field) str {
    return $self->header($field);
}

# $r->header_out(field, value) - sets response header field
func Cannoli_header_out(scalar $self, str $field, str $value) scalar {
    return $self->set_header($field, $value);
}

# $r->header_only - returns true if HEAD request
func Cannoli_header_only(scalar $self) int {
    return $self->{"_method"} eq "HEAD";
}

# $r->filename - returns document_root + path
func Cannoli_filename(scalar $self) str {
    my str $root = $self->{"_document_root"};
    if (length($root) == 0) {
        return "";
    }
    return $root . $self->{"_path"};
}

# $r->unescape(text) - URL decode
func Cannoli_unescape(scalar $self, str $text) str {
    defined($self);
    return Cannoli_url_decode($text);
}

# $r->variable(name, value) - get/set request variable
func Cannoli_variable(scalar $self, str $name, str $value) scalar {
    my scalar $vars = $self->{"_variables"};
    if (length($value) > 0) {
        $vars->{$name} = $value;
        return $self;
    }
    if (exists(%{$vars}, $name)) {
        return $vars->{$name};
    }
    return "";
}

# Alias: stash
func Cannoli_stash(scalar $self, str $name, str $value) scalar {
    return $self->variable($name, $value);
}

# $r->log_error(errno, message) - log error
func Cannoli_log_error(scalar $self, int $errno, str $message) scalar {
    if ($errno != 0) {
        say("[error] " . $message . " (errno: " . $errno . ")");
    } else {
        say("[error] " . $message);
    }
    return $self;
}

# $r->allow_ranges - enable byte-range support
func Cannoli_allow_ranges(scalar $self) scalar {
    $self->{"_allow_ranges"} = 1;
    return $self;
}

# $r->flush - no-op in our model
func Cannoli_flush(scalar $self) scalar {
    return $self;
}

# $r->discard_request_body - no-op
func Cannoli_discard_request_body(scalar $self) scalar {
    return $self;
}

# $r->send_http_header(type) - set content type
func Cannoli_send_http_header(scalar $self, str $type) scalar {
    if (length($type) > 0) {
        $self->content_type($type);
    }
    return $self;
}

#
# Response Methods
#

# Set/get response status
func Cannoli_status(scalar $self, int $code) scalar {
    if ($code > 0) {
        $self->{"_res_status"} = $code;
    }
    return $self;
}

# Get status code
func Cannoli_get_status(scalar $self) int {
    return $self->{"_res_status"};
}

# Set/get response content type
func Cannoli_content_type(scalar $self, str $type) scalar {
    if (length($type) > 0) {
        $self->{"_res_content_type"} = $type;
    }
    return $self;
}

# Get content type
func Cannoli_get_content_type(scalar $self) str {
    return $self->{"_res_content_type"};
}

# Set a response header
func Cannoli_set_header(scalar $self, str $name, str $value) scalar {
    my scalar $hdrs = $self->{"_res_headers"};
    $hdrs->{$name} = $value;
    return $self;
}

# Get response headers
func Cannoli_response_headers(scalar $self) scalar {
    return $self->{"_res_headers"};
}

# Write to response body
func Cannoli_write_body(scalar $self, str $content) scalar {
    $self->{"_res_body"} = $self->{"_res_body"} . $content;
    return $self;
}

# Alias for Cannoli_write_body(nginx compat: print)
func Cannoli_print_body(scalar $self, str $content) scalar {
    return $self->write_body($content);
}

# Set response Cannoli_body(replaces existing)
func Cannoli_body_set(scalar $self, str $content) scalar {
    $self->{"_res_body"} = $content;
    return $self;
}

# Get response body
func Cannoli_response_body(scalar $self) str {
    return $self->{"_res_body"};
}

# Send redirect
func Cannoli_redirect(scalar $self, str $url, int $code) scalar {
    $self->{"_res_redirect"} = $url;
    if ($code > 0) {
        $self->{"_res_status"} = $code;
    } else {
        $self->{"_res_status"} = 302;
    }
    return $self;
}

# Render JSON response
func Cannoli_render_json(scalar $self, scalar $data) scalar {
    $self->content_type("application/json");
    $self->write_body(Cannoli_to_json($data));
    return $self;
}

# Render text response
func Cannoli_render_text(scalar $self, str $text) scalar {
    $self->content_type("text/plain");
    $self->write_body($text);
    return $self;
}

# Render HTML response
func Cannoli_render_html(scalar $self, str $html) scalar {
    $self->content_type("text/html");
    $self->write_body($html);
    return $self;
}

# Send error response
func Cannoli_error(scalar $self, int $code, str $message) scalar {
    if ($code == 0) {
        $code = 500;
    }
    $self->status($code);
    $self->content_type("application/json");
    if (length($message) == 0) {
        $message = "Internal Server Error";
    }
    $self->body_set("{\"error\":\"" . $message . "\"}");
    return $self;
}

# Send not found response
func Cannoli_not_found(scalar $self, str $message) scalar {
    if (length($message) == 0) {
        $message = "Not Found";
    }
    return $self->error(404, $message);
}

# Send bad request response
func Cannoli_bad_request(scalar $self, str $message) scalar {
    if (length($message) == 0) {
        $message = "Bad Request";
    }
    return $self->error(400, $message);
}

# Set cookie
func Cannoli_set_cookie(scalar $self, str $name, str $value, str $path, int $max_age, int $httponly, int $secure) scalar {
    my str $cookie = $name . "=" . $value;
    if (length($path) > 0) {
        $cookie = $cookie . "; Path=" . $path;
    }
    if ($max_age > 0) {
        $cookie = $cookie . "; Max-Age=" . $max_age;
    }
    if ($httponly == 1) {
        $cookie = $cookie . "; HttpOnly";
    }
    if ($secure == 1) {
        $cookie = $cookie . "; Secure";
    }
    $self->set_header("Set-Cookie", $cookie);
    return $self;
}

# Send file content
func Cannoli_sendfile(scalar $self, str $filepath) scalar {
    if (!sys::is_file($filepath)) {
        $self->log_error(0, "File not found: " . $filepath);
        return $self;
    }

    my str $content = sys::slurp($filepath);

    # Auto-detect content type
    my str $ct = "application/octet-stream";
    if ($filepath =~ /\.html?$/i) { $ct = "text/html"; }
    elsif ($filepath =~ /\.css$/i) { $ct = "text/css"; }
    elsif ($filepath =~ /\.js$/i) { $ct = "application/javascript"; }
    elsif ($filepath =~ /\.json$/i) { $ct = "application/json"; }
    elsif ($filepath =~ /\.xml$/i) { $ct = "application/xml"; }
    elsif ($filepath =~ /\.txt$/i) { $ct = "text/plain"; }
    elsif ($filepath =~ /\.png$/i) { $ct = "image/png"; }
    elsif ($filepath =~ /\.jpe?g$/i) { $ct = "image/jpeg"; }
    elsif ($filepath =~ /\.gif$/i) { $ct = "image/gif"; }
    elsif ($filepath =~ /\.svg$/i) { $ct = "image/svg+xml"; }
    elsif ($filepath =~ /\.ico$/i) { $ct = "image/x-icon"; }
    elsif ($filepath =~ /\.pdf$/i) { $ct = "application/pdf"; }
    elsif ($filepath =~ /\.zip$/i) { $ct = "application/zip"; }

    if (length($self->{"_res_content_type"}) == 0) {
        $self->content_type($ct);
    }
    $self->write_body($content);

    if ($self->{"_allow_ranges"} == 1) {
        $self->set_header("Accept-Ranges", "bytes");
    }

    return $self;
}

#
# Chunked Transfer Encoding Methods
#

# Start a chunked response - sends headers immediately
# After calling this, use Cannoli_write_chunk() to send data, then Cannoli_end_chunked() to finish
func Cannoli_start_chunked(scalar $self) scalar {
    # Build a response hash with current settings
    my hash %res = Cannoli::Response::new();
    Cannoli::Response::status(%res, $self->{"_res_status"});

    # Set content type
    if (length($self->{"_res_content_type"}) > 0) {
        Cannoli::Response::content_type(%res, $self->{"_res_content_type"});
    }

    # Set custom headers
    my scalar $custom_hdrs = $self->{"_res_headers"};
    my array @hdr_names = keys(%{$custom_hdrs});
    my int $i = 0;
    while ($i < scalar(@hdr_names)) {
        my str $name = @hdr_names[$i];
        my str $value = $custom_hdrs->{$name};
        Cannoli::Response::header(%res, $name, $value);
        $i = $i + 1;
    }

    # Check if SSL or regular socket
    if (exists(%{$self}, "_ssl") && $self->{"_ssl"} == 1) {
        # SSL chunked - need to send headers via SSL write
        my scalar $ssl_conn = $self->{"_ssl_conn"};
        my scalar $ssl_write_fn = $self->{"_ssl_write_fn"};

        Cannoli::Response::header(%res, "Transfer-Encoding", "chunked");
        Cannoli::Response::remove_header(%res, "Content-Length");
        my str $headers = Cannoli::Response::build_headers(%res);
        sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $headers]);

        $self->{"_chunked"} = 1;
        $self->{"_chunked_ssl"} = 1;
    } else {
        # Regular socket chunked
        my int $fd = $self->{"_fd"};
        %res = Cannoli::Response::chunked_start(%res, $fd);
        $self->{"_chunked"} = 1;
        $self->{"_chunked_res"} = \%res;
    }

    return $self;
}

# Write a chunk of data
# Returns bytes written, or -1 on error
func Cannoli_write_chunk(scalar $self, str $data) int {
    if (length($data) == 0) {
        return 0;
    }

    # Format chunk: hex_length\r\n data \r\n
    my str $hex_len = Cannoli::Response::to_hex(length($data));
    my str $chunk = $hex_len . "\r\n" . $data . "\r\n";

    if (exists(%{$self}, "_chunked_ssl") && $self->{"_chunked_ssl"} == 1) {
        # SSL write
        my scalar $ssl_conn = $self->{"_ssl_conn"};
        my scalar $ssl_write_fn = $self->{"_ssl_write_fn"};
        return sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $chunk]);
    } else {
        # Regular socket write
        my int $fd = $self->{"_fd"};
        return sys::write_fd($fd, $chunk);
    }
}

# End the chunked response - sends terminating chunk
func Cannoli_end_chunked(scalar $self) scalar {
    my str $terminator = "0\r\n\r\n";

    if (exists(%{$self}, "_chunked_ssl") && $self->{"_chunked_ssl"} == 1) {
        # SSL write
        my scalar $ssl_conn = $self->{"_ssl_conn"};
        my scalar $ssl_write_fn = $self->{"_ssl_write_fn"};
        sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $terminator]);
    } else {
        # Regular socket write
        my int $fd = $self->{"_fd"};
        sys::write_fd($fd, $terminator);
    }

    return $self;
}

# Check if response is in chunked mode
func Cannoli_is_chunked(scalar $self) int {
    if (exists(%{$self}, "_chunked")) {
        return $self->{"_chunked"};
    }
    return 0;
}

#
# WebSocket Methods
#

func Cannoli_ws_accept(scalar $self, str $protocol = "") scalar {
    my hash %req = ();
    $req{"method"} = $self->{"_method"};
    $req{"headers"} = $self->{"_headers"};

    if (exists(%{$self}, "_client")) {
        $req{"_client"} = $self->{"_client"};
        $req{"_fd"} = $self->{"_fd"};
    }

    if (exists(%{$self}, "_ssl") && $self->{"_ssl"} == 1) {
        $req{"_ssl"} = $self->{"_ssl"};
        $req{"_ssl_conn"} = $self->{"_ssl_conn"};
        if (exists(%{$self}, "_ssl_read_fn")) {
            $req{"_ssl_read_fn"} = $self->{"_ssl_read_fn"};
        }
        $req{"_ssl_write_fn"} = $self->{"_ssl_write_fn"};
        if (exists(%{$self}, "_ssl_close_fn")) {
            $req{"_ssl_close_fn"} = $self->{"_ssl_close_fn"};
        }
    }

    my scalar $ws = Cannoli::WebSocket::accept(%req, $protocol);
    if (defined($ws)) {
        $self->{"_ws_active"} = 1;
        $self->{"_ws_status"} = 101;
    }
    return $ws;
}

#
# Build response hash from Cannoli state
#

func Cannoli_build_response(scalar $self) hash {
    if (exists(%{$self}, "_ws_active") && $self->{"_ws_active"} == 1) {
        my int $status = 101;
        if (exists(%{$self}, "_ws_status")) {
            $status = $self->{"_ws_status"};
        }
        return Cannoli::Response::sent($status);
    }

    # If chunked mode, response was already sent
    if ($self->is_chunked() == 1) {
        return Cannoli::Response::empty();
    }

    my hash %res = Cannoli::Response::new();

    # Handle redirect
    if (length($self->{"_res_redirect"}) > 0) {
        return Cannoli::Response::redirect($self->{"_res_redirect"}, $self->{"_res_status"});
    }

    # Set status
    Cannoli::Response::status(%res, $self->{"_res_status"});

    # Set content type
    if (length($self->{"_res_content_type"}) > 0) {
        Cannoli::Response::content_type(%res, $self->{"_res_content_type"});
    }

    # Set body
    Cannoli::Response::body(%res, $self->{"_res_body"});

    # Set custom headers
    my scalar $custom_hdrs = $self->{"_res_headers"};
    my array @hdr_names = keys(%{$custom_hdrs});
    my int $i = 0;
    while ($i < scalar(@hdr_names)) {
        my str $name = @hdr_names[$i];
        my str $value = $custom_hdrs->{$name};
        Cannoli::Response::header(%res, $name, $value);
        $i = $i + 1;
    }

    # Apply compression if enabled
    if ($self->is_compress_enabled() == 1) {
        if (exists(%{$self}, "_auto_compress")) {
            # Auto-compress based on Accept-Encoding
            my str $accept = $self->{"_req_accept_encoding"};
            Cannoli::Response::auto_compress(%res, $accept);
        } else {
            # Force gzip compression
            Cannoli::Response::compress_gzip(%res);
        }
    }

    return %res;
}

# end package Cannoli

#
# Helper functions (utility routines in Cannoli package)
#

# URL decode helper
func Cannoli_url_decode(str $s) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch eq "+") {
            $result = $result . " ";
            $i = $i + 1;
        } elsif ($ch eq "%" && $i + 2 < $len) {
            my str $hex = substr($s, $i + 1, 2);
            my int $code = Cannoli_hex_to_int($hex);
            $result = $result . chr($code);
            $i = $i + 3;
        } else {
            $result = $result . $ch;
            $i = $i + 1;
        }
    }

    return $result;
}

# Hex to int helper
func Cannoli_hex_to_int(str $hex) int {
    my int $result = 0;
    my int $i = 0;
    my int $len = length($hex);

    while ($i < $len) {
        my str $ch = substr($hex, $i, 1);
        my int $val = 0;

        if ($ch ge "0" && $ch le "9") {
            $val = ord($ch) - ord("0");
        } elsif ($ch ge "a" && $ch le "f") {
            $val = ord($ch) - ord("a") + 10;
        } elsif ($ch ge "A" && $ch le "F") {
            $val = ord($ch) - ord("A") + 10;
        }

        $result = $result * 16 + $val;
        $i = $i + 1;
    }

    return $result;
}

# Create Cannoli object from request hash (convenience function)
func Cannoli_from_request(hash %req) scalar {
    return Cannoli_new(%req);
}

# Simple JSON encoder
func Cannoli_to_json(scalar $data) str {
    if (!defined($data)) {
        return "null";
    }

    my str $type = ref($data);

    if ($type eq "hash") {
        my array @keys = keys(%{$data});
        my int $num = scalar(@keys);
        my str $result = "{";
        my int $i = 0;

        while ($i < $num) {
            my str $key = @keys[$i];
            my scalar $val = $data->{$key};

            if ($i > 0) {
                $result = $result . ",";
            }
            $result = $result . "\"" . Cannoli_json_escape($key) . "\":" . Cannoli_to_json($val);
            $i = $i + 1;
        }
        return $result . "}";
    }

    # Array (both anonymous arrays and named array refs)
    if ($type eq "array" || $type eq "ref") {
        my int $num = scalar(@{$data});
        my str $result = "[";
        my int $i = 0;

        while ($i < $num) {
            if ($i > 0) {
                $result = $result . ",";
            }
            $result = $result . Cannoli_to_json($data->[$i]);
            $i = $i + 1;
        }
        return $result . "]";
    }

    # Scalar value (ref() returns empty string for non-references)
    # Stringify and check if it's a number
    my str $s = "" . $data;
    if ($s =~ /^-?\d+$/) {
        return $s;
    }
    if ($s =~ /^-?\d+\.\d+$/) {
        return $s;
    }

    return "\"" . Cannoli_json_escape($s) . "\"";
}

# JSON string escape helper
func Cannoli_json_escape(str $s) str {
    my str $result = "";
    my int $len = length($s);
    my int $i = 0;

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        my int $code = ord($ch);

        if ($ch eq "\"") {
            $result = $result . "\\\"";
        } elsif ($ch eq "\\") {
            $result = $result . "\\\\";
        } elsif ($code == 10) {
            $result = $result . "\\n";
        } elsif ($code == 13) {
            $result = $result . "\\r";
        } elsif ($code == 9) {
            $result = $result . "\\t";
        } else {
            $result = $result . $ch;
        }
        $i = $i + 1;
    }

    return $result;
}

# ===== Error handling methods =====

# Get the error code (set when error handler is called)
func Cannoli_error_code(scalar $self) int {
    if (exists(%{$self}, "_error_code")) {
        return $self->{"_error_code"};
    }
    return 0;
}

# Get the error message (set when error handler is called)
func Cannoli_error_message(scalar $self) str {
    if (exists(%{$self}, "_error_message")) {
        return $self->{"_error_message"};
    }
    return "";
}

# Throw an exception (will be caught by error handler)
func Cannoli_throw_error(scalar $self, str $message) void {
    defined($self);
    throw $message;
}

# Render a custom error page
func Cannoli_render_error(scalar $self, int $code, str $message) void {
    $self->status($code);
    $self->content_type("text/html");

    my str $title = Cannoli::Response::status_message($code);

    my str $html = "<!DOCTYPE html>\n";
    $html = $html . "<html><head><title>" . $code . " " . $title . "</title>\n";
    $html = $html . "<style>\n";
    $html = $html . "body { font-family: sans-serif; text-align: center; padding: 50px; }\n";
    $html = $html . "h1 { color: #333; }\n";
    $html = $html . ".code { font-size: 72px; color: #e74c3c; }\n";
    $html = $html . ".message { color: #666; margin-top: 20px; }\n";
    $html = $html . "</style></head><body>\n";
    $html = $html . "<div class=\"code\">" . $code . "</div>\n";
    $html = $html . "<h1>" . $title . "</h1>\n";
    if (length($message) > 0) {
        $html = $html . "<p class=\"message\">" . Cannoli::Response::html_escape($message) . "</p>\n";
    }
    $html = $html . "</body></html>\n";

    $self->write_body($html);
}

# ===== Compression methods =====

# Enable gzip compression for this response
func Cannoli_compress(scalar $self) void {
    $self->{"_compress"} = 1;
}

# Enable auto-compression (based on Accept-Encoding)
func Cannoli_auto_compress(scalar $self) void {
    $self->{"_auto_compress"} = 1;
}

# Check if compression is enabled
func Cannoli_is_compress_enabled(scalar $self) int {
    if (exists(%{$self}, "_compress")) {
        return $self->{"_compress"};
    }
    if (exists(%{$self}, "_auto_compress")) {
        return $self->{"_auto_compress"};
    }
    return 0;
}

# ===== Session methods =====

# Get or create Cannoli_session(lazy loading from cookie)
func Cannoli_session(scalar $self) scalar {
    # Return cached session if already loaded
    if (exists(%{$self}, "_session")) {
        return $self->{"_session"};
    }

    # Try to load from session cookie
    my str $cookie_name = Cannoli::Session::cookie_name();
    my str $session_id = "";

    # Get cookies from request headers
    my scalar $hdrs = $self->{"_headers"};
    if (exists(%{$hdrs}, "cookie")) {
        my str $cookie_header = $hdrs->{"cookie"};
        # Parse cookies (format: name=value; name2=value2)
        my array @cookies = split($cookie_header, "; ");
        my int $i = 0;
        while ($i < scalar(@cookies)) {
            my str $cookie = @cookies[$i];
            my int $eq_pos = index($cookie, "=");
            if ($eq_pos > 0) {
                my str $name = substr($cookie, 0, $eq_pos);
                my str $value = substr($cookie, $eq_pos + 1, length($cookie) - $eq_pos - 1);
                if ($name eq $cookie_name) {
                    $session_id = $value;
                    last;
                }
            }
            $i = $i + 1;
        }
    }

    my scalar $session = undef;

    # Try to load existing session
    if (length($session_id) > 0) {
        $session = Cannoli::Session::load($session_id);
    }

    # Create new session if not found
    if (!defined($session)) {
        $session = Cannoli::Session::new();
        $self->{"_session_new"} = 1;  # Flag to set cookie
    }

    $self->{"_session"} = $session;
    return $session;
}

# Get a value from session
func Cannoli_session_get(scalar $self, str $key) scalar {
    my scalar $session = $self->session();
    return Cannoli::Session::get($session, $key);
}

# Set a value in session
func Cannoli_session_set(scalar $self, str $key, scalar $value) scalar {
    my scalar $session = $self->session();
    Cannoli::Session::set($session, $key, $value);
    return $self;
}

# Check if session has a key
func Cannoli_session_has(scalar $self, str $key) int {
    my scalar $session = $self->session();
    return Cannoli::Session::has($session, $key);
}

# Delete a value from session
func Cannoli_session_delete(scalar $self, str $key) scalar {
    my scalar $session = $self->session();
    Cannoli::Session::delete($session, $key);
    return $self;
}

# Save session and set cookie if new
func Cannoli_session_save(scalar $self) scalar {
    if (!exists(%{$self}, "_session")) {
        return $self;
    }

    my scalar $session = $self->{"_session"};
    Cannoli::Session::save($session);

    # Set session cookie if this is a new session
    if (exists(%{$self}, "_session_new") && $self->{"_session_new"} == 1) {
        my str $cookie_name = Cannoli::Session::cookie_name();
        my str $session_id = Cannoli::Session::id($session);
        my int $ttl = Cannoli::Session::ttl();
        $self->set_cookie($cookie_name, $session_id, "/", $ttl, 1, 0);
        $self->{"_session_new"} = 0;
    }

    return $self;
}

# Destroy session and clear cookie
func Cannoli_session_destroy(scalar $self) scalar {
    if (exists(%{$self}, "_session")) {
        my scalar $session = $self->{"_session"};
        my str $session_id = Cannoli::Session::id($session);
        Cannoli::Session::destroy($session_id);

        # Clear cookie by setting max-age to 0
        my str $cookie_name = Cannoli::Session::cookie_name();
        $self->set_cookie($cookie_name, "", "/", 0, 1, 0);

        $self->{"_session"} = undef;
    }

    return $self;
}

# Get session ID
func Cannoli_session_id(scalar $self) str {
    my scalar $session = $self->session();
    return Cannoli::Session::id($session);
}

# ===== Template methods =====

# Render a template and set response body
func Cannoli_render(scalar $self, str $template_name, scalar $vars) scalar {
    my str $html = Cannoli::Template::render($template_name, $vars);
    if (length($self->{"_res_content_type"}) == 0) {
        $self->content_type("text/html; charset=utf-8");
    }
    $self->write_body($html);
    return $self;
}

# Render a template with HTML escaping (safe mode)
func Cannoli_render_safe(scalar $self, str $template_name, scalar $vars) scalar {
    my str $html = Cannoli::Template::render_safe($template_name, $vars);
    if (length($self->{"_res_content_type"}) == 0) {
        $self->content_type("text/html; charset=utf-8");
    }
    $self->write_body($html);
    return $self;
}

# Render a template with a layout
func Cannoli_render_with_layout(scalar $self, str $template_name, str $layout_name, scalar $vars) scalar {
    my str $html = Cannoli::Template::render_with_layout($template_name, $layout_name, $vars);
    if (length($self->{"_res_content_type"}) == 0) {
        $self->content_type("text/html; charset=utf-8");
    }
    $self->write_body($html);
    return $self;
}

# Render a template string directly
func Cannoli_render_string(scalar $self, str $template, scalar $vars) scalar {
    my str $html = Cannoli::Template::render_string($template, $vars);
    if (length($self->{"_res_content_type"}) == 0) {
        $self->content_type("text/html; charset=utf-8");
    }
    $self->write_body($html);
    return $self;
}

# ===== Validation methods =====

# Create a validator from rules hash
# rules format: { "email" => ["required", "email"], "password" => ["required", "min_length:8"] }
func Cannoli_validate(scalar $self, scalar $rules) scalar {
    my scalar $params = $self->{"_params"};

    # Also include JSON body params if available
    if ($self->is_json() == 1) {
        my scalar $json_body = $self->json_body();
        if (defined($json_body) && ref($json_body) eq "hash") {
            # Merge JSON body into Cannoli_params(JSON takes precedence)
            my array @json_keys = keys(%{$json_body});
            my int $i = 0;
            while ($i < scalar(@json_keys)) {
                my str $key = @json_keys[$i];
                $params->{$key} = $json_body->{$key};
                $i = $i + 1;
            }
        }
    }

    return Cannoli::Validation::from_rules($params, $rules);
}

# Validate and return JSON error response if invalid
# Returns 1 if valid, 0 if invalid (and sets error response)
func Cannoli_validate_or_error(scalar $self, scalar $rules) int {
    my scalar $v = $self->validate($rules);

    if (Cannoli::Validation::validate($v) == 0) {
        my scalar $errors = Cannoli::Validation::errors($v);
        $self->status(400);
        $self->content_type("application/json");
        $self->render_json({"errors" => $errors});
        return 0;
    }

    return 1;
}

# ===== CORS methods =====

# Set CORS headers for cross-origin requests
# Usage: $c->cors("*") or $c->cors("https://example.com")
func Cannoli_cors(scalar $self, str $origin) scalar {
    $self->set_header("Access-Control-Allow-Origin", $origin);
    $self->set_header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS");
    $self->set_header("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With");
    $self->set_header("Access-Control-Max-Age", "86400");
    return $self;
}

# Set CORS headers with custom options
# $options: { "methods" => "GET,POST", "headers" => "X-Custom", "credentials" => 1, "max_age" => 3600 }
func Cannoli_cors_options(scalar $self, str $origin, scalar $options) scalar {
    $self->set_header("Access-Control-Allow-Origin", $origin);

    if (defined($options)) {
        if (exists(%{$options}, "methods")) {
            $self->set_header("Access-Control-Allow-Methods", $options->{"methods"});
        } else {
            $self->set_header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS");
        }

        if (exists(%{$options}, "headers")) {
            $self->set_header("Access-Control-Allow-Headers", $options->{"headers"});
        } else {
            $self->set_header("Access-Control-Allow-Headers", "Content-Type, Authorization");
        }

        if (exists(%{$options}, "credentials") && $options->{"credentials"} == 1) {
            $self->set_header("Access-Control-Allow-Credentials", "true");
        }

        if (exists(%{$options}, "max_age")) {
            $self->set_header("Access-Control-Max-Age", "" . $options->{"max_age"});
        } else {
            $self->set_header("Access-Control-Max-Age", "86400");
        }
    }

    return $self;
}

# Handle OPTIONS preflight request (returns 1 if handled, 0 otherwise)
func Cannoli_handle_preflight(scalar $self, str $origin) int {
    if ($self->method() ne "OPTIONS") {
        return 0;
    }

    $self->cors($origin);
    $self->status(204);
    return 1;
}

# ===== Flash message methods =====

# Set a flash message (stored in session, cleared after read)
func Cannoli_flash(scalar $self, str $key, str $message) scalar {
    my scalar $session = $self->session();
    my scalar $flash = Cannoli::Session::get($session, "_flash");

    if (!defined($flash)) {
        $flash = {};
    }

    $flash->{$key} = $message;
    Cannoli::Session::set($session, "_flash", $flash);

    return $self;
}

# Get and clear a flash message
func Cannoli_get_flash(scalar $self, str $key) str {
    my scalar $session = $self->session();
    my scalar $flash = Cannoli::Session::get($session, "_flash");

    if (!defined($flash)) {
        return "";
    }

    if (!exists(%{$flash}, $key)) {
        return "";
    }

    my str $message = $flash->{$key};

    # Remove the message after reading - create new hash without this key
    my hash %new_flash = ();
    my array @flash_keys = keys(%{$flash});
    my int $i = 0;
    while ($i < scalar(@flash_keys)) {
        my str $k = @flash_keys[$i];
        if ($k ne $key) {
            $new_flash{$k} = $flash->{$k};
        }
        $i = $i + 1;
    }
    Cannoli::Session::set($session, "_flash", \%new_flash);

    return $message;
}

# Check if a flash message exists
func Cannoli_has_flash(scalar $self, str $key) int {
    my scalar $session = $self->session();
    my scalar $flash = Cannoli::Session::get($session, "_flash");

    if (!defined($flash)) {
        return 0;
    }

    return exists(%{$flash}, $key);
}

# Get all flash messages and clear them
func Cannoli_get_all_flash(scalar $self) scalar {
    my scalar $session = $self->session();
    my scalar $flash = Cannoli::Session::get($session, "_flash");

    if (!defined($flash)) {
        my hash %empty = ();
        return \%empty;
    }

    # Clear all flash messages
    Cannoli::Session::set($session, "_flash", {});

    return $flash;
}

# Common flash types
func Cannoli_flash_success(scalar $self, str $message) scalar {
    return $self->flash("success", $message);
}

func Cannoli_flash_error(scalar $self, str $message) scalar {
    return $self->flash("error", $message);
}

func Cannoli_flash_warning(scalar $self, str $message) scalar {
    return $self->flash("warning", $message);
}

func Cannoli_flash_info(scalar $self, str $message) scalar {
    return $self->flash("info", $message);
}

# ============================================================
# Basic Auth Helpers
# ============================================================

# Base64 decoding table (global)
my hash %g_b64_decode = ();

# Initialize base64 decode table
func Cannoli_init_base64() void {
    my str $chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    my int $i = 0;
    while ($i < 64) {
        my str $ch = substr($chars, $i, 1);
        $g_b64_decode{$ch} = $i;
        $i = $i + 1;
    }
    $g_b64_decode{"="} = 0;
}

# Decode base64 string
func Cannoli_base64_decode(str $encoded) str {
    # Initialize table if needed
    if (scalar(keys(%g_b64_decode)) == 0) {
        Cannoli_init_base64();
    }

    my str $result = "";
    my int $len = length($encoded);
    my int $i = 0;

    while ($i < $len) {
        # Get 4 characters
        my str $c1 = substr($encoded, $i, 1);
        my str $c2 = "";
        my str $c3 = "";
        my str $c4 = "";

        if ($i + 1 < $len) { $c2 = substr($encoded, $i + 1, 1); }
        if ($i + 2 < $len) { $c3 = substr($encoded, $i + 2, 1); }
        if ($i + 3 < $len) { $c4 = substr($encoded, $i + 3, 1); }

        # Skip whitespace
        if ($c1 eq " " || $c1 eq "\n" || $c1 eq "\r" || $c1 eq "\t") {
            $i = $i + 1;
            next;
        }

        # Get values from table
        my int $v1 = 0;
        my int $v2 = 0;
        my int $v3 = 0;
        my int $v4 = 0;

        if (exists(%g_b64_decode, $c1)) { $v1 = $g_b64_decode{$c1}; }
        if (exists(%g_b64_decode, $c2)) { $v2 = $g_b64_decode{$c2}; }
        if (exists(%g_b64_decode, $c3)) { $v3 = $g_b64_decode{$c3}; }
        if (exists(%g_b64_decode, $c4)) { $v4 = $g_b64_decode{$c4}; }

        # Decode 4 chars into 3 bytes
        my int $b1 = ($v1 * 4) + ($v2 / 16);
        my int $b2 = (($v2 % 16) * 16) + ($v3 / 4);
        my int $b3 = (($v3 % 4) * 64) + $v4;

        $result = $result . chr($b1);
        if ($c3 ne "=") {
            $result = $result . chr($b2);
        }
        if ($c4 ne "=") {
            $result = $result . chr($b3);
        }

        $i = $i + 4;
    }

    return $result;
}

# Get Basic Auth credentials from request
# Returns hash with {username, password} or undef if not present/invalid
func Cannoli_basic_auth_credentials(scalar $self) scalar {
    my str $auth_header = $self->header_in("Authorization");

    if (length($auth_header) == 0) {
        return undef;
    }

    # Check for "Basic " prefix
    if (length($auth_header) < 7) {
        return undef;
    }

    my str $prefix = substr($auth_header, 0, 6);
    if ($prefix ne "Basic ") {
        return undef;
    }

    # Extract and decode base64 part
    my str $encoded = substr($auth_header, 6, length($auth_header) - 6);
    my str $decoded = Cannoli_base64_decode($encoded);

    # Split on first colon (username:password)
    my int $colon_pos = index($decoded, ":");
    if ($colon_pos < 0) {
        return undef;
    }

    my str $username = substr($decoded, 0, $colon_pos);
    my str $password = substr($decoded, $colon_pos + 1, length($decoded) - $colon_pos - 1);

    my hash %creds = ();
    $creds{"username"} = $username;
    $creds{"password"} = $password;

    return \%creds;
}

# Get Basic Auth username (empty string if not present)
func Cannoli_basic_auth_user(scalar $self) str {
    my scalar $creds = $self->basic_auth_credentials();
    if (!defined($creds)) {
        return "";
    }
    return $creds->{"username"};
}

# Get Basic Auth password (empty string if not present)
func Cannoli_basic_auth_pass(scalar $self) str {
    my scalar $creds = $self->basic_auth_credentials();
    if (!defined($creds)) {
        return "";
    }
    return $creds->{"password"};
}

# Check if valid Basic Auth credentials are present
func Cannoli_has_basic_auth(scalar $self) int {
    my scalar $creds = $self->basic_auth_credentials();
    if (!defined($creds)) {
        return 0;
    }
    return 1;
}

# Send 401 Unauthorized response with WWW-Authenticate header
# Returns a response hash that should be returned from handler
func Cannoli_require_basic_auth(scalar $self, str $realm) hash {
    if (length($realm) == 0) {
        $realm = "Protected Area";
    }

    $self->status(401);
    $self->set_header("WWW-Authenticate", "Basic realm=\"" . $realm . "\"");
    $self->content_type("text/plain");
    $self->write_body("401 Unauthorized\n\nAuthentication required.");
    return $self->build_response();
}

# Validate Basic Auth against a username/password pair
# Returns 1 if valid, 0 if not
func Cannoli_check_basic_auth(scalar $self, str $expected_user, str $expected_pass) int {
    my scalar $creds = $self->basic_auth_credentials();
    if (!defined($creds)) {
        return 0;
    }

    my str $user = $creds->{"username"};
    my str $pass = $creds->{"password"};

    if ($user eq $expected_user && $pass eq $expected_pass) {
        return 1;
    }

    return 0;
}

# Validate Basic Auth using a callback function
# Callback receives (username, password) and returns 1 if valid
func Cannoli_validate_basic_auth(scalar $self, scalar $validator) int {
    my scalar $creds = $self->basic_auth_credentials();
    if (!defined($creds)) {
        return 0;
    }

    my str $user = $creds->{"username"};
    my str $pass = $creds->{"password"};

    return $validator->($user, $pass);
}
