/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# cannoli/src/response.strada - HTTP Response building
#
# Build and send HTTP responses

# HTTP status code messages
func Response_status_message(int $code) str {
    if ($code == 200) { return "OK"; }
    if ($code == 201) { return "Created"; }
    if ($code == 204) { return "No Content"; }
    if ($code == 301) { return "Moved Permanently"; }
    if ($code == 302) { return "Found"; }
    if ($code == 304) { return "Not Modified"; }
    if ($code == 400) { return "Bad Request"; }
    if ($code == 401) { return "Unauthorized"; }
    if ($code == 403) { return "Forbidden"; }
    if ($code == 404) { return "Not Found"; }
    if ($code == 405) { return "Method Not Allowed"; }
    if ($code == 413) { return "Payload Too Large"; }
    if ($code == 431) { return "Request Header Fields Too Large"; }
    if ($code == 500) { return "Internal Server Error"; }
    if ($code == 502) { return "Bad Gateway"; }
    if ($code == 503) { return "Service Unavailable"; }
    return "Unknown";
}

# Create a new response object
func Response_new() hash {
    my hash %res = ();

    $res{"status"} = 200;
    $res{"headers"} = {};
    $res{"body"} = "";
    $res{"sent"} = 0;

    # Set default headers
    my scalar $headers = $res{"headers"};
    $headers->{"Content-Type"} = "text/html; charset=utf-8";
    $headers->{"Server"} = "Cannoli/1.0";
    $headers->{"Connection"} = "close";

    return %res;
}

# Set status code
func Response_status(hash %res, int $code) void {
    $res{"status"} = $code;
}

# Set a header
func Response_header(hash %res, str $name, str $value) void {
    my scalar $headers = $res{"headers"};
    $headers->{$name} = $value;
}

# Set content type
func Response_content_type(hash %res, str $type) void {
    Response_header(%res, "Content-Type", $type);
}

# Set body content
func Response_body(hash %res, str $content) void {
    $res{"body"} = $content;
}

# Append to body
func Response_write(hash %res, str $content) void {
    $res{"body"} = $res{"body"} . $content;
}

# Build the complete HTTP response string
func Response_build(hash %res) str {
    my int $status_code = $res{"status"};
    my str $status_msg = Response_status_message($status_code);
    my str $body_content = $res{"body"};
    my scalar $headers = $res{"headers"};

    # Set content length
    $headers->{"Content-Length"} = "" . length($body_content);

    # Build status line
    my str $response = "HTTP/1.1 " . $status_code . " " . $status_msg . "\r\n";

    # Add headers (skip empty values)
    my array @header_names = keys(%{$headers});
    my int $i = 0;
    while ($i < scalar(@header_names)) {
        my str $name = @header_names[$i];
        my str $value = $headers->{$name};
        if (length($value) > 0) {
            $response = $response . $name . ": " . $value . "\r\n";
        }
        $i = $i + 1;
    }

    # End headers, add body
    $response = $response . "\r\n" . $body_content;

    return $response;
}

# Send response to a file descriptor
func Response_send_to(hash %res, int $fd) int {
    if ($res{"sent"} == 1) {
        return 0;
    }

    my str $data = Response_build(%res);
    my int $written = sys::write_fd($fd, $data);
    $res{"sent"} = 1;

    return $written;
}

# Convenience: Create and return a simple text response
func Response_text(int $status, str $content) hash {
    my hash %res = Response_new();
    Response_status(%res, $status);
    Response_content_type(%res, "text/plain; charset=utf-8");
    Response_body(%res, $content);
    return %res;
}

# Convenience: Create and return an HTML response
func Response_html(int $status, str $content) hash {
    my hash %res = Response_new();
    Response_status(%res, $status);
    Response_content_type(%res, "text/html; charset=utf-8");
    Response_body(%res, $content);
    return %res;
}

# Convenience: Create and return a JSON response
func Response_json(int $status, str $content) hash {
    my hash %res = Response_new();
    Response_status(%res, $status);
    Response_content_type(%res, "application/json");
    Response_body(%res, $content);
    return %res;
}

# Convenience: Redirect response
func Response_redirect(str $url, int $permanent) hash {
    my hash %res = Response_new();

    if ($permanent == 1) {
        Response_status(%res, 301);
    } else {
        Response_status(%res, 302);
    }

    Response_header(%res, "Location", $url);
    Response_body(%res, "");
    return %res;
}

# HTML escape helper
func Response_html_escape(str $s) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        if ($ch eq "<") {
            $result = $result . "&lt;";
        } elsif ($ch eq ">") {
            $result = $result . "&gt;";
        } elsif ($ch eq "&") {
            $result = $result . "&amp;";
        } elsif ($ch eq "\"") {
            $result = $result . "&quot;";
        } else {
            $result = $result . $ch;
        }

        $i = $i + 1;
    }

    return $result;
}

# Error page responses
func Response_error_page(int $code, str $message) hash {
    my str $status_msg = Response_status_message($code);
    my str $html_content = "<!DOCTYPE html>\n";
    $html_content = $html_content . "<html>\n<head>\n";
    $html_content = $html_content . "<title>" . $code . " " . $status_msg . "</title>\n";
    $html_content = $html_content . "<style>\n";
    $html_content = $html_content . "body { font-family: sans-serif; text-align: center; padding: 50px; }\n";
    $html_content = $html_content . "h1 { color: #333; }\n";
    $html_content = $html_content . "p { color: #666; }\n";
    $html_content = $html_content . ".code { font-size: 72px; color: #999; }\n";
    $html_content = $html_content . "</style>\n</head>\n<body>\n";
    $html_content = $html_content . "<div class=\"code\">" . $code . "</div>\n";
    $html_content = $html_content . "<h1>" . $status_msg . "</h1>\n";

    if (length($message) > 0) {
        $html_content = $html_content . "<p>" . Response_html_escape($message) . "</p>\n";
    }

    $html_content = $html_content . "<hr>\n<p><em>Cannoli/1.0</em></p>\n";
    $html_content = $html_content . "</body>\n</html>\n";

    return Response_html($code, $html_content);
}

# Not found (404)
func Response_not_found() hash {
    return Response_error_page(404, "The requested resource was not found.");
}

# Method not allowed (405)
func Response_method_not_allowed(str $allowed) hash {
    my hash %res = Response_error_page(405, "Method not allowed.");
    Response_header(%res, "Allow", $allowed);
    return %res;
}

# Internal server error (500)
func Response_internal_error(str $message) hash {
    return Response_error_page(500, $message);
}

# Payload too large (413)
func Response_payload_too_large(int $max_size) hash {
    my str $msg = "Request body exceeds maximum allowed size of " . $max_size . " bytes.";
    return Response_error_page(413, $msg);
}

# Request header fields too large (431)
func Response_header_too_large(int $max_size) hash {
    my str $msg = "Request headers exceed maximum allowed size of " . $max_size . " bytes.";
    return Response_error_page(431, $msg);
}

# Set multiple headers from a hash
func Response_headers(hash %res, hash %hdrs) void {
    my array @names = keys(%hdrs);
    my int $i = 0;
    while ($i < scalar(@names)) {
        my str $name = @names[$i];
        Response_header(%res, $name, $hdrs{$name});
        $i = $i + 1;
    }
}

# Get all response headers as a hash reference
func Response_get_headers(hash %res) scalar {
    return $res{"headers"};
}

# Check if a response header is set
func Response_has_header(hash %res, str $name) int {
    my scalar $headers = $res{"headers"};
    return exists(%{$headers}, $name);
}

# Get a response header value
func Response_get_header(hash %res, str $name) str {
    my scalar $headers = $res{"headers"};
    if (exists(%{$headers}, $name)) {
        return $headers->{$name};
    }
    return "";
}

# Remove a response header (sets to empty string)
# Note: To fully remove, rebuild headers hash without the key
func Response_remove_header(hash %res, str $name) void {
    my scalar $headers = $res{"headers"};
    # Since Strada doesn't have delete, we set to empty
    # The build function will skip empty headers
    $headers->{$name} = "";
}

# Convenience: Text response with custom headers
func Response_text_with_headers(int $status, str $content, hash %hdrs) hash {
    my hash %res = Response_text($status, $content);
    Response_headers(%res, %hdrs);
    return %res;
}

# Convenience: HTML response with custom headers
func Response_html_with_headers(int $status, str $content, hash %hdrs) hash {
    my hash %res = Response_html($status, $content);
    Response_headers(%res, %hdrs);
    return %res;
}

# Convenience: JSON response with custom headers
func Response_json_with_headers(int $status, str $content, hash %hdrs) hash {
    my hash %res = Response_json($status, $content);
    Response_headers(%res, %hdrs);
    return %res;
}

# Set Cache-Control header
func Response_cache(hash %res, int $max_age) void {
    if ($max_age <= 0) {
        Response_header(%res, "Cache-Control", "no-cache, no-store, must-revalidate");
        Response_header(%res, "Pragma", "no-cache");
        Response_header(%res, "Expires", "0");
    } else {
        Response_header(%res, "Cache-Control", "public, max-age=" . $max_age);
    }
}

# Set CORS headers for cross-origin requests
func Response_cors(hash %res, str $origin) void {
    if (length($origin) == 0) {
        $origin = "*";
    }
    Response_header(%res, "Access-Control-Allow-Origin", $origin);
    Response_header(%res, "Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
    Response_header(%res, "Access-Control-Allow-Headers", "Content-Type, Authorization");
}

# Set cookie header
func Response_set_cookie(hash %res, str $name, str $value, str $options) void {
    my str $cookie = $name . "=" . $value;
    if (length($options) > 0) {
        $cookie = $cookie . "; " . $options;
    }
    Response_header(%res, "Set-Cookie", $cookie);
}

# ============================================================
# Chunked Transfer Encoding
# ============================================================

# Integer modulo operation (a mod b)
func Response_mod(int $a, int $b) int {
    my num $div = $a / $b;
    my int $floored = math::floor($div);
    return $a - ($floored * $b);
}

# Convert integer to lowercase hexadecimal string
func Response_to_hex(int $value) str {
    if ($value == 0) {
        return "0";
    }

    my str $result = "";
    my int $n = $value;

    while ($n > 0) {
        my int $digit = Response_mod($n, 16);
        my str $ch = "";
        if ($digit < 10) {
            $ch = chr(48 + $digit);  # 0-9
        } else {
            $ch = chr(97 + $digit - 10);  # a-f
        }
        $result = $ch . $result;
        my num $div = $n / 16;
        $n = math::floor($div);
    }

    return $result;
}

# Build only the HTTP headers (status line + headers + blank line)
# Used for chunked responses where body is sent separately
func Response_build_headers(hash %res) str {
    my int $status_code = $res{"status"};
    my str $status_msg = Response_status_message($status_code);
    my scalar $headers = $res{"headers"};

    # Build status line
    my str $response = "HTTP/1.1 " . $status_code . " " . $status_msg . "\r\n";

    # Add headers (skip empty values and Content-Length for chunked)
    my array @header_names = keys(%{$headers});
    my int $i = 0;
    while ($i < scalar(@header_names)) {
        my str $name = @header_names[$i];
        my str $value = $headers->{$name};
        # Skip Content-Length for chunked (it's not allowed)
        if (length($value) > 0 && $name ne "Content-Length") {
            $response = $response . $name . ": " . $value . "\r\n";
        }
        $i = $i + 1;
    }

    # End headers with blank line
    $response = $response . "\r\n";

    return $response;
}

# Initialize chunked response and send headers
# Sets Transfer-Encoding: chunked and sends headers immediately
# Returns the modified response hash
func Response_chunked_start(hash %res, int $fd) hash {
    # Set chunked encoding header
    Response_header(%res, "Transfer-Encoding", "chunked");

    # Remove Content-Length if set (not allowed with chunked)
    Response_remove_header(%res, "Content-Length");

    # Store the fd for later chunk writes
    $res{"_fd"} = $fd;
    $res{"_chunked"} = 1;

    # Send headers immediately
    my str $headers = Response_build_headers(%res);
    sys::write_fd($fd, $headers);

    $res{"sent"} = 1;  # Mark as sent (headers sent)

    return %res;
}

# Send a data chunk
# Format: hex_size\r\n data\r\n
# Returns bytes written
func Response_send_chunk(hash %res, str $data) int {
    if (length($data) == 0) {
        return 0;  # Skip empty chunks
    }

    my int $fd = $res{"_fd"};
    if ($fd <= 0) {
        return -1;  # No fd set
    }

    # Format: {hex_length}\r\n{data}\r\n
    my str $hex_len = Response_to_hex(length($data));
    my str $chunk = $hex_len . "\r\n" . $data . "\r\n";

    return sys::write_fd($fd, $chunk);
}

# Send the final (terminating) chunk
# Format: 0\r\n\r\n
# Returns bytes written
func Response_end_chunked(hash %res) int {
    my int $fd = $res{"_fd"};
    if ($fd <= 0) {
        return -1;
    }

    # Terminating chunk: 0 length followed by empty trailer
    return sys::write_fd($fd, "0\r\n\r\n");
}

# Create an empty response to signal "already handled"
# Used when handler sends response directly (e.g., chunked)
func Response_empty() hash {
    my hash %res = ();
    $res{"status"} = 0;
    $res{"headers"} = {};
    $res{"body"} = "";
    $res{"sent"} = 1;  # Already sent
    $res{"_chunked"} = 1;
    return %res;
}

# Check if response is chunked
func Response_is_chunked(hash %res) int {
    if (exists(%res, "_chunked")) {
        return $res{"_chunked"};
    }
    return 0;
}

# ============================================================
# Response Compression
# ============================================================

# Compress response body using gzip
# Returns 1 if compressed, 0 if not
func Response_compress_gzip(hash %res) int {
    my str $body = $res{"body"};

    # Don't compress if body is empty or too small
    if (length($body) < 1024) {
        return 0;
    }

    # Don't compress if already compressed
    if (Response_has_header(%res, "Content-Encoding")) {
        return 0;
    }

    # Check content type - only compress text-based
    my str $content_type = Response_get_header(%res, "Content-Type");
    if (compress_should_compress($content_type, $body) == 0) {
        return 0;
    }

    # Compress the body
    my str $compressed = compress_gzip($body);

    # Only use compressed if it's actually smaller
    if (length($compressed) < length($body)) {
        $res{"body"} = $compressed;
        Response_header(%res, "Content-Encoding", "gzip");
        Response_header(%res, "Vary", "Accept-Encoding");
        return 1;
    }

    return 0;
}

# Compress response if client accepts gzip encoding
func Response_auto_compress(hash %res, str $accept_encoding) int {
    # Check if client accepts gzip
    if (index($accept_encoding, "gzip") < 0) {
        return 0;
    }

    return Response_compress_gzip(%res);
}

# Check if response is compressed
func Response_is_compressed(hash %res) int {
    my str $encoding = Response_get_header(%res, "Content-Encoding");
    if (length($encoding) > 0) {
        return 1;
    }
    return 0;
}
