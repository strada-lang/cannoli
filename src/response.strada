/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Response;


# cannoli/src/response.strada - HTTP Response building
#
# Build and send HTTP responses

# HTTP status code messages
func Cannoli_Response_status_message(int $code) str {
    if ($code == 200) { return "OK"; }
    if ($code == 201) { return "Created"; }
    if ($code == 204) { return "No Content"; }
    if ($code == 301) { return "Moved Permanently"; }
    if ($code == 302) { return "Found"; }
    if ($code == 304) { return "Not Modified"; }
    if ($code == 400) { return "Bad Request"; }
    if ($code == 401) { return "Unauthorized"; }
    if ($code == 403) { return "Forbidden"; }
    if ($code == 404) { return "Not Found"; }
    if ($code == 405) { return "Method Not Allowed"; }
    if ($code == 413) { return "Payload Too Large"; }
    if ($code == 431) { return "Request Header Fields Too Large"; }
    if ($code == 500) { return "Internal Server Error"; }
    if ($code == 502) { return "Bad Gateway"; }
    if ($code == 503) { return "Service Unavailable"; }
    return "Unknown";
}

# Create a new response object
func Cannoli_Response_new() hash {
    my hash %res = ();

    $res{"status"} = 200;
    $res{"headers"} = {};
    $res{"body"} = "";
    $res{"sent"} = 0;

    # Set default headers
    my scalar $headers = $res{"headers"};
    $headers->{"Content-Type"} = "text/html; charset=utf-8";
    $headers->{"Server"} = "Cannoli/1.0";
    $headers->{"Connection"} = "close";

    return %res;
}

# Set status code
func Cannoli_Response_status(hash %res, int $code) void {
    $res{"status"} = $code;
}

# Set a header
func Cannoli_Response_header(hash %res, str $name, str $value) void {
    my scalar $headers = $res{"headers"};
    $headers->{$name} = $value;
}

# Set content type
func Cannoli_Response_content_type(hash %res, str $type) void {
    ::header(%res, "Content-Type", $type);
}

# Set body content
func Cannoli_Response_body(hash %res, str $content) void {
    $res{"body"} = $content;
}

# Append to body
func Cannoli_Response_write(hash %res, str $content) void {
    $res{"body"} = $res{"body"} . $content;
}

# Build the complete HTTP response string
func Cannoli_Response_build(hash %res) str {
    my int $status_code = $res{"status"};
    my str $status_msg = ::status_message($status_code);
    my str $body_content = $res{"body"};
    my scalar $headers = $res{"headers"};

    # Set content length
    $headers->{"Content-Length"} = "" . length($body_content);

    # Build status line
    my str $response = "HTTP/1.1 " . $status_code . " " . $status_msg . "\r\n";

    # Add Cannoli::Response::headers(skip empty values)
    my array @header_names = keys(%{$headers});
    my int $i = 0;
    while ($i < scalar(@header_names)) {
        my str $name = $header_names[$i];
        my str $value = $headers->{$name};
        if (length($value) > 0) {
            $response = $response . $name . ": " . $value . "\r\n";
        }
        $i = $i + 1;
    }

    # End headers, add body
    $response = $response . "\r\n" . $body_content;

    return $response;
}

# Send response to a file descriptor
func Cannoli_Response_send_to(hash %res, int $fd) int {
    if ($res{"sent"} == 1) {
        return 0;
    }

    my str $data = ::build(%res);
    my int $written = sys::write_fd($fd, $data);
    $res{"sent"} = 1;

    return $written;
}

# Convenience: Create and return a simple text response
func Cannoli_Response_text(int $status, str $content) hash {
    my hash %res = ::new();
    ::status(%res, $status);
    ::content_type(%res, "text/plain; charset=utf-8");
    ::body(%res, $content);
    return %res;
}

# Convenience: Create and return an HTML response
func Cannoli_Response_html(int $status, str $content) hash {
    my hash %res = ::new();
    ::status(%res, $status);
    ::content_type(%res, "text/html; charset=utf-8");
    ::body(%res, $content);
    return %res;
}

# Convenience: Create and return a JSON response
func Cannoli_Response_json(int $status, str $content) hash {
    my hash %res = ::new();
    ::status(%res, $status);
    ::content_type(%res, "application/json");
    ::body(%res, $content);
    return %res;
}

# Convenience: Redirect response
func Cannoli_Response_redirect(str $url, int $permanent) hash {
    my hash %res = ::new();

    if ($permanent == 1) {
        ::status(%res, 301);
    } else {
        ::status(%res, 302);
    }

    ::header(%res, "Location", $url);
    ::body(%res, "");
    return %res;
}

# HTML escape helper
func Cannoli_Response_html_escape(str $s) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        if ($ch eq "<") {
            $result = $result . "&lt;";
        } elsif ($ch eq ">") {
            $result = $result . "&gt;";
        } elsif ($ch eq "&") {
            $result = $result . "&amp;";
        } elsif ($ch eq "\"") {
            $result = $result . "&quot;";
        } else {
            $result = $result . $ch;
        }

        $i = $i + 1;
    }

    return $result;
}

# Error page responses
func Cannoli_Response_error_page(int $code, str $message) hash {
    my str $status_msg = ::status_message($code);
    my str $html_content = "<!DOCTYPE html>\n";
    $html_content = $html_content . "<html>\n<head>\n";
    $html_content = $html_content . "<title>" . $code . " " . $status_msg . "</title>\n";
    $html_content = $html_content . "<style>\n";
    $html_content = $html_content . "body { font-family: sans-serif; text-align: center; padding: 50px; }\n";
    $html_content = $html_content . "h1 { color: #333; }\n";
    $html_content = $html_content . "p { color: #666; }\n";
    $html_content = $html_content . ".code { font-size: 72px; color: #999; }\n";
    $html_content = $html_content . "</style>\n</head>\n<body>\n";
    $html_content = $html_content . "<div class=\"code\">" . $code . "</div>\n";
    $html_content = $html_content . "<h1>" . $status_msg . "</h1>\n";

    if (length($message) > 0) {
        $html_content = $html_content . "<p>" . ::html_escape($message) . "</p>\n";
    }

    $html_content = $html_content . "<hr>\n<p><em>Cannoli/1.0</em></p>\n";
    $html_content = $html_content . "</body>\n</html>\n";

    return ::html($code, $html_content);
}

# Not found (404)
func Cannoli_Response_not_found() hash {
    return ::error_page(404, "The requested resource was not found.");
}

# Method not allowed (405)
func Cannoli_Response_method_not_allowed(str $allowed) hash {
    my hash %res = ::error_page(405, "Method not allowed.");
    ::header(%res, "Allow", $allowed);
    return %res;
}

# Internal server error (500)
func Cannoli_Response_internal_error(str $message) hash {
    return ::error_page(500, $message);
}

# Payload too large (413)
func Cannoli_Response_payload_too_large(int $max_size) hash {
    my str $msg = "Request body exceeds maximum allowed size of " . $max_size . " bytes.";
    return ::error_page(413, $msg);
}

# Request header fields too large (431)
func Cannoli_Response_header_too_large(int $max_size) hash {
    my str $msg = "Request headers exceed maximum allowed size of " . $max_size . " bytes.";
    return ::error_page(431, $msg);
}

# Set multiple headers from a hash
func Cannoli_Response_headers(hash %res, hash %hdrs) void {
    my array @names = keys(%hdrs);
    my int $i = 0;
    while ($i < scalar(@names)) {
        my str $name = $names[$i];
        ::header(%res, $name, $hdrs{$name});
        $i = $i + 1;
    }
}

# Get all response headers as a hash reference
func Cannoli_Response_get_headers(hash %res) scalar {
    return $res{"headers"};
}

# Check if a response header is set
func Cannoli_Response_has_header(hash %res, str $name) int {
    my scalar $headers = $res{"headers"};
    return exists(%{$headers}, $name);
}

# Get a response header value
func Cannoli_Response_get_header(hash %res, str $name) str {
    my scalar $headers = $res{"headers"};
    if (exists(%{$headers}, $name)) {
        return $headers->{$name};
    }
    return "";
}

# Remove a response Cannoli::Response::header(sets to empty string)
# Note: To fully remove, rebuild headers hash without the key
func Cannoli_Response_remove_header(hash %res, str $name) void {
    my scalar $headers = $res{"headers"};
    # Since Strada doesn't have delete, we set to empty
    # The build function will skip empty headers
    $headers->{$name} = "";
}

# Convenience: Text response with custom headers
func Cannoli_Response_text_with_headers(int $status, str $content, hash %hdrs) hash {
    my hash %res = ::text($status, $content);
    ::headers(%res, %hdrs);
    return %res;
}

# Convenience: HTML response with custom headers
func Cannoli_Response_html_with_headers(int $status, str $content, hash %hdrs) hash {
    my hash %res = ::html($status, $content);
    ::headers(%res, %hdrs);
    return %res;
}

# Convenience: JSON response with custom headers
func Cannoli_Response_json_with_headers(int $status, str $content, hash %hdrs) hash {
    my hash %res = ::json($status, $content);
    ::headers(%res, %hdrs);
    return %res;
}

# Set Cache-Control header
func Cannoli_Response_cache(hash %res, int $max_age) void {
    if ($max_age <= 0) {
        ::header(%res, "Cache-Control", "no-cache, no-store, must-revalidate");
        ::header(%res, "Pragma", "no-cache");
        ::header(%res, "Expires", "0");
    } else {
        ::header(%res, "Cache-Control", "public, max-age=" . $max_age);
    }
}

# Set CORS headers for cross-origin requests
func Cannoli_Response_cors(hash %res, str $origin) void {
    if (length($origin) == 0) {
        $origin = "*";
    }
    ::header(%res, "Access-Control-Allow-Origin", $origin);
    ::header(%res, "Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
    ::header(%res, "Access-Control-Allow-Headers", "Content-Type, Authorization");
}

# Set cookie header
func Cannoli_Response_set_cookie(hash %res, str $name, str $value, str $options) void {
    my str $cookie = $name . "=" . $value;
    if (length($options) > 0) {
        $cookie = $cookie . "; " . $options;
    }
    ::header(%res, "Set-Cookie", $cookie);
}

# ============================================================
# Chunked Transfer Encoding
# ============================================================

# Integer modulo operation (a mod b)
func Cannoli_Response_mod(int $a, int $b) int {
    my num $div = $a / $b;
    my int $floored = math::floor($div);
    return $a - ($floored * $b);
}

# Convert integer to lowercase hexadecimal string
func Cannoli_Response_to_hex(int $value) str {
    if ($value == 0) {
        return "0";
    }

    my str $result = "";
    my int $n = $value;

    while ($n > 0) {
        my int $digit = ::mod($n, 16);
        my str $ch = "";
        if ($digit < 10) {
            $ch = chr(48 + $digit);  # 0-9
        } else {
            $ch = chr(97 + $digit - 10);  # a-f
        }
        $result = $ch . $result;
        my num $div = $n / 16;
        $n = math::floor($div);
    }

    return $result;
}

# Build only the HTTP Cannoli::Response::headers(status line + headers + blank line)
# Used for chunked responses where body is sent separately
func Cannoli_Response_build_headers(hash %res) str {
    my int $status_code = $res{"status"};
    my str $status_msg = ::status_message($status_code);
    my scalar $headers = $res{"headers"};

    # Build status line
    my str $response = "HTTP/1.1 " . $status_code . " " . $status_msg . "\r\n";

    # Add Cannoli::Response::headers(skip empty values and Content-Length for chunked)
    my array @header_names = keys(%{$headers});
    my int $i = 0;
    while ($i < scalar(@header_names)) {
        my str $name = $header_names[$i];
        my str $value = $headers->{$name};
        # Skip Content-Length for chunked (it's not allowed)
        if (length($value) > 0 && $name ne "Content-Length") {
            $response = $response . $name . ": " . $value . "\r\n";
        }
        $i = $i + 1;
    }

    # End headers with blank line
    $response = $response . "\r\n";

    return $response;
}

# Initialize chunked response and send headers
# Sets Transfer-Encoding: chunked and sends headers immediately
# Returns the modified response hash
func Cannoli_Response_chunked_start(hash %res, int $fd) hash {
    # Set chunked encoding header
    ::header(%res, "Transfer-Encoding", "chunked");

    # Remove Content-Length if set (not allowed with chunked)
    ::remove_header(%res, "Content-Length");

    # Store the fd for later chunk writes
    $res{"_fd"} = $fd;
    $res{"_chunked"} = 1;

    # Send headers immediately
    my str $headers = ::build_headers(%res);
    sys::write_fd($fd, $headers);

    $res{"sent"} = 1;  # Mark as sent (headers sent)

    return %res;
}

# Send a data chunk
# Format: hex_size\r\n data\r\n
# Returns bytes written
func Cannoli_Response_send_chunk(hash %res, str $data) int {
    if (length($data) == 0) {
        return 0;  # Skip empty chunks
    }

    my int $fd = $res{"_fd"};
    if ($fd <= 0) {
        return -1;  # No fd set
    }

    # Format: {hex_length}\r\n{data}\r\n
    my str $hex_len = ::to_hex(length($data));
    my str $chunk = $hex_len . "\r\n" . $data . "\r\n";

    return sys::write_fd($fd, $chunk);
}

# Send the final (terminating) chunk
# Format: 0\r\n\r\n
# Returns bytes written
func Cannoli_Response_end_chunked(hash %res) int {
    my int $fd = $res{"_fd"};
    if ($fd <= 0) {
        return -1;
    }

    # Terminating chunk: 0 length followed by empty trailer
    return sys::write_fd($fd, "0\r\n\r\n");
}

# Create an empty response to signal "already handled"
# Used when handler sends response directly (e.g., chunked)
func Cannoli_Response_empty() hash {
    my hash %res = ();
    $res{"status"} = 0;
    $res{"headers"} = {};
    $res{"body"} = "";
    $res{"sent"} = 1;  # Already sent
    $res{"_chunked"} = 1;
    return %res;
}

# Create an empty response with status for logging
func Cannoli_Response_sent(int $status = 200) hash {
    my hash %res = ();
    $res{"status"} = $status;
    $res{"headers"} = {};
    $res{"body"} = "";
    $res{"sent"} = 1;
    $res{"_chunked"} = 1;
    return %res;
}

# Check if response is chunked
func Cannoli_Response_is_chunked(hash %res) int {
    if (exists(%res, "_chunked")) {
        return $res{"_chunked"};
    }
    return 0;
}

# ============================================================
# Response Compression
# ============================================================

# Compress response body using gzip
# Returns 1 if compressed, 0 if not
func Cannoli_Response_compress_gzip(hash %res) int {
    my str $body = $res{"body"};

    # Don't compress if body is empty or too small
    if (length($body) < 1024) {
        return 0;
    }

    # Don't compress if already compressed
    if (::has_header(%res, "Content-Encoding")) {
        return 0;
    }

    # Check content type - only compress text-based
    my str $content_type = ::get_header(%res, "Content-Type");
    if (compress::should_compress($content_type, $body) == 0) {
        return 0;
    }

    # Compress the body
    my str $compressed = compress::gzip($body);

    # Only use compressed if it's actually smaller
    if (length($compressed) < length($body)) {
        $res{"body"} = $compressed;
        ::header(%res, "Content-Encoding", "gzip");
        ::header(%res, "Vary", "Accept-Encoding");
        return 1;
    }

    return 0;
}

# Compress response if client accepts gzip encoding
func Cannoli_Response_auto_compress(hash %res, str $accept_encoding) int {
    # Check if client accepts gzip
    if (index($accept_encoding, "gzip") < 0) {
        return 0;
    }

    return ::compress_gzip(%res);
}

# Check if response is compressed
func Cannoli_Response_is_compressed(hash %res) int {
    my str $encoding = ::get_header(%res, "Content-Encoding");
    if (length($encoding) > 0) {
        return 1;
    }
    return 0;
}
