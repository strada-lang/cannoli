/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# t/test_router.strada - Test URL router

func test_exact_match() int {
    say("Testing exact path matching...");

    my scalar $router = Router_new();

    my int $called = 0;
    Router_get($router, "/hello", func (hash %req) {
        $called = 1;
        return Response_text(200, "Hello");
    });

    # Create a mock request
    my hash %req = ();
    $req{"method"} = "GET";
    $req{"path"} = "/hello";

    my scalar $match = Router_match($router, %req);

    if (!defined($match)) {
        say("  FAIL: route should match /hello");
        return 1;
    }

    say("  PASS");
    return 0;
}

func test_no_match() int {
    say("Testing no match...");

    my scalar $router = Router_new();

    Router_get($router, "/hello", func (hash %req) {
        return Response_text(200, "Hello");
    });

    my hash %req = ();
    $req{"method"} = "GET";
    $req{"path"} = "/world";

    my scalar $match = Router_match($router, %req);

    if (defined($match)) {
        say("  FAIL: /world should not match /hello");
        return 1;
    }

    say("  PASS");
    return 0;
}

func test_method_match() int {
    say("Testing method matching...");

    my scalar $router = Router_new();

    Router_get($router, "/resource", func (hash %req) {
        return Response_text(200, "GET");
    });

    Router_post($router, "/resource", func (hash %req) {
        return Response_text(200, "POST");
    });

    # GET should match
    my hash %get_req = ();
    $get_req{"method"} = "GET";
    $get_req{"path"} = "/resource";

    my scalar $get_match = Router_match($router, %get_req);
    if (!defined($get_match)) {
        say("  FAIL: GET /resource should match");
        return 1;
    }

    # POST should match
    my hash %post_req = ();
    $post_req{"method"} = "POST";
    $post_req{"path"} = "/resource";

    my scalar $post_match = Router_match($router, %post_req);
    if (!defined($post_match)) {
        say("  FAIL: POST /resource should match");
        return 1;
    }

    # DELETE should not match
    my hash %delete_req = ();
    $delete_req{"method"} = "DELETE";
    $delete_req{"path"} = "/resource";

    my scalar $delete_match = Router_match($router, %delete_req);
    if (defined($delete_match)) {
        say("  FAIL: DELETE /resource should not match");
        return 1;
    }

    say("  PASS");
    return 0;
}

func test_regex_match() int {
    say("Testing regex matching...");

    my scalar $router = Router_new();

    Router_get($router, "/user/([0-9]+)", func (hash %req) {
        return Response_text(200, "User");
    });

    # Should match numeric ID
    my hash %req1 = ();
    $req1{"method"} = "GET";
    $req1{"path"} = "/user/123";

    my scalar $match1 = Router_match($router, %req1);
    if (!defined($match1)) {
        say("  FAIL: /user/123 should match");
        return 1;
    }

    # Should not match non-numeric
    my hash %req2 = ();
    $req2{"method"} = "GET";
    $req2{"path"} = "/user/abc";

    my scalar $match2 = Router_match($router, %req2);
    if (defined($match2)) {
        say("  FAIL: /user/abc should not match [0-9]+");
        return 1;
    }

    say("  PASS");
    return 0;
}

func test_any_method() int {
    say("Testing any method matching...");

    my scalar $router = Router_new();

    Router_any($router, "/anything", func (hash %req) {
        return Response_text(200, "OK");
    });

    my array @methods = ("GET", "POST", "PUT", "DELETE");
    my int $i = 0;

    while ($i < scalar(@methods)) {
        my hash %req = ();
        $req{"method"} = @methods[$i];
        $req{"path"} = "/anything";

        my scalar $match = Router_match($router, %req);
        if (!defined($match)) {
            say("  FAIL: " . @methods[$i] . " /anything should match");
            return 1;
        }

        $i = $i + 1;
    }

    say("  PASS");
    return 0;
}

func test_contains_regex_chars() int {
    say("Testing regex character detection...");

    if (Router_contains_regex_chars("/simple") != 0) {
        say("  FAIL: /simple should not be detected as regex");
        return 1;
    }

    if (Router_contains_regex_chars("/user/([0-9]+)") != 1) {
        say("  FAIL: /user/([0-9]+) should be detected as regex");
        return 1;
    }

    if (Router_contains_regex_chars("/files/*") != 1) {
        say("  FAIL: /files/* should be detected as regex");
        return 1;
    }

    say("  PASS");
    return 0;
}

func main() int {
    say("=== Cannoli Router Tests ===");
    say("");

    my int $failures = 0;

    $failures = $failures + test_exact_match();
    $failures = $failures + test_no_match();
    $failures = $failures + test_method_match();
    $failures = $failures + test_regex_match();
    $failures = $failures + test_any_method();
    $failures = $failures + test_contains_regex_chars();

    say("");
    if ($failures == 0) {
        say("All router tests passed!");
        return 0;
    } else {
        say("" . $failures . " test(s) failed!");
        return 1;
    }
}
