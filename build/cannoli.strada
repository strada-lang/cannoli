/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Config;


# cannoli/src/config.strada - Configuration file parser and settings
#
# Supports simple key=value configuration with sections [section]
# Example config:
#   [server]
#   port = 8080
#   workers = 5
#   [app]
#   document_root = /var/www

# Default configuration values
func Cannoli_Config_defaults() hash {
    my hash %config = ();

    # Server settings
    $config{"server.host"} = "0.0.0.0";
    $config{"server.port"} = "8080";
    $config{"server.workers"} = "5";
    $config{"server.max_requests"} = "1000";
    $config{"server.timeout"} = "30";
    $config{"server.backlog"} = "128";
    $config{"server.max_body_size"} = "10485760";    # 10MB default
    $config{"server.max_header_size"} = "8192";      # 8KB default

    # FastCGI settings
    $config{"fastcgi.enabled"} = "0";
    $config{"fastcgi.socket"} = "/tmp/cannoli.sock";

    # Logging
    $config{"log.level"} = "info";
    $config{"log.error_file"} = "";    # Path to error log file
    $config{"log.access_file"} = "";   # Path to access log file

    # Application
    $config{"app.document_root"} = ".";
    $config{"app.index"} = "index.html";
    $config{"app.library"} = "";  # Path to dynamic library for handlers (comma-separated for multiple)

    # SSL/HTTPS settings
    $config{"ssl.enabled"} = "0";
    $config{"ssl.port"} = "443";
    $config{"ssl.cert"} = "";      # Path to certificate file
    $config{"ssl.key"} = "";       # Path to private key file

    return %config;
}

# Parse a configuration file
func Cannoli_Config_parse_file(str $filename) hash {
    my hash %config = ::defaults();

    if (!sys::is_file($filename)) {
        return %config;
    }

    my str $content = slurp($filename);
    my array @lines = split($content, "\n");

    my str $section = "";
    my int $i = 0;
    my int $len = scalar(@lines);

    while ($i < $len) {
        my str $line = $lines[$i];
        $line = ::trim($line);

        # Skip empty lines and comments
        if (length($line) == 0) {
            $i = $i + 1;
            next;
        }
        if (substr($line, 0, 1) eq "#") {
            $i = $i + 1;
            next;
        }

        # Section header [section]
        if (substr($line, 0, 1) eq "[") {
            my int $end = index($line, "]");
            if ($end > 1) {
                $section = substr($line, 1, $end - 1);
            }
            $i = $i + 1;
            next;
        }

        # Key = value
        my int $eq_pos = index($line, "=");
        if ($eq_pos > 0) {
            my str $key = ::trim(substr($line, 0, $eq_pos));
            my str $value = ::trim(substr($line, $eq_pos + 1, length($line) - $eq_pos - 1));

            # Remove quotes if present
            if (length($value) >= 2) {
                my str $first_ch = substr($value, 0, 1);
                my str $last_ch = substr($value, length($value) - 1, 1);
                if (($first_ch eq "\"" && $last_ch eq "\"") || ($first_ch eq "'" && $last_ch eq "'")) {
                    $value = substr($value, 1, length($value) - 2);
                }
            }

            # Build full key with section prefix
            my str $full_key = $key;
            if (length($section) > 0) {
                $full_key = $section . "." . $key;
            }

            $config{$full_key} = $value;
        }

        $i = $i + 1;
    }

    return %config;
}

# Trim whitespace from string
func Cannoli_Config_trim(str $s) str {
    my int $start = 0;
    my int $end = length($s);

    # Find first non-whitespace
    while ($start < $end) {
        my str $ch = substr($s, $start, 1);
        if ($ch ne " " && $ch ne "\t" && $ch ne "\r" && $ch ne "\n") {
            last;
        }
        $start = $start + 1;
    }

    # Find last non-whitespace
    while ($end > $start) {
        my str $ch = substr($s, $end - 1, 1);
        if ($ch ne " " && $ch ne "\t" && $ch ne "\r" && $ch ne "\n") {
            last;
        }
        $end = $end - 1;
    }

    if ($start >= $end) {
        return "";
    }

    return substr($s, $start, $end - $start);
}

# Get a string configuration value with fallback
func Cannoli_Config_get_str(hash %config, str $key, str $fallback) str {
    if (exists(%config, $key)) {
        return $config{$key};
    }
    return $fallback;
}

# Get an integer configuration value with fallback
func Cannoli_Config_get_int(hash %config, str $key, int $fallback) int {
    if (exists(%config, $key)) {
        my str $val = $config{$key};
        return $val + 0;
    }
    return $fallback;
}

# Get a boolean configuration value (0/1, true/false, yes/no)
func Cannoli_Config_get_bool(hash %config, str $key, int $fallback) int {
    if (!exists(%config, $key)) {
        return $fallback;
    }

    my str $val = lc($config{$key});
    if ($val eq "1" || $val eq "true" || $val eq "yes" || $val eq "on") {
        return 1;
    }
    if ($val eq "0" || $val eq "false" || $val eq "no" || $val eq "off") {
        return 0;
    }
    return $fallback;
}

# Set a configuration value
func Cannoli_Config_set(hash %config, str $key, str $value) void {
    $config{$key} = $value;
}

# Merge command line args into config
func Cannoli_Config_merge_args(hash %config, int $argc, array @argv) hash {
    my int $i = 1;

    while ($i < $argc) {
        my str $arg = $argv[$i];

        if ($arg eq "-p" || $arg eq "--port") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"server.port"} = $argv[$i];
            }
        } elsif ($arg eq "-h" || $arg eq "--host") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"server.host"} = $argv[$i];
            }
        } elsif ($arg eq "-w" || $arg eq "--workers") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"server.workers"} = $argv[$i];
            }
        } elsif ($arg eq "--fastcgi") {
            $config{"fastcgi.enabled"} = "1";
        } elsif ($arg eq "--socket") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"fastcgi.socket"} = $argv[$i];
                $config{"fastcgi.enabled"} = "1";
            }
        }

        $i = $i + 1;
    }

    return %config;
}

# Extract library routes from config
# Looks for keys like "library./api" = "api.so"
# Returns array reference of hashes with {prefix, path}
func Cannoli_Config_get_library_routes(hash %config) scalar {
    my scalar $routes = [];
    my array @k = keys(%config);
    my int $i = 0;

    while ($i < scalar(@k)) {
        my str $key = $k[$i];
        # Look for keys starting with "library."
        if (length($key) > 8 && substr($key, 0, 8) eq "library.") {
            my str $prefix = substr($key, 8, length($key) - 8);
            my str $lib_path = $config{$key};

            my hash %route = ();
            $route{"prefix"} = $prefix;
            $route{"path"} = $lib_path;
            push($routes, \%route);
        }
        $i = $i + 1;
    }

    # Sort routes by prefix length (longest first) for most specific matching
    # Simple bubble sort since we expect few routes
    my int $n = scalar(@{$routes});
    my int $j = 0;
    while ($j < $n - 1) {
        my int $k = 0;
        while ($k < $n - $j - 1) {
            my scalar $r1 = $routes->[$k];
            my scalar $r2 = $routes->[$k + 1];
            my int $len1 = length($r1->{"prefix"});
            my int $len2 = length($r2->{"prefix"});
            if ($len1 < $len2) {
                # Swap
                $routes->[$k] = $r2;
                $routes->[$k + 1] = $r1;
            }
            $k = $k + 1;
        }
        $j = $j + 1;
    }

    return $routes;
}

# Print configuration (for debugging)
func Cannoli_Config_dump(hash %config) void {
    say("=== Configuration ===");
    my array @k = keys(%config);
    my int $i = 0;
    while ($i < scalar(@k)) {
        my str $key = $k[$i];
        say("  " . $key . " = " . $config{$key});
        $i = $i + 1;
    }
    say("");
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Mime;


# cannoli/src/mime.strada - MIME type detection (minimal)

func Cannoli_Mime_type(str $path) str {
    my int $len = length($path);
    my int $i = $len - 1;
    my int $dot_pos = -1;
    while ($i >= 0) {
        my str $ch = substr($path, $i, 1);
        if ($ch eq ".") { $dot_pos = $i; last; }
        if ($ch eq "/") { last; }
        $i = $i - 1;
    }
    if ($dot_pos < 0) { return "application/octet-stream"; }
    my str $ext = lc(substr($path, $dot_pos, $len - $dot_pos));
    if ($ext eq ".html" || $ext eq ".htm") { return "text/html; charset=utf-8"; }
    if ($ext eq ".css") { return "text/css; charset=utf-8"; }
    if ($ext eq ".js") { return "text/javascript; charset=utf-8"; }
    if ($ext eq ".json") { return "application/json"; }
    if ($ext eq ".txt") { return "text/plain; charset=utf-8"; }
    if ($ext eq ".png") { return "image/png"; }
    if ($ext eq ".jpg" || $ext eq ".jpeg") { return "image/jpeg"; }
    if ($ext eq ".gif") { return "image/gif"; }
    if ($ext eq ".svg") { return "image/svg+xml"; }
    if ($ext eq ".ico") { return "image/x-icon"; }
    if ($ext eq ".pdf") { return "application/pdf"; }
    return "application/octet-stream";
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Session;


# cannoli/src/session.strada - Session management
#
# File-based session storage with cookie tracking.
# Sessions are stored in /tmp/cannoli_sessions/ directory.
#
# Usage:
#   my scalar $session = Cannoli::Session::new();
#   Cannoli::Session::set($session, "user_id", "42");
#   Cannoli::Session::save($session);
#
#   my scalar $loaded = Cannoli::Session::load($session_id);
#   my str $user = Cannoli::Session::get($loaded, "user_id");

# Session directory
my str $g_session_dir = "/tmp/cannoli_sessions";
my str $g_session_cookie = "cannoli_session";
my int $g_session_ttl = 3600;  # 1 hour default TTL

# Initialize session system (creates directory if needed)
func Cannoli_Session_init() void {
    if (sys::is_dir($g_session_dir) == 0) {
        sys::mkdir($g_session_dir);
    }
}

# Configure session settings
func Cannoli_Session_configure(str $dir, str $cookie_name, int $ttl) void {
    if (length($dir) > 0) {
        $g_session_dir = $dir;
    }
    if (length($cookie_name) > 0) {
        $g_session_cookie = $cookie_name;
    }
    if ($ttl > 0) {
        $g_session_ttl = $ttl;
    }
    ::init();
}

# Generate a secure session ID (32 hex characters)
func Cannoli_Session_generate_id() str {
    my str $id = "";
    my int $i = 0;
    my str $hex = "0123456789abcdef";

    # Use random() to generate 32 hex chars
    while ($i < 32) {
        # math::rand() returns 0-1, scale to 0-15
        my num $rand = math::rand();
        my int $r = math::floor($rand * 16);
        if ($r > 15) { $r = 15; }
        my str $ch = substr($hex, $r, 1);
        $id = $id . $ch;
        $i = $i + 1;
    }

    return $id;
}

# Get session file path
func Cannoli_Session_file_path(str $id) str {
    return $g_session_dir . "/sess_" . $id;
}

# Create a new session
func Cannoli_Session_new() scalar {
    ::init();

    my hash %session = ();
    $session{"id"} = ::generate_id();
    $session{"created"} = sys::time();
    $session{"modified"} = sys::time();
    $session{"data"} = {};

    return \%session;
}

# Load a session by ID
func Cannoli_Session_load(str $id) scalar {
    # Validate session ID (only hex chars allowed)
    if (length($id) != 32) {
        return undef;
    }

    my str $path = ::file_path($id);

    if (sys::is_file($path) == 0) {
        return undef;
    }

    # Read and parse session file
    my str $content = slurp($path);
    if (length($content) == 0) {
        return undef;
    }

    # Parse session data (simple key=value format)
    my hash %session = ();
    $session{"id"} = $id;
    $session{"data"} = {};

    my array @lines = split($content, "\n");
    my int $i = 0;
    my int $in_data = 0;

    while ($i < scalar(@lines)) {
        my str $line = $lines[$i];

        if (length($line) == 0) {
            $i = $i + 1;
            next;
        }

        # Parse key=value
        my int $eq_pos = index($line, "=");
        if ($eq_pos > 0) {
            my str $key = substr($line, 0, $eq_pos);
            my str $value = substr($line, $eq_pos + 1, length($line) - $eq_pos - 1);

            if ($key eq "_created") {
                $session{"created"} = $value + 0;
            } elsif ($key eq "_modified") {
                $session{"modified"} = $value + 0;
            } else {
                # User data
                my scalar $data = $session{"data"};
                $data->{$key} = ::decode_value($value);
            }
        }

        $i = $i + 1;
    }

    # Check TTL
    my int $now = sys::time();
    my int $modified = $session{"modified"} + 0;
    if ($now - $modified > $g_session_ttl) {
        # Session expired
        ::destroy($id);
        return undef;
    }

    return \%session;
}

# Save a session to file
func Cannoli_Session_save(scalar $session) int {
    ::init();

    my str $id = $session->{"id"};
    my str $path = ::file_path($id);

    # Update modified time
    $session->{"modified"} = sys::time();

    # Build file content
    my str $content = "";
    $content = $content . "_created=" . $session->{"created"} . "\n";
    $content = $content . "_modified=" . $session->{"modified"} . "\n";

    # Save data fields
    my scalar $data = $session->{"data"};
    my array @keys = keys(%{$data});
    my int $i = 0;

    while ($i < scalar(@keys)) {
        my str $key = $keys[$i];
        my str $value = ::encode_value($data->{$key});
        $content = $content . $key . "=" . $value . "\n";
        $i = $i + 1;
    }

    # Write to file
    spew($path, $content);
    return 1;
}

# Destroy a session
func Cannoli_Session_destroy(str $id) void {
    my str $path = ::file_path($id);
    if (sys::is_file($path) == 1) {
        sys::unlink($path);
    }
}

# Get a value from session
func Cannoli_Session_get(scalar $session, str $key) scalar {
    my scalar $data = $session->{"data"};
    if (exists(%{$data}, $key)) {
        return $data->{$key};
    }
    return undef;
}

# Set a value in session
func Cannoli_Session_set(scalar $session, str $key, scalar $value) void {
    my scalar $data = $session->{"data"};
    $data->{$key} = $value;
}

# Delete a value from session
# Note: Sets value to undef rather than removing key
func Cannoli_Session_delete(scalar $session, str $key) void {
    my scalar $data = $session->{"data"};
    if (exists(%{$data}, $key)) {
        $data->{$key} = undef;
    }
}

# Check if session has a key
func Cannoli_Session_has(scalar $session, str $key) int {
    my scalar $data = $session->{"data"};
    if (exists(%{$data}, $key)) {
        return 1;
    }
    return 0;
}

# Get session ID
func Cannoli_Session_id(scalar $session) str {
    return $session->{"id"};
}

# Get cookie name
func Cannoli_Session_cookie_name() str {
    return $g_session_cookie;
}

# Get TTL
func Cannoli_Session_ttl() int {
    return $g_session_ttl;
}

# Encode a value for storage (escape newlines and equals)
func Cannoli_Session_encode_value(scalar $value) str {
    if (!defined($value)) {
        return "";
    }

    my str $s = "" . $value;

    # Escape special chars: \ -> \\, newline -> \n, = -> \e
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        if ($ch eq "\\") {
            $result = $result . "\\\\";
        } elsif ($ch eq "\n") {
            $result = $result . "\\n";
        } elsif ($ch eq "=") {
            $result = $result . "\\e";
        } else {
            $result = $result . $ch;
        }

        $i = $i + 1;
    }

    return $result;
}

# Decode a stored value
func Cannoli_Session_decode_value(str $s) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        if ($ch eq "\\" && $i + 1 < $len) {
            my str $next_ch = substr($s, $i + 1, 1);
            if ($next_ch eq "\\") {
                $result = $result . "\\";
                $i = $i + 2;
                next;
            } elsif ($next_ch eq "n") {
                $result = $result . "\n";
                $i = $i + 2;
                next;
            } elsif ($next_ch eq "e") {
                $result = $result . "=";
                $i = $i + 2;
                next;
            }
        }

        $result = $result . $ch;
        $i = $i + 1;
    }

    return $result;
}

# Clean up expired sessions (call periodically)
func Cannoli_Session_cleanup() int {
    if (sys::is_dir($g_session_dir) == 0) {
        return 0;
    }

    my int $now = sys::time();
    my int $cleaned = 0;

    my array @files = sys::readdir($g_session_dir);
    my int $i = 0;

    while ($i < scalar(@files)) {
        my str $file = $files[$i];

        # Only process session files
        if (substr($file, 0, 5) eq "sess_") {
            my str $path = $g_session_dir . "/" . $file;

            # Check modification time via file content
            my str $content = slurp($path);
            my int $modified = 0;

            # Find _modified= line
            my int $pos = index($content, "_modified=");
            if ($pos >= 0) {
                my str $rest = substr($content, $pos + 10, 20);
                my int $nl = index($rest, "\n");
                if ($nl > 0) {
                    my str $ts = substr($rest, 0, $nl);
                    $modified = $ts + 0;
                }
            }

            # Remove if expired
            if ($modified > 0 && $now - $modified > $g_session_ttl) {
                sys::unlink($path);
                $cleaned = $cleaned + 1;
            }
        }

        $i = $i + 1;
    }

    return $cleaned;
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Template;


# cannoli/src/template.strada - Template rendering engine
#
# Simple template rendering with variable substitution.
# Supports {{variable}}, {{obj.field}}, loops, and conditionals.
#
# Usage:
#   Cannoli::Template::init("./templates");
#   my str $html = Cannoli::Template::render("user.html", {"name" => "Alice", "id" => 42});
#
# Template syntax:
#   {{name}}              - simple variable
#   {{user.name}}         - nested object field
#   {{user.address.city}} - deeply nested field
#
#   {{#each items}}       - loop over array (fields merged into scope)
#     {{name}}            - access current item fields directly
#   {{/each}}
#
#   {{#each item in items}} - loop with named variable
#     {{item.name}}         - access via named variable
#     {{@index}}            - current index (0-based)
#     {{@first}}            - true if first iteration
#     {{@last}}             - true if last iteration
#   {{/each}}
#
#   {{#set varname = value}}  - set a variable
#     {{#set name = user.name}}
#     {{#set greeting = "Hello"}}
#     {{#set count = 42}}
#
#   {{#with object}}      - change scope to object
#     {{name}}            - accesses object.name directly
#   {{/with}}
#
#   {{dump varname}}      - debug dump of variable (JSON-like format)
#
#   {{#if condition}}     - conditional (truthy check)
#     ...
#   {{else}}              - optional else clause
#     ...
#   {{/if}}

# Template cache
my hash %g_template_cache = ();
my str $g_template_dir = "./templates";
my int $g_cache_enabled = 1;

# Initialize template system with directory
func Cannoli_Template_init(str $dir) void {
    $g_template_dir = $dir;
}

# Set template directory
func Cannoli_Template_set_dir(str $dir) void {
    $g_template_dir = $dir;
}

# Get template directory
func Cannoli_Template_get_dir() str {
    return $g_template_dir;
}

# Enable/disable template caching
func Cannoli_Template_set_cache(int $enabled) void {
    $g_cache_enabled = $enabled;
}

# Clear template cache
func Cannoli_Template_clear_cache() void {
    %g_template_cache = ();
}

# Load a template file (with caching)
func Cannoli_Template_load(str $name) str {
    # Check cache first
    if ($g_cache_enabled == 1 && exists(%g_template_cache, $name)) {
        return $g_template_cache{$name};
    }

    # Build full path
    my str $path = $g_template_dir . "/" . $name;

    # Check if file exists
    if (sys::is_file($path) == 0) {
        return "";
    }

    # Load file content
    my str $content = slurp($path);

    # Cache if enabled
    if ($g_cache_enabled == 1) {
        $g_template_cache{$name} = $content;
    }

    return $content;
}

# Render a template file with variables
func Cannoli_Template_render(str $name, scalar $vars) str {
    my str $template = ::load($name);
    if (length($template) == 0) {
        return "";
    }
    return ::render_string($template, $vars);
}

# Render a template string with variables
func Cannoli_Template_render_string(str $template, scalar $vars) str {
    my str $result = "";
    my int $len = length($template);
    my int $i = 0;

    while ($i < $len) {
        # Check for {{#each ...}}
        if ($i + 7 < $len) {
            my str $check_each = substr($template, $i, 7);
            if ($check_each eq "{{#each") {
                # Find the closing }} of the opening tag
                my int $tag_end = ::find_closing($template, $i + 7);
                if ($tag_end > $i + 7) {
                    # Extract the each expression
                    my str $each_expr = substr($template, $i + 7, $tag_end - $i - 7);
                    $each_expr = trim($each_expr);

                    # Check for "item in items" syntax
                    my str $loop_var = "";
                    my str $collection_name = $each_expr;
                    my int $in_pos = index($each_expr, " in ");
                    if ($in_pos > 0) {
                        $loop_var = substr($each_expr, 0, $in_pos);
                        $collection_name = substr($each_expr, $in_pos + 4, length($each_expr) - $in_pos - 4);
                        $loop_var = trim($loop_var);
                        $collection_name = trim($collection_name);
                    }

                    # Find matching {{/each}}
                    my int $block_end = ::find_block_end($template, $tag_end + 2, "each");
                    if ($block_end > 0) {
                        # Extract body
                        my str $body = substr($template, $tag_end + 2, $block_end - $tag_end - 2);

                        # Process the each block
                        my str $rendered = ::process_each_named($collection_name, $loop_var, $body, $vars);
                        $result = $result . $rendered;

                        # Skip past {{/each}}
                        $i = $block_end + 9;
                        next;
                    }
                }
            }
        }

        # Check for {{#if ...}}
        if ($i + 5 < $len) {
            my str $check_if = substr($template, $i, 5);
            if ($check_if eq "{{#if") {
                # Find the closing }} of the opening tag
                my int $tag_end = ::find_closing($template, $i + 5);
                if ($tag_end > $i + 5) {
                    # Extract condition variable
                    my str $condition = substr($template, $i + 5, $tag_end - $i - 5);
                    $condition = trim($condition);

                    # Find matching {{/if}}
                    my int $block_end = ::find_block_end($template, $tag_end + 2, "if");
                    if ($block_end > 0) {
                        # Check for {{else}}
                        my int $else_pos = ::find_else($template, $tag_end + 2, $block_end);

                        my str $if_body = "";
                        my str $else_body = "";

                        if ($else_pos > 0) {
                            $if_body = substr($template, $tag_end + 2, $else_pos - $tag_end - 2);
                            $else_body = substr($template, $else_pos + 8, $block_end - $else_pos - 8);
                        } else {
                            $if_body = substr($template, $tag_end + 2, $block_end - $tag_end - 2);
                        }

                        # Process the if block
                        my str $rendered = ::process_if($condition, $if_body, $else_body, $vars);
                        $result = $result . $rendered;

                        # Skip past {{/if}}
                        $i = $block_end + 7;
                        next;
                    }
                }
            }
        }

        # Check for {{#set varname = value}}
        if ($i + 6 < $len) {
            my str $check_set = substr($template, $i, 6);
            if ($check_set eq "{{#set") {
                # Find the closing }}
                my int $tag_end = ::find_closing($template, $i + 6);
                if ($tag_end > $i + 6) {
                    # Extract the set expression: "varname = value"
                    my str $set_expr = substr($template, $i + 6, $tag_end - $i - 6);
                    $set_expr = trim($set_expr);

                    # Parse "varname = value"
                    my int $eq_pos = index($set_expr, "=");
                    if ($eq_pos > 0) {
                        my str $var_name = substr($set_expr, 0, $eq_pos);
                        my str $value_expr = substr($set_expr, $eq_pos + 1, length($set_expr) - $eq_pos - 1);
                        $var_name = trim($var_name);
                        $value_expr = trim($value_expr);

                        # Resolve the value
                        my scalar $value = ::resolve_value($value_expr, $vars);

                        # Set in vars (modify in place)
                        $vars->{$var_name} = $value;
                    }

                    # Skip past }}
                    $i = $tag_end + 2;
                    next;
                }
            }
        }

        # Check for {{#with object}}...{{/with}}
        if ($i + 7 < $len) {
            my str $check_with = substr($template, $i, 7);
            if ($check_with eq "{{#with") {
                # Find the closing }} of the opening tag
                my int $tag_end = ::find_closing($template, $i + 7);
                if ($tag_end > $i + 7) {
                    # Extract object name
                    my str $obj_name = substr($template, $i + 7, $tag_end - $i - 7);
                    $obj_name = trim($obj_name);

                    # Find matching {{/with}}
                    my int $block_end = ::find_block_end($template, $tag_end + 2, "with");
                    if ($block_end > 0) {
                        # Extract body
                        my str $body = substr($template, $tag_end + 2, $block_end - $tag_end - 2);

                        # Get the object and merge into new scope
                        my scalar $obj = ::get_var($obj_name, $vars);
                        my scalar $new_vars = ::merge_scope($vars, $obj);

                        # Render body with merged scope
                        my str $rendered = ::render_string($body, $new_vars);
                        $result = $result . $rendered;

                        # Skip past {{/with}}
                        $i = $block_end + 9;
                        next;
                    }
                }
            }
        }

        # Look for {{ start (simple variable or dump)
        if ($i + 1 < $len) {
            my str $two = substr($template, $i, 2);
            if ($two eq "{{") {
                # Find closing }}
                my int $end = ::find_closing($template, $i + 2);
                if ($end > $i + 2) {
                    # Extract content
                    my str $content = substr($template, $i + 2, $end - $i - 2);
                    $content = trim($content);

                    # Check for {{dump varname}}
                    if (length($content) > 5 && substr($content, 0, 5) eq "dump ") {
                        my str $var_name = substr($content, 5, length($content) - 5);
                        $var_name = trim($var_name);
                        my scalar $val = ::get_var($var_name, $vars);
                        my str $dump_str = ::dump($val, 0);
                        # HTML-escape the dump to prevent template re-parsing
                        $dump_str = ::escape_html($dump_str);
                        $result = $result . "<pre class=\"template-dump\">" . $dump_str . "</pre>";
                        $i = $end + 2;
                        next;
                    }

                    # Regular variable
                    my str $value = ::resolve_var($content, $vars);
                    $result = $result . $value;

                    # Skip past }}
                    $i = $end + 2;
                    next;
                }
            }
        }

        # Regular character
        my str $ch = substr($template, $i, 1);
        $result = $result . $ch;
        $i = $i + 1;
    }

    return $result;
}

# Resolve a value expression (string literal, number, or variable reference)
func Cannoli_Template_resolve_value(str $expr, scalar $vars) scalar {
    # Check for string literal "value" or 'value'
    my int $expr_len = length($expr);
    if ($expr_len >= 2) {
        my str $first_ch = substr($expr, 0, 1);
        my str $last_ch = substr($expr, $expr_len - 1, 1);

        if (($first_ch eq "\"" && $last_ch eq "\"") || ($first_ch eq "'" && $last_ch eq "'")) {
            # String literal - extract content
            return substr($expr, 1, $expr_len - 2);
        }
    }

    # Check for numeric literal
    my int $is_num = 1;
    my int $has_dot = 0;
    my int $j = 0;
    while ($j < $expr_len && $is_num == 1) {
        my str $ch = substr($expr, $j, 1);
        if ($ch eq ".") {
            if ($has_dot == 1) {
                $is_num = 0;
            }
            $has_dot = 1;
        } elsif ($ch eq "-" && $j == 0) {
            # Allow leading minus
        } elsif ($ch ge "0" && $ch le "9") {
            # Digit OK
        } else {
            $is_num = 0;
        }
        $j = $j + 1;
    }

    if ($is_num == 1 && $expr_len > 0) {
        # Return as number
        return $expr + 0;
    }

    # Otherwise treat as variable reference
    return ::get_var($expr, $vars);
}

# Merge an object's fields into a new scope (for {{#with}})
func Cannoli_Template_merge_scope(scalar $parent_vars, scalar $obj) scalar {
    my scalar $new_vars = {};

    # Copy parent vars first
    if (ref($parent_vars) eq "HASH") {
        foreach my str $k (keys(%{$parent_vars})) {
            $new_vars->{$k} = $parent_vars->{$k};
        }
    }

    # Merge object fields (overrides parent)
    if (ref($obj) eq "HASH") {
        foreach my str $k (keys(%{$obj})) {
            $new_vars->{$k} = $obj->{$k};
        }
    }

    return $new_vars;
}

# Dump a value for debugging (returns formatted string)
# Simple implementation: shows type and top-level contents
func Cannoli_Template_dump(scalar $val, int $indent) str {
    defined($indent);
    if (!defined($val)) {
        return "undef";
    }

    my str $r = ref($val);

    if ($r eq "HASH") {
        my str $out = "{\n";
        foreach my str $k (keys(%{$val})) {
            my scalar $v = $val->{$k};
            $out = $out . "  \"" . $k . "\": " . ::dump_value($v) . ",\n";
        }
        $out = $out . "}";
        return $out;
    }

    if ($r eq "ARRAY") {
        my str $out = "[\n";
        my int $arr_len = scalar(@{$val});
        my int $arr_i = 0;
        while ($arr_i < $arr_len) {
            my scalar $v = $val->[$arr_i];
            $out = $out . "  " . ::dump_value($v) . ",\n";
            $arr_i = $arr_i + 1;
        }
        $out = $out . "]";
        return $out;
    }

    # Scalar
    return ::dump_scalar($val);
}

# Dump a nested value (shallow - no further recursion)
func Cannoli_Template_dump_value(scalar $val) str {
    if (!defined($val)) {
        return "undef";
    }

    my str $r = ref($val);

    if ($r eq "HASH") {
        my str $out = "{";
        my int $count = 0;
        foreach my str $k (keys(%{$val})) {
            if ($count > 0) {
                $out = $out . ", ";
            }
            $out = $out . "\"" . $k . "\": ...";
            $count = $count + 1;
        }
        $out = $out . "}";
        return $out;
    }

    if ($r eq "ARRAY") {
        my int $arr_len = scalar(@{$val});
        return "[" . $arr_len . " items]";
    }

    return ::dump_scalar($val);
}

# Format a scalar value for dump
func Cannoli_Template_dump_scalar(scalar $val) str {
    if (!defined($val)) {
        return "undef";
    }

    my str $s = "" . $val;

    # Check if it looks like a number
    my int $is_num = 1;
    my int $has_dot = 0;
    my int $slen = length($s);
    my int $j = 0;

    if ($slen == 0) {
        return "\"\"";
    }

    while ($j < $slen && $is_num == 1) {
        my str $ch = substr($s, $j, 1);
        if ($ch eq ".") {
            if ($has_dot == 1) {
                $is_num = 0;
            }
            $has_dot = 1;
        } elsif ($ch eq "-" && $j == 0) {
            # OK
        } elsif ($ch ge "0" && $ch le "9") {
            # OK
        } else {
            $is_num = 0;
        }
        $j = $j + 1;
    }

    if ($is_num == 1) {
        return $s;
    }

    # String - quote it
    return "\"" . $s . "\"";
}

# Find closing }} from start position
func Cannoli_Template_find_closing(str $template, int $start) int {
    my int $len = length($template);
    my int $i = $start;

    while ($i + 1 < $len) {
        my str $two = substr($template, $i, 2);
        if ($two eq "}}") {
            return $i;
        }
        $i = $i + 1;
    }

    return -1;
}

# Resolve a variable name (supports dot notation for nested access)
func Cannoli_Template_resolve_var(str $name, scalar $vars) str {
    if (!defined($vars)) {
        return "";
    }

    # Check for dot notation (e.g., user.name, user.address.city)
    my int $dot = index($name, ".");
    if ($dot > 0) {
        # Split on first dot
        my str $first = substr($name, 0, $dot);
        my str $rest = substr($name, $dot + 1, length($name) - $dot - 1);

        # Get nested value
        if (ref($vars) eq "HASH" && exists(%{$vars}, $first)) {
            my scalar $nested = $vars->{$first};
            return ::resolve_var($rest, $nested);
        }
        return "";
    }

    # Simple variable lookup
    if (ref($vars) eq "HASH" && exists(%{$vars}, $name)) {
        my scalar $value = $vars->{$name};

        # Convert to string
        if (!defined($value)) {
            return "";
        }
        return "" . $value;
    }

    return "";
}

# Get a variable value (not converted to string)
func Cannoli_Template_get_var(str $name, scalar $vars) scalar {
    if (!defined($vars)) {
        return undef;
    }

    # Check for dot notation
    my int $dot = index($name, ".");
    if ($dot > 0) {
        my str $first = substr($name, 0, $dot);
        my str $rest = substr($name, $dot + 1, length($name) - $dot - 1);

        if (ref($vars) eq "HASH" && exists(%{$vars}, $first)) {
            my scalar $nested = $vars->{$first};
            return ::get_var($rest, $nested);
        }
        return undef;
    }

    # Simple variable lookup
    if (ref($vars) eq "HASH" && exists(%{$vars}, $name)) {
        return $vars->{$name};
    }

    return undef;
}

# Check if a value is truthy
func Cannoli_Template_is_truthy(scalar $val) int {
    if (!defined($val)) {
        return 0;
    }

    my str $r = ref($val);
    if ($r eq "ARRAY") {
        my int $len = scalar(@{$val});
        return $len > 0;
    }
    if ($r eq "HASH") {
        return 1;
    }

    # String or number
    my str $s = "" . $val;
    if ($s eq "" || $s eq "0") {
        return 0;
    }
    return 1;
}

# Find matching block end tag (handles nesting)
# block_type is "each" or "if"
func Cannoli_Template_find_block_end(str $template, int $start, str $block_type) int {
    my int $len = length($template);
    my int $i = $start;
    my int $depth = 1;
    my str $open_tag = "{{#" . $block_type;
    my str $close_tag = "{{/" . $block_type . "}}";
    my int $open_len = length($open_tag);
    my int $close_len = length($close_tag);

    while ($i < $len && $depth > 0) {
        # Check for nested open tag
        if ($i + $open_len <= $len) {
            my str $check_open = substr($template, $i, $open_len);
            if ($check_open eq $open_tag) {
                $depth = $depth + 1;
                $i = $i + $open_len;
                next;
            }
        }

        # Check for close tag
        if ($i + $close_len <= $len) {
            my str $check_close = substr($template, $i, $close_len);
            if ($check_close eq $close_tag) {
                $depth = $depth - 1;
                if ($depth == 0) {
                    return $i;
                }
                $i = $i + $close_len;
                next;
            }
        }

        $i = $i + 1;
    }

    return -1;
}

# Find {{else}} at current nesting level
func Cannoli_Template_find_else(str $template, int $start, int $block_end) int {
    my int $i = $start;
    my int $depth = 0;

    while ($i < $block_end) {
        # Track nested #if blocks
        if ($i + 5 <= $block_end) {
            my str $check = substr($template, $i, 5);
            if ($check eq "{{#if") {
                $depth = $depth + 1;
                $i = $i + 5;
                next;
            }
        }

        if ($i + 7 <= $block_end) {
            my str $check = substr($template, $i, 7);
            if ($check eq "{{/if}}") {
                $depth = $depth - 1;
                $i = $i + 7;
                next;
            }
        }

        # Look for {{else}} at depth 0
        if ($depth == 0 && $i + 8 <= $block_end) {
            my str $check = substr($template, $i, 8);
            if ($check eq "{{else}}") {
                return $i;
            }
        }

        $i = $i + 1;
    }

    return -1;
}

# Process an #each block with named variable support
# $collection_name: the variable containing the array (e.g., "items" or "user.roles")
# $loop_var: the name for each item (e.g., "item"), empty string for legacy mode
# $body: the template body to render for each item
# $vars: the current variable scope
func Cannoli_Template_process_each_named(str $collection_name, str $loop_var, str $body, scalar $vars) str {
    my scalar $arr = ::get_var($collection_name, $vars);

    if (!defined($arr) || ref($arr) ne "ARRAY") {
        return "";
    }

    my str $result = "";
    my int $len = scalar(@{$arr});
    my int $idx = 0;

    foreach my scalar $item (@{$arr}) {
        # Create iteration context
        my scalar $iter_vars = {};

        # Copy parent vars
        if (ref($vars) eq "HASH") {
            foreach my str $k (keys(%{$vars})) {
                $iter_vars->{$k} = $vars->{$k};
            }
        }

        # Handle named variable syntax: {{#each item in items}}
        if (length($loop_var) > 0) {
            # Named variable mode: item is accessible as {{loop_var}} or {{loop_var.field}}
            $iter_vars->{$loop_var} = $item;
        } else {
            # Legacy mode: merge hash fields into scope, or use "this" for scalars
            if (ref($item) eq "HASH") {
                foreach my str $k (keys(%{$item})) {
                    $iter_vars->{$k} = $item->{$k};
                }
            } else {
                $iter_vars->{"this"} = $item;
            }
        }

        # Add loop metadata
        $iter_vars->{"@index"} = $idx;
        if ($idx == 0) {
            $iter_vars->{"@first"} = 1;
        } else {
            $iter_vars->{"@first"} = 0;
        }
        if ($idx == $len - 1) {
            $iter_vars->{"@last"} = 1;
        } else {
            $iter_vars->{"@last"} = 0;
        }

        # Render body with iteration context
        my str $rendered = ::render_string($body, $iter_vars);
        $result = $result . $rendered;

        $idx = $idx + 1;
    }

    return $result;
}

# Process an #if block
func Cannoli_Template_process_if(str $condition, str $if_body, str $else_body, scalar $vars) str {
    my scalar $val = ::get_var($condition, $vars);
    my int $truthy = ::is_truthy($val);

    if ($truthy == 1) {
        return ::render_string($if_body, $vars);
    } else {
        if (length($else_body) > 0) {
            return ::render_string($else_body, $vars);
        }
        return "";
    }
}

# HTML escape a string
func Cannoli_Template_escape_html(str $s) str {
    my str $result = "";
    my int $len = length($s);
    my int $i = 0;

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        if ($ch eq "&") {
            $result = $result . "&amp;";
        } elsif ($ch eq "<") {
            $result = $result . "&lt;";
        } elsif ($ch eq ">") {
            $result = $result . "&gt;";
        } elsif ($ch eq "\"") {
            $result = $result . "&quot;";
        } elsif ($ch eq "'") {
            $result = $result . "&#39;";
        } else {
            $result = $result . $ch;
        }

        $i = $i + 1;
    }

    return $result;
}

# Render with HTML escaping for variables
func Cannoli_Template_render_safe(str $name, scalar $vars) str {
    my str $template = ::load($name);
    if (length($template) == 0) {
        return "";
    }
    return ::render_string_safe($template, $vars);
}

# Render string with HTML escaping
func Cannoli_Template_render_string_safe(str $template, scalar $vars) str {
    my str $result = "";
    my int $len = length($template);
    my int $i = 0;

    while ($i < $len) {
        # Look for {{ start
        if ($i + 1 < $len) {
            my str $two = substr($template, $i, 2);
            if ($two eq "{{") {
                # Find closing }}
                my int $end = ::find_closing($template, $i + 2);
                if ($end > $i + 2) {
                    # Extract variable name
                    my str $var_name = substr($template, $i + 2, $end - $i - 2);
                    $var_name = trim($var_name);

                    # Check for raw output marker {{{var}}}
                    my int $raw = 0;
                    if (length($var_name) > 0 && substr($var_name, 0, 1) eq "{") {
                        # Check if this is {{{ which means raw
                        if ($i + 2 < $len && substr($template, $i, 3) eq "{{{") {
                            my int $raw_end = ::find_triple_closing($template, $i + 3);
                            if ($raw_end > 0) {
                                $var_name = substr($template, $i + 3, $raw_end - $i - 3);
                                $var_name = trim($var_name);
                                my str $value = ::resolve_var($var_name, $vars);
                                $result = $result . $value;
                                $i = $raw_end + 3;
                                next;
                            }
                        }
                    }

                    # Resolve and escape variable
                    my str $value = ::resolve_var($var_name, $vars);
                    $result = $result . ::escape_html($value);

                    # Skip past }}
                    $i = $end + 2;
                    next;
                }
            }
        }

        # Regular character
        my str $ch = substr($template, $i, 1);
        $result = $result . $ch;
        $i = $i + 1;
    }

    return $result;
}

# Find triple closing }}}
func Cannoli_Template_find_triple_closing(str $template, int $start) int {
    my int $len = length($template);
    my int $i = $start;

    while ($i + 2 < $len) {
        my str $three = substr($template, $i, 3);
        if ($three eq "}}}") {
            return $i;
        }
        $i = $i + 1;
    }

    return -1;
}

# Include another template (for partials/layouts)
func Cannoli_Template_include(str $name, scalar $vars) str {
    return ::render($name, $vars);
}

# Render a template with a layout
# Layout should have {{content}} placeholder
func Cannoli_Template_render_with_layout(str $template_name, str $layout_name, scalar $vars) str {
    # First render the main template
    my str $content = ::render($template_name, $vars);

    # Add content to vars
    if (!defined($vars)) {
        $vars = {};
    }
    $vars->{"content"} = $content;

    # Render the layout with the content
    return ::render($layout_name, $vars);
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Validation;


# cannoli/src/validation.strada - Request validation
#
# Provides validation rules for request parameters.
#
# Usage:
#   my scalar $v = Cannoli::Validation::new();
#   Cannoli::Validation::add($v, "email", $email, "required");
#   Cannoli::Validation::add($v, "email", $email, "email");
#   Cannoli::Validation::add($v, "password", $password, "min_length", 8);
#
#   if (Cannoli::Validation::validate($v) == 1) {
#       # Valid
#   } else {
#       my hash %errors = Cannoli::Validation::errors($v);
#   }

# ============================================================
# Individual Validation Rules
# ============================================================

# Check if value is present (not empty)
func Cannoli_Validation_required(scalar $value) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;
    if (length($s) == 0) {
        return 0;
    }
    return 1;
}

# Check if value is a valid Cannoli::Validation::email(basic check)
func Cannoli_Validation_email(scalar $value) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;

    # Must contain @ with something before and after
    my int $at = index($s, "@");
    if ($at < 1) {
        return 0;
    }

    # Must have a dot after @
    my str $domain = substr($s, $at + 1, length($s) - $at - 1);
    my int $dot = index($domain, ".");
    if ($dot < 1) {
        return 0;
    }

    # Must have something after the dot
    if ($dot >= length($domain) - 1) {
        return 0;
    }

    return 1;
}

# Check minimum length
func Cannoli_Validation_min_length(scalar $value, int $min) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;
    return length($s) >= $min;
}

# Check maximum length
func Cannoli_Validation_max_length(scalar $value, int $max) int {
    if (!defined($value)) {
        return 1;  # Undefined values pass max_length
    }
    my str $s = "" . $value;
    return length($s) <= $max;
}

# Check if value is Cannoli::Validation::numeric(integer or decimal)
func Cannoli_Validation_numeric(scalar $value) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;
    if (length($s) == 0) {
        return 0;
    }

    my int $i = 0;
    my int $len = length($s);
    my int $has_digit = 0;
    my int $has_dot = 0;

    # Allow leading minus
    if (substr($s, 0, 1) eq "-") {
        $i = 1;
    }

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch ge "0" && $ch le "9") {
            $has_digit = 1;
        } elsif ($ch eq ".") {
            if ($has_dot == 1) {
                return 0;  # Multiple dots
            }
            $has_dot = 1;
        } else {
            return 0;  # Invalid character
        }
        $i = $i + 1;
    }

    return $has_digit;
}

# Check if value is an integer
func Cannoli_Validation_integer(scalar $value) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;
    if (length($s) == 0) {
        return 0;
    }

    my int $i = 0;
    my int $len = length($s);

    # Allow leading minus
    if (substr($s, 0, 1) eq "-") {
        $i = 1;
    }

    if ($i >= $len) {
        return 0;  # Just a minus sign
    }

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch lt "0" || $ch gt "9") {
            return 0;
        }
        $i = $i + 1;
    }

    return 1;
}

# Check if value matches a regex pattern
func Cannoli_Validation_regex(scalar $value, str $pattern) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;
    if ($s =~ /$pattern/) {
        return 1;
    }
    return 0;
}

# Check if value is in a list of allowed values
func Cannoli_Validation_in(scalar $value, scalar $allowed) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;

    my int $i = 0;
    my int $num = scalar(@{$allowed});
    while ($i < $num) {
        my str $item = "" . $allowed->[$i];
        if ($s eq $item) {
            return 1;
        }
        $i = $i + 1;
    }

    return 0;
}

# Check minimum value (numeric)
func Cannoli_Validation_min(scalar $value, int $min) int {
    if (!::numeric($value)) {
        return 0;
    }
    my int $n = $value + 0;
    return $n >= $min;
}

# Check maximum value (numeric)
func Cannoli_Validation_max(scalar $value, int $max) int {
    if (!::numeric($value)) {
        return 0;
    }
    my int $n = $value + 0;
    return $n <= $max;
}

# Check if value equals another value
func Cannoli_Validation_equals(scalar $value, scalar $other) int {
    if (!defined($value) || !defined($other)) {
        return 0;
    }
    my str $s1 = "" . $value;
    my str $s2 = "" . $other;
    return $s1 eq $s2;
}

# Check if value is alphanumeric only
func Cannoli_Validation_alphanumeric(scalar $value) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;
    if (length($s) == 0) {
        return 0;
    }

    my int $i = 0;
    while ($i < length($s)) {
        my str $ch = substr($s, $i, 1);
        my int $valid = 0;
        if ($ch ge "a" && $ch le "z") { $valid = 1; }
        if ($ch ge "A" && $ch le "Z") { $valid = 1; }
        if ($ch ge "0" && $ch le "9") { $valid = 1; }
        if ($valid == 0) {
            return 0;
        }
        $i = $i + 1;
    }

    return 1;
}

# Check if value looks like a URL
func Cannoli_Validation_url(scalar $value) int {
    if (!defined($value)) {
        return 0;
    }
    my str $s = "" . $value;

    # Must start with http:// or https://
    if (substr($s, 0, 7) ne "http://" && substr($s, 0, 8) ne "https://") {
        return 0;
    }

    # Must have something after the protocol
    my int $proto_len = 7;
    if (substr($s, 0, 8) eq "https://") {
        $proto_len = 8;
    }

    my str $rest = substr($s, $proto_len, length($s) - $proto_len);
    if (length($rest) < 3) {
        return 0;
    }

    return 1;
}

# ============================================================
# Validator Object
# ============================================================

# Create a new validator
func Cannoli_Validation_new() scalar {
    my hash %validator = ();
    $validator{"rules"} = [];
    $validator{"errors"} = {};
    $validator{"valid"} = 1;
    return \%validator;
}

# Add a validation rule
# Rules: required, email, min_length, max_length, numeric, integer, regex, in, min, max, alphanumeric, url
func Cannoli_Validation_add(scalar $v, str $field, scalar $value, str $rule, scalar $param) void {
    my hash %entry = ();
    $entry{"field"} = $field;
    $entry{"value"} = $value;
    $entry{"rule"} = $rule;
    $entry{"param"} = $param;
    push(@{$v->{"rules"}}, \%entry);
}

# Run validation
func Cannoli_Validation_validate(scalar $v) int {
    my scalar $rules = $v->{"rules"};
    my scalar $errors = $v->{"errors"};
    my int $all_valid = 1;

    my int $i = 0;
    while ($i < scalar(@{$rules})) {
        my scalar $entry = $rules->[$i];
        my str $field = $entry->{"field"};
        my scalar $value = $entry->{"value"};
        my str $rule = $entry->{"rule"};
        my scalar $param = $entry->{"param"};

        my int $valid = 1;
        my str $error_msg = "";

        # Apply validation rule
        if ($rule eq "required") {
            if (::required($value) == 0) {
                $valid = 0;
                $error_msg = $field . " is required";
            }
        } elsif ($rule eq "email") {
            if (::email($value) == 0) {
                $valid = 0;
                $error_msg = $field . " must be a valid email";
            }
        } elsif ($rule eq "min_length") {
            my int $min = $param + 0;
            if (::min_length($value, $min) == 0) {
                $valid = 0;
                $error_msg = $field . " must be at least " . $min . " characters";
            }
        } elsif ($rule eq "max_length") {
            my int $max = $param + 0;
            if (::max_length($value, $max) == 0) {
                $valid = 0;
                $error_msg = $field . " must be at most " . $max . " characters";
            }
        } elsif ($rule eq "numeric") {
            if (::numeric($value) == 0) {
                $valid = 0;
                $error_msg = $field . " must be numeric";
            }
        } elsif ($rule eq "integer") {
            if (::integer($value) == 0) {
                $valid = 0;
                $error_msg = $field . " must be an integer";
            }
        } elsif ($rule eq "regex") {
            my str $pattern = "" . $param;
            if (::regex($value, $pattern) == 0) {
                $valid = 0;
                $error_msg = $field . " is invalid";
            }
        } elsif ($rule eq "in") {
            if (::in($value, $param) == 0) {
                $valid = 0;
                $error_msg = $field . " must be one of the allowed values";
            }
        } elsif ($rule eq "min") {
            my int $min = $param + 0;
            if (::min($value, $min) == 0) {
                $valid = 0;
                $error_msg = $field . " must be at least " . $min;
            }
        } elsif ($rule eq "max") {
            my int $max = $param + 0;
            if (::max($value, $max) == 0) {
                $valid = 0;
                $error_msg = $field . " must be at most " . $max;
            }
        } elsif ($rule eq "alphanumeric") {
            if (::alphanumeric($value) == 0) {
                $valid = 0;
                $error_msg = $field . " must be alphanumeric";
            }
        } elsif ($rule eq "url") {
            if (::url($value) == 0) {
                $valid = 0;
                $error_msg = $field . " must be a valid URL";
            }
        }

        # Record error if invalid
        if ($valid == 0) {
            $all_valid = 0;
            # Store first error per field
            if (!exists(%{$errors}, $field)) {
                $errors->{$field} = $error_msg;
            }
        }

        $i = $i + 1;
    }

    $v->{"valid"} = $all_valid;
    return $all_valid;
}

# Get validation Cannoli::Validation::errors(hash of field => error message)
func Cannoli_Validation_errors(scalar $v) scalar {
    return $v->{"errors"};
}

# Check if validation passed
func Cannoli_Validation_is_valid(scalar $v) int {
    return $v->{"valid"};
}

# Get error for a specific field
func Cannoli_Validation_error(scalar $v, str $field) str {
    my scalar $errors = $v->{"errors"};
    if (exists(%{$errors}, $field)) {
        return $errors->{$field};
    }
    return "";
}

# ============================================================
# Cannoli Integration - Declarative Validation
# ============================================================

# Create validator from a rules hash
# rules format: { "field" => ["rule1", "rule2:param", ...] }
# e.g.: { "email" => ["required", "email"], "age" => ["required", "integer", "min:18"] }
func Cannoli_Validation_from_rules(scalar $params, scalar $rules) scalar {
    my scalar $v = ::new();

    my array @fields = keys(%{$rules});
    my int $i = 0;

    while ($i < scalar(@fields)) {
        my str $field = $fields[$i];
        my scalar $field_rules = $rules->{$field};

        # Get value from params
        my scalar $value = undef;
        if (defined($params) && exists(%{$params}, $field)) {
            $value = $params->{$field};
        }

        # Process each rule
        my int $j = 0;
        while ($j < scalar(@{$field_rules})) {
            my str $rule_spec = "" . $field_rules->[$j];

            # Parse rule:param format
            my str $rule = $rule_spec;
            my scalar $param = undef;
            my int $colon = index($rule_spec, ":");

            if ($colon > 0) {
                $rule = substr($rule_spec, 0, $colon);
                my str $param_str = substr($rule_spec, $colon + 1, length($rule_spec) - $colon - 1);
                $param = $param_str;
            }

            ::add($v, $field, $value, $rule, $param);
            $j = $j + 1;
        }

        $i = $i + 1;
    }

    return $v;
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Request;


# cannoli/src/request.strada - HTTP Request parsing
#
# Parses incoming HTTP requests into a structured format

# Create a new empty request object
func Cannoli_Request_new() hash {
    my hash %req = ();

    $req{"method"} = "GET";
    $req{"uri"} = "/";
    $req{"path"} = "/";
    $req{"query_string"} = "";
    $req{"http_version"} = "HTTP/1.1";
    $req{"headers"} = {};
    $req{"body"} = "";
    $req{"content_length"} = "0";
    $req{"content_type"} = "";
    $req{"params"} = {};
    $req{"captures"} = [];
    $req{"remote_addr"} = "";
    $req{"remote_port"} = "0";

    return %req;
}

# Parse an HTTP request from raw data
func Cannoli_Request_parse(str $data) hash {
    my hash %req = ::new();
    say("DEBUG parse: data=[" . substr($data, 0, 100) . "]");

    # Split headers and body
    my int $body_start = index($data, "\r\n\r\n");
    my str $header_section = $data;
    my str $body = "";

    if ($body_start >= 0) {
        $header_section = substr($data, 0, $body_start);
        $body = substr($data, $body_start + 4, length($data) - $body_start - 4);
    }

    # Parse request line
    my array @lines = split("\r\n", $header_section);
    if (scalar(@lines) < 1) {
        return %req;
    }

    my str $request_line = $lines[0];
    my array @parts = split(" ", $request_line);

    if (scalar(@parts) >= 3) {
        $req{"method"} = $parts[0];
        $req{"uri"} = $parts[1];
        $req{"http_version"} = $parts[2];

        # Parse path and query string
        my str $uri = $parts[1];
        my int $q_pos = index($uri, "?");
        if ($q_pos >= 0) {
            $req{"path"} = substr($uri, 0, $q_pos);
            $req{"query_string"} = substr($uri, $q_pos + 1, length($uri) - $q_pos - 1);
        } else {
            $req{"path"} = $uri;
        }
    }

    # Parse headers
    my hash %headers = ();
    my int $i = 1;
    while ($i < scalar(@lines)) {
        my str $line = $lines[$i];
        my int $colon = index($line, ":");

        if ($colon > 0) {
            my str $name = substr($line, 0, $colon);
            my str $value = substr($line, $colon + 1, length($line) - $colon - 1);

            # Trim leading space from value
            if (length($value) > 0 && substr($value, 0, 1) eq " ") {
                $value = substr($value, 1, length($value) - 1);
            }

            # Normalize header name to lowercase
            $name = ::header_normalize($name);
            $headers{$name} = $value;
        }

        $i = $i + 1;
    }

    $req{"headers"} = \%headers;
    $req{"body"} = $body;

    # Extract common headers
    if (exists(%headers, "content-length")) {
        $req{"content_length"} = $headers{"content-length"};
    }
    if (exists(%headers, "content-type")) {
        $req{"content_type"} = $headers{"content-type"};
    }

    # Parse query parameters
    if (length($req{"query_string"}) > 0) {
        $req{"params"} = ::parse_query($req{"query_string"});
    }

    # Parse POST/PUT body if form data
    my str $method = $req{"method"};
    if (($method eq "POST" || $method eq "PUT" || $method eq "PATCH") && length($body) > 0) {
        my str $ct = $req{"content_type"};

        if (index($ct, "multipart/form-data") >= 0) {
            # Parse multipart form data (file uploads)
            my str $boundary = ::extract_boundary($ct);
            if (length($boundary) > 0) {
                my hash %multipart = ::parse_multipart($body, $boundary);

                # Store files
                $req{"files"} = $multipart{"files"};

                # Merge form fields with params
                my hash %params = %{$req{"params"}};
                my scalar $mp_params = $multipart{"params"};
                my array @k = keys(%{$mp_params});
                my int $j = 0;
                while ($j < scalar(@k)) {
                    my str $key = $k[$j];
                    $params{$key} = $mp_params->{$key};
                    $j = $j + 1;
                }
                $req{"params"} = \%params;
            }
        } elsif (index($ct, "application/x-www-form-urlencoded") >= 0) {
            my scalar $body_params = ::parse_query($body);
            # Merge with existing params
            my hash %params = %{$req{"params"}};
            my array @k = keys(%{$body_params});
            my int $j = 0;
            while ($j < scalar(@k)) {
                my str $key = $k[$j];
                $params{$key} = $body_params->{$key};
                $j = $j + 1;
            }
            $req{"params"} = \%params;
        }
    }

    # Initialize files hash if not set
    if (!exists(%req, "files")) {
        my hash %empty_files = ();
        $req{"files"} = \%empty_files;
    }

    return %req;
}

# Parse query string into hash
func Cannoli_Request_parse_query(str $qs) scalar {
    my hash %params = ();

    if (length($qs) == 0) {
        return \%params;
    }

    my array @pairs = split("&", $qs);
    my int $i = 0;

    while ($i < scalar(@pairs)) {
        my str $pair = $pairs[$i];
        my int $eq_idx = index($pair, "=");

        if ($eq_idx > 0) {
            my str $key = ::url_decode(substr($pair, 0, $eq_idx));
            my str $val = ::url_decode(substr($pair, $eq_idx + 1, length($pair) - $eq_idx - 1));
            $params{$key} = $val;
        } elsif (length($pair) > 0) {
            $params{::url_decode($pair)} = "";
        }

        $i = $i + 1;
    }

    return \%params;
}

# URL decode a string
func Cannoli_Request_url_decode(str $s) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        if ($ch eq "+") {
            $result = $result . " ";
        } elsif ($ch eq "%" && $i + 2 < $len) {
            my str $hex = substr($s, $i + 1, 2);
            my int $code = ::hex_to_int($hex);
            if ($code >= 0) {
                $result = $result . chr($code);
                $i = $i + 2;
            } else {
                $result = $result . $ch;
            }
        } else {
            $result = $result . $ch;
        }

        $i = $i + 1;
    }

    return $result;
}

# Convert hex string to integer
func Cannoli_Request_hex_to_int(str $hex) int {
    my int $result = 0;
    my int $i = 0;
    my int $len = length($hex);

    while ($i < $len) {
        my str $ch = substr($hex, $i, 1);
        my int $code = ord($ch);
        my int $digit = 0;

        if ($code >= 48 && $code <= 57) {
            # 0-9
            $digit = $code - 48;
        } elsif ($code >= 65 && $code <= 70) {
            # A-F
            $digit = $code - 55;
        } elsif ($code >= 97 && $code <= 102) {
            # a-f
            $digit = $code - 87;
        } else {
            return -1;
        }

        $result = $result * 16 + $digit;
        $i = $i + 1;
    }

    return $result;
}

# Normalize header name (lowercase)
func Cannoli_Request_header_normalize(str $name) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($name);

    while ($i < $len) {
        my str $ch = substr($name, $i, 1);
        my int $code = ord($ch);

        # A-Z -> a-z
        if ($code >= 65 && $code <= 90) {
            $result = $result . chr($code + 32);
        } else {
            $result = $result . $ch;
        }
        $i = $i + 1;
    }

    return $result;
}

# Get a header value (case-insensitive)
func Cannoli_Request_get_header(hash %req, str $name) str {
    my str $normalized = ::header_normalize($name);
    my scalar $headers = $req{"headers"};

    if (exists(%{$headers}, $normalized)) {
        return $headers->{$normalized};
    }
    return "";
}

# Get a parameter value
func Cannoli_Request_get_param(hash %req, str $name) str {
    my scalar $params = $req{"params"};

    if (exists(%{$params}, $name)) {
        return $params->{$name};
    }
    return "";
}

# Check if request is a specific method
func Cannoli_Request_is_get(hash %req) int {
    return $req{"method"} eq "GET";
}

func Cannoli_Request_is_post(hash %req) int {
    return $req{"method"} eq "POST";
}

func Cannoli_Request_is_put(hash %req) int {
    return $req{"method"} eq "PUT";
}

func Cannoli_Request_is_delete(hash %req) int {
    return $req{"method"} eq "DELETE";
}

# Get all headers as a hash reference
func Cannoli_Request_headers(hash %req) scalar {
    return $req{"headers"};
}

# Check if a header exists
func Cannoli_Request_has_header(hash %req, str $name) int {
    my str $normalized = ::header_normalize($name);
    my scalar $headers = $req{"headers"};
    return exists(%{$headers}, $normalized);
}

# Get all header names as an array
func Cannoli_Request_header_names(hash %req) array {
    my scalar $headers = $req{"headers"};
    return keys(%{$headers});
}

# Get a cookie value from the Cookie header
func Cannoli_Request_get_cookie(hash %req, str $name) str {
    my str $cookie_header = ::get_header(%req, "Cookie");
    if (length($cookie_header) == 0) {
        return "";
    }

    # Parse cookies: "name1=value1; name2=value2"
    my array @pairs = split(";", $cookie_header);
    my int $i = 0;
    while ($i < scalar(@pairs)) {
        my str $pair = trim($pairs[$i]);
        my int $eq_pos = index($pair, "=");
        if ($eq_pos > 0) {
            my str $cookie_name = substr($pair, 0, $eq_pos);
            if ($cookie_name eq $name) {
                return substr($pair, $eq_pos + 1, length($pair) - $eq_pos - 1);
            }
        }
        $i = $i + 1;
    }
    return "";
}

# Get all cookies as a hash
func Cannoli_Request_cookies(hash %req) hash {
    my hash %cookies = ();
    my str $cookie_header = ::get_header(%req, "Cookie");
    if (length($cookie_header) == 0) {
        return %cookies;
    }

    my array @pairs = split(";", $cookie_header);
    my int $i = 0;
    while ($i < scalar(@pairs)) {
        my str $pair = trim($pairs[$i]);
        my int $eq_pos = index($pair, "=");
        if ($eq_pos > 0) {
            my str $name = substr($pair, 0, $eq_pos);
            my str $value = substr($pair, $eq_pos + 1, length($pair) - $eq_pos - 1);
            $cookies{$name} = $value;
        }
        $i = $i + 1;
    }
    return %cookies;
}

# Get the User-Agent header
func Cannoli_Request_user_agent(hash %req) str {
    return ::get_header(%req, "User-Agent");
}

# Get the Referer header
func Cannoli_Request_referer(hash %req) str {
    return ::get_header(%req, "Referer");
}

# Get the Host header
func Cannoli_Request_host(hash %req) str {
    return ::get_header(%req, "Host");
}

# Check if request accepts JSON
func Cannoli_Request_accepts_json(hash %req) int {
    my str $accept = ::get_header(%req, "Accept");
    if (index($accept, "application/json") >= 0) {
        return 1;
    }
    if (index($accept, "*/*") >= 0) {
        return 1;
    }
    return 0;
}

# Check if request is AJAX/XHR
func Cannoli_Request_is_ajax(hash %req) int {
    my str $xhr = ::get_header(%req, "X-Requested-With");
    return $xhr eq "XMLHttpRequest";
}

# Check if a parameter exists
func Cannoli_Request_has_param(hash %req, str $name) int {
    my scalar $params = $req{"params"};
    return exists(%{$params}, $name);
}

# ============================================================
# Multipart Form Data Parsing (File Uploads)
# ============================================================

# Extract boundary from Content-Type header
# Content-Type: multipart/form-data; boundary=----WebKitFormBoundary...
func Cannoli_Request_extract_boundary(str $content_type) str {
    # Check if multipart
    if (index($content_type, "multipart/form-data") < 0) {
        return "";
    }

    # Find boundary parameter
    my int $bound_pos = index($content_type, "boundary=");
    if ($bound_pos < 0) {
        return "";
    }

    # Extract boundary value (after "boundary=")
    my str $boundary = substr($content_type, $bound_pos + 9, length($content_type) - $bound_pos - 9);

    # Remove quotes if present
    if (length($boundary) > 0 && substr($boundary, 0, 1) eq "\"") {
        $boundary = substr($boundary, 1, length($boundary) - 1);
        my int $quote_end = index($boundary, "\"");
        if ($quote_end >= 0) {
            $boundary = substr($boundary, 0, $quote_end);
        }
    }

    # Remove trailing semicolon or whitespace
    my int $semi_pos = index($boundary, ";");
    if ($semi_pos >= 0) {
        $boundary = substr($boundary, 0, $semi_pos);
    }

    return $boundary;
}

# Extract a parameter value from Content-Disposition header
# e.g., form-data; name="fieldname"; filename="file.txt"
func Cannoli_Request_extract_disposition_param(str $header, str $param_name) str {
    my str $search = $param_name . "=\"";
    my int $pos = index($header, $search);
    if ($pos < 0) {
        # Try without quotes
        $search = $param_name . "=";
        $pos = index($header, $search);
        if ($pos < 0) {
            return "";
        }
        # Extract unquoted value (until ; or end)
        my str $value = substr($header, $pos + length($search), length($header) - $pos - length($search));
        my int $end_pos = index($value, ";");
        if ($end_pos >= 0) {
            $value = substr($value, 0, $end_pos);
        }
        return $value;
    }

    # Extract quoted value
    my str $rest = substr($header, $pos + length($search), length($header) - $pos - length($search));
    my int $quote_end = index($rest, "\"");
    if ($quote_end < 0) {
        return $rest;
    }
    return substr($rest, 0, $quote_end);
}

# Parse a single multipart part
# Returns hash with: name, filename, content_type, content, size
func Cannoli_Request_parse_multipart_part(str $part) hash {
    my hash %result = ();
    $result{"name"} = "";
    $result{"filename"} = "";
    $result{"content_type"} = "text/plain";
    $result{"content"} = "";
    $result{"size"} = 0;

    # Split headers from content (blank line separator)
    my int $split_pos = index($part, "\r\n\r\n");
    if ($split_pos < 0) {
        # Try just \n\n
        $split_pos = index($part, "\n\n");
        if ($split_pos < 0) {
            return %result;
        }
        my str $content = substr($part, $split_pos + 2, length($part) - $split_pos - 2);
        $result{"content"} = $content;
        $result{"size"} = length($content);
        # Note: headers not parsed in \n\n case (simplified handling)
    } else {
        my str $headers_section = substr($part, 0, $split_pos);
        my str $content = substr($part, $split_pos + 4, length($part) - $split_pos - 4);
        $result{"content"} = $content;
        $result{"size"} = length($content);

        # Parse headers
        my array @header_lines = split("\r\n", $headers_section);
        my int $i = 0;
        while ($i < scalar(@header_lines)) {
            my str $line = $header_lines[$i];
            my str $line_lower = ::header_normalize($line);

            if (index($line_lower, "content-disposition:") == 0) {
                # Extract name and filename from Content-Disposition
                $result{"name"} = ::extract_disposition_param($line, "name");
                $result{"filename"} = ::extract_disposition_param($line, "filename");
            } elsif (index($line_lower, "content-type:") == 0) {
                # Extract content type (after "Content-Type: ")
                my int $colon_pos = index($line, ":");
                if ($colon_pos >= 0) {
                    my str $ct = substr($line, $colon_pos + 1, length($line) - $colon_pos - 1);
                    # Trim leading space
                    if (length($ct) > 0 && substr($ct, 0, 1) eq " ") {
                        $ct = substr($ct, 1, length($ct) - 1);
                    }
                    $result{"content_type"} = $ct;
                }
            }
            $i = $i + 1;
        }
    }

    return %result;
}

# Parse multipart form data body
# Returns hash with: params (hash ref), Cannoli::Request::files(hash ref)
func Cannoli_Request_parse_multipart(str $body, str $boundary) hash {
    my hash %result = ();
    my hash %params = ();
    my hash %files = ();

    # Parts are separated by --boundary
    my str $delim = "--" . $boundary;
    my str $end_delim = "--" . $boundary . "--";

    # Remove trailing boundary marker if present
    my int $end_pos = index($body, $end_delim);
    if ($end_pos >= 0) {
        $body = substr($body, 0, $end_pos);
    }

    # Split on delimiter
    my array @parts = split($delim, $body);
    my int $i = 0;

    while ($i < scalar(@parts)) {
        my str $part = $parts[$i];

        # Skip empty parts and preamble
        if (length($part) > 2) {
            # Remove leading \r\n if present
            if (substr($part, 0, 2) eq "\r\n") {
                $part = substr($part, 2, length($part) - 2);
            }
            # Remove trailing \r\n if present
            if (length($part) >= 2 && substr($part, length($part) - 2, 2) eq "\r\n") {
                $part = substr($part, 0, length($part) - 2);
            }

            if (length($part) > 0) {
                my hash %parsed = ::parse_multipart_part($part);
                my str $name = $parsed{"name"};
                my str $filename = $parsed{"filename"};

                if (length($name) > 0) {
                    if (length($filename) > 0) {
                        # This is a file upload
                        $files{$name} = \%parsed;
                    } else {
                        # This is a regular form field
                        $params{$name} = $parsed{"content"};
                    }
                }
            }
        }

        $i = $i + 1;
    }

    $result{"params"} = \%params;
    $result{"files"} = \%files;
    return %result;
}

# Get an uploaded file by field name
func Cannoli_Request_get_file(hash %req, str $name) scalar {
    if (!exists(%req, "files")) {
        return undef;
    }
    my scalar $files = $req{"files"};
    if (exists(%{$files}, $name)) {
        return $files->{$name};
    }
    return undef;
}

# Check if a file was uploaded with the given field name
func Cannoli_Request_has_file(hash %req, str $name) int {
    if (!exists(%req, "files")) {
        return 0;
    }
    my scalar $files = $req{"files"};
    return exists(%{$files}, $name);
}

# Get all uploaded files as a hash reference
func Cannoli_Request_files(hash %req) scalar {
    if (!exists(%req, "files")) {
        my hash %empty = ();
        return \%empty;
    }
    return $req{"files"};
}

# Get file content from a file hash
func Cannoli_Request_file_content(scalar $file) str {
    if (length($file) == 0) {
        return "";
    }
    return $file->{"content"};
}

# Get original filename from a file hash
func Cannoli_Request_file_name(scalar $file) str {
    if (length($file) == 0) {
        return "";
    }
    return $file->{"filename"};
}

# Get file size from a file hash
func Cannoli_Request_file_size(scalar $file) int {
    if (length($file) == 0) {
        return 0;
    }
    return $file->{"size"};
}

# Get content type from a file hash
func Cannoli_Request_file_type(scalar $file) str {
    if (length($file) == 0) {
        return "";
    }
    return $file->{"content_type"};
}

#
# JSON Body Parsing
#

# Check if request has JSON content type
func Cannoli_Request_is_json(hash %req) int {
    my str $ct = $req{"content_type"};
    if (index($ct, "application/json") >= 0) {
        return 1;
    }
    return 0;
}

# Parse JSON body - simple JSON parser
# Returns parsed structure or undef on error
func Cannoli_Request_parse_json_body(hash %req) scalar {
    if (::is_json(%req) == 0) {
        return undef;
    }
    my str $body = $req{"body"};
    if (length($body) == 0) {
        return undef;
    }
    return ::json_parse($body);
}

# Simple JSON parser
# Handles: objects, arrays, strings, numbers, true, false, null
func Cannoli_Request_json_parse(str $json) scalar {
    my int $pos = 0;
    my int $len = length($json);

    # Skip whitespace
    while ($pos < $len) {
        my str $ch = substr($json, $pos, 1);
        if ($ch ne " " && $ch ne "\t" && $ch ne "\n" && $ch ne "\r") {
            last;
        }
        $pos = $pos + 1;
    }

    if ($pos >= $len) {
        return undef;
    }

    my str $ch = substr($json, $pos, 1);

    # Object
    if ($ch eq "{") {
        return ::json_parse_object($json, $pos);
    }

    # Array
    if ($ch eq "[") {
        return ::json_parse_array($json, $pos);
    }

    # String
    if ($ch eq "\"") {
        my scalar $result = ::json_parse_string($json, $pos);
        return $result->{"value"};
    }

    # Number, true, false, null
    return ::json_parse_value($json, $pos);
}

# Parse JSON object starting at pos, returns {value, end_pos}
func Cannoli_Request_json_parse_object(str $json, int $start) scalar {
    my hash %obj = ();
    my int $pos = $start + 1;  # Skip '{'
    my int $len = length($json);

    while ($pos < $len) {
        # Skip whitespace
        while ($pos < $len) {
            my str $ch = substr($json, $pos, 1);
            if ($ch ne " " && $ch ne "\t" && $ch ne "\n" && $ch ne "\r") {
                last;
            }
            $pos = $pos + 1;
        }

        if ($pos >= $len) { last; }

        my str $ch = substr($json, $pos, 1);

        # End of object
        if ($ch eq "}") {
            return \%obj;
        }

        # Expect string key
        if ($ch ne "\"") {
            return undef;
        }

        my scalar $key_result = ::json_parse_string($json, $pos);
        if (!defined($key_result)) { return undef; }
        my str $key = $key_result->{"value"};
        $pos = $key_result->{"end_pos"};

        # Skip whitespace and colon
        while ($pos < $len) {
            my str $c = substr($json, $pos, 1);
            if ($c ne " " && $c ne "\t" && $c ne "\n" && $c ne "\r") {
                last;
            }
            $pos = $pos + 1;
        }

        if ($pos >= $len || substr($json, $pos, 1) ne ":") {
            return undef;
        }
        $pos = $pos + 1;

        # Skip whitespace
        while ($pos < $len) {
            my str $c = substr($json, $pos, 1);
            if ($c ne " " && $c ne "\t" && $c ne "\n" && $c ne "\r") {
                last;
            }
            $pos = $pos + 1;
        }

        # Parse value
        my scalar $val_result = ::json_parse_any($json, $pos);
        if (!defined($val_result)) { return undef; }
        $obj{$key} = $val_result->{"value"};
        $pos = $val_result->{"end_pos"};

        # Skip whitespace
        while ($pos < $len) {
            my str $c = substr($json, $pos, 1);
            if ($c ne " " && $c ne "\t" && $c ne "\n" && $c ne "\r") {
                last;
            }
            $pos = $pos + 1;
        }

        if ($pos >= $len) { last; }

        $ch = substr($json, $pos, 1);
        if ($ch eq "}") {
            return \%obj;
        }
        if ($ch eq ",") {
            $pos = $pos + 1;
        }
    }

    return \%obj;
}

# Parse JSON array starting at pos
func Cannoli_Request_json_parse_array(str $json, int $start) scalar {
    my array @arr = ();
    my int $pos = $start + 1;  # Skip '['
    my int $len = length($json);

    while ($pos < $len) {
        # Skip whitespace
        while ($pos < $len) {
            my str $ch = substr($json, $pos, 1);
            if ($ch ne " " && $ch ne "\t" && $ch ne "\n" && $ch ne "\r") {
                last;
            }
            $pos = $pos + 1;
        }

        if ($pos >= $len) { last; }

        my str $ch = substr($json, $pos, 1);

        # End of array
        if ($ch eq "]") {
            return \@arr;
        }

        # Parse value
        my scalar $val_result = ::json_parse_any($json, $pos);
        if (!defined($val_result)) { return undef; }
        push(@arr, $val_result->{"value"});
        $pos = $val_result->{"end_pos"};

        # Skip whitespace
        while ($pos < $len) {
            my str $c = substr($json, $pos, 1);
            if ($c ne " " && $c ne "\t" && $c ne "\n" && $c ne "\r") {
                last;
            }
            $pos = $pos + 1;
        }

        if ($pos >= $len) { last; }

        $ch = substr($json, $pos, 1);
        if ($ch eq "]") {
            return \@arr;
        }
        if ($ch eq ",") {
            $pos = $pos + 1;
        }
    }

    return \@arr;
}

# Parse JSON string starting at pos, returns {value, end_pos}
func Cannoli_Request_json_parse_string(str $json, int $start) scalar {
    my str $result = "";
    my int $pos = $start + 1;  # Skip opening quote
    my int $len = length($json);

    while ($pos < $len) {
        my str $ch = substr($json, $pos, 1);

        if ($ch eq "\"") {
            my hash %ret = ();
            $ret{"value"} = $result;
            $ret{"end_pos"} = $pos + 1;
            return \%ret;
        }

        if ($ch eq "\\") {
            $pos = $pos + 1;
            if ($pos >= $len) { last; }
            my str $esc = substr($json, $pos, 1);
            if ($esc eq "n") { $result = $result . "\n"; }
            elsif ($esc eq "r") { $result = $result . "\r"; }
            elsif ($esc eq "t") { $result = $result . "\t"; }
            elsif ($esc eq "\"") { $result = $result . "\""; }
            elsif ($esc eq "\\") { $result = $result . "\\"; }
            elsif ($esc eq "/") { $result = $result . "/"; }
            else { $result = $result . $esc; }
        } else {
            $result = $result . $ch;
        }

        $pos = $pos + 1;
    }

    my hash %ret = ();
    $ret{"value"} = $result;
    $ret{"end_pos"} = $pos;
    return \%ret;
}

# Parse any JSON value, returns {value, end_pos}
func Cannoli_Request_json_parse_any(str $json, int $start) scalar {
    my int $pos = $start;
    my int $len = length($json);

    # Skip whitespace
    while ($pos < $len) {
        my str $ch = substr($json, $pos, 1);
        if ($ch ne " " && $ch ne "\t" && $ch ne "\n" && $ch ne "\r") {
            last;
        }
        $pos = $pos + 1;
    }

    if ($pos >= $len) {
        return undef;
    }

    my str $ch = substr($json, $pos, 1);

    # Object
    if ($ch eq "{") {
        my scalar $obj = ::json_parse_object($json, $pos);
        # Find end position by scanning past the object
        my int $end = ::json_find_end($json, $pos, "{", "}");
        my hash %ret = ();
        $ret{"value"} = $obj;
        $ret{"end_pos"} = $end;
        return \%ret;
    }

    # Array
    if ($ch eq "[") {
        my scalar $arr = ::json_parse_array($json, $pos);
        my int $end = ::json_find_end($json, $pos, "[", "]");
        my hash %ret = ();
        $ret{"value"} = $arr;
        $ret{"end_pos"} = $end;
        return \%ret;
    }

    # String
    if ($ch eq "\"") {
        return ::json_parse_string($json, $pos);
    }

    # true, false, null, or number
    if (substr($json, $pos, 4) eq "true") {
        my hash %ret = ();
        $ret{"value"} = 1;
        $ret{"end_pos"} = $pos + 4;
        return \%ret;
    }
    if (substr($json, $pos, 5) eq "false") {
        my hash %ret = ();
        $ret{"value"} = 0;
        $ret{"end_pos"} = $pos + 5;
        return \%ret;
    }
    if (substr($json, $pos, 4) eq "null") {
        my hash %ret = ();
        $ret{"value"} = undef;
        $ret{"end_pos"} = $pos + 4;
        return \%ret;
    }

    # Number
    my str $num_str = "";
    while ($pos < $len) {
        $ch = substr($json, $pos, 1);
        if ($ch eq "-" || $ch eq "+" || $ch eq "." || ($ch ge "0" && $ch le "9") || $ch eq "e" || $ch eq "E") {
            $num_str = $num_str . $ch;
            $pos = $pos + 1;
        } else {
            last;
        }
    }

    my hash %ret = ();
    if (index($num_str, ".") >= 0) {
        $ret{"value"} = 0.0 + $num_str;  # Convert to float
    } else {
        $ret{"value"} = 0 + $num_str;  # Convert to int
    }
    $ret{"end_pos"} = $pos;
    return \%ret;
}

# Find matching end bracket/brace
func Cannoli_Request_json_find_end(str $json, int $start, str $open, str $close) int {
    my int $depth = 0;
    my int $pos = $start;
    my int $len = length($json);
    my int $in_string = 0;

    while ($pos < $len) {
        my str $ch = substr($json, $pos, 1);

        if ($in_string == 1) {
            if ($ch eq "\\") {
                $pos = $pos + 2;
                next;
            }
            if ($ch eq "\"") {
                $in_string = 0;
            }
        } else {
            if ($ch eq "\"") {
                $in_string = 1;
            } elsif ($ch eq $open) {
                $depth = $depth + 1;
            } elsif ($ch eq $close) {
                $depth = $depth - 1;
                if ($depth == 0) {
                    return $pos + 1;
                }
            }
        }

        $pos = $pos + 1;
    }

    return $len;
}

# Parse JSON value (for top-level primitives)
func Cannoli_Request_json_parse_value(str $json, int $pos) scalar {
    my scalar $result = ::json_parse_any($json, $pos);
    if (defined($result)) {
        return $result->{"value"};
    }
    return undef;
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Log;


# cannoli/src/log.strada - Logging support
#
# Provides error and access logging with configurable output
# Access log format: Combined Log Format (Apache/nginx compatible)
#   remote_ip - - [timestamp] "method path protocol" status size "referer" "user_agent"
#
# Error log format:
#   [timestamp] [level] message

# Log levels
my int $LOG_ERROR = 1;
my int $LOG_WARN = 2;
my int $LOG_INFO = 3;
my int $LOG_DEBUG = 4;

# Global log settings
my scalar $g_error_log_fd = undef;
my scalar $g_access_log_fd = undef;
my str $g_error_log_file = "";
my str $g_access_log_file = "";
my int $g_log_level = 3;  # Default to INFO
my int $g_log_to_stderr = 1;
my int $g_log_to_stdout = 0;  # For access log to stdout
my str $g_log_format = "%m %p %s %b %Tms";  # Default console format

# Initialize logging
func Cannoli_Log_init(hash %config) void {
    $g_error_log_file = Cannoli::Config::get_str(%config, "log.error_file", "");
    $g_access_log_file = Cannoli::Config::get_str(%config, "log.access_file", "");
    my str $level_str = Cannoli::Config::get_str(%config, "log.level", "info");

    # Set log level
    if ($level_str eq "error") {
        $g_log_level = 1;
    } elsif ($level_str eq "warn") {
        $g_log_level = 2;
    } elsif ($level_str eq "info") {
        $g_log_level = 3;
    } elsif ($level_str eq "debug") {
        $g_log_level = 4;
    }

    # Check if logging to stdout is enabled (--debug flag)
    my str $to_stdout = Cannoli::Config::get_str(%config, "log.to_stdout", "0");
    if ($to_stdout eq "1") {
        $g_log_to_stdout = 1;
        $g_log_to_stderr = 1;
    }

    # Get log format string
    $g_log_format = Cannoli::Config::get_str(%config, "log.format", "%m %p %s %b %Tms");

    # Test open error log
    if (length($g_error_log_file) > 0) {
        my scalar $fh = sys::open($g_error_log_file, "a");
        if (defined($fh)) {
            sys::close($fh);
        } else {
            say("Warning: Could not open error log: " . $g_error_log_file);
            $g_error_log_file = "";
        }
    }

    # Test open access log
    if (length($g_access_log_file) > 0) {
        my scalar $fh = sys::open($g_access_log_file, "a");
        if (defined($fh)) {
            sys::close($fh);
        } else {
            say("Warning: Could not open access log: " . $g_access_log_file);
            $g_access_log_file = "";
        }
    }
}

# Close log files (no-op, we open/close per write for safety in forked processes)
func Cannoli_Log_close() void {
    # Nothing to do - files are opened/closed per write
}

# Get current timestamp in log format
func Cannoli_Log_timestamp() str {
    my int $now = sys::time();
    # Format: [DD/Mon/YYYY:HH:MM:SS +0000]
    # For now, use Unix timestamp as we don't have strftime
    return "[" . $now . "]";
}

# Get timestamp for access log
func Cannoli_Log_access_timestamp() str {
    my int $now = sys::time();
    return "[" . $now . "]";
}

# Write to error log
func Cannoli_Log_write_error(str $level, str $message) void {
    my str $timestamp = ::timestamp();
    my str $line = $timestamp . " [" . $level . "] " . $message . "\n";

    if (length($g_error_log_file) > 0) {
        my scalar $fh = sys::open($g_error_log_file, "a");
        if (defined($fh)) {
            sys::fwrite($fh, $line);
            sys::close($fh);
        }
    }

    if ($g_log_to_stderr == 1) {
        print($line);
    }
}

# Log error message
func Cannoli_Log_error(str $message) void {
    if ($g_log_level >= 1) {
        ::write_error("ERROR", $message);
    }
}

# Log warning message
func Cannoli_Log_warn(str $message) void {
    if ($g_log_level >= 2) {
        ::write_error("WARN", $message);
    }
}

# Log info message
func Cannoli_Log_info(str $message) void {
    if ($g_log_level >= 3) {
        ::write_error("INFO", $message);
    }
}

# Log debug message
func Cannoli_Log_debug(str $message) void {
    if ($g_log_level >= 4) {
        ::write_error("DEBUG", $message);
    }
}

# Format a log line using the format string
# Placeholders: %t=timestamp %m=method %p=path %s=status %b=bytes %T=time_ms
#               %r=referer %a=user_agent %i=remote_ip %P=protocol
func Cannoli_Log_format_line(str $format, str $remote_ip, str $method, str $path, str $protocol, int $status, int $size, str $referer, str $user_agent, int $time_ms) str {
    my str $result = "";
    my str $timestamp = "" . sys::time();
    my str $status_str = "" . $status;
    my str $size_str = "" . $size;
    my str $time_str = "" . $time_ms;

    my int $len = length($format);
    my int $i = 0;

    while ($i < $len) {
        my str $ch = substr($format, $i, 1);

        if ($ch eq "%" && $i + 1 < $len) {
            my str $spec = substr($format, $i + 1, 1);

            if ($spec eq "T") {
                $result = $result . $time_str;
                $i = $i + 2;
            } elsif ($spec eq "t") {
                $result = $result . $timestamp;
                $i = $i + 2;
            } elsif ($spec eq "m") {
                $result = $result . $method;
                $i = $i + 2;
            } elsif ($spec eq "p") {
                $result = $result . $path;
                $i = $i + 2;
            } elsif ($spec eq "s") {
                $result = $result . $status_str;
                $i = $i + 2;
            } elsif ($spec eq "b") {
                $result = $result . $size_str;
                $i = $i + 2;
            } elsif ($spec eq "r") {
                $result = $result . $referer;
                $i = $i + 2;
            } elsif ($spec eq "a") {
                $result = $result . $user_agent;
                $i = $i + 2;
            } elsif ($spec eq "i") {
                $result = $result . $remote_ip;
                $i = $i + 2;
            } elsif ($spec eq "P") {
                $result = $result . $protocol;
                $i = $i + 2;
            } elsif ($spec eq "%") {
                $result = $result . "%";
                $i = $i + 2;
            } else {
                # Unknown placeholder, keep as-is
                $result = $result . $ch;
                $i = $i + 1;
            }
        } else {
            $result = $result . $ch;
            $i = $i + 1;
        }
    }

    return $result;
}

# Log access in Combined Log Format
# remote_ip - - [timestamp] "method path protocol" status size "referer" "user_agent"
func Cannoli_Log_access(str $remote_ip, str $method, str $path, str $protocol, int $status, int $size, str $referer, str $user_agent, int $time_ms) void {
    my str $timestamp = ::access_timestamp();

    # Escape or default values
    if (length($referer) == 0) {
        $referer = "-";
    }
    if (length($user_agent) == 0) {
        $user_agent = "-";
    }

    # Write to file in Combined Log Format (with timing)
    if (length($g_access_log_file) > 0) {
        my str $line = $remote_ip . " - - " . $timestamp . " \"";
        $line = $line . $method . " " . $path . " " . $protocol . "\" ";
        $line = $line . $status . " " . $size . " ";
        $line = $line . "\"" . $referer . "\" \"" . $user_agent . "\" " . $time_ms . "ms\n";

        my scalar $fh = sys::open($g_access_log_file, "a");
        if (defined($fh)) {
            sys::fwrite($fh, $line);
            sys::close($fh);
        }
    }

    # Log to stdout if --debug flag or debug level, using custom format
    if ($g_log_to_stdout == 1 || $g_log_level >= 4) {
        my str $console_line = ::format_line($g_log_format, $remote_ip, $method, $path, $protocol, $status, $size, $referer, $user_agent, $time_ms);
        say($console_line);
    }
}

# Convenience function for logging a request with timing
func Cannoli_Log_request_timed(hash %req, hash %res, int $time_ms) void {
    my str $remote_ip = "127.0.0.1";  # TODO: Get from socket
    my str $method = $req{"method"};
    my str $path = $req{"path"};
    my str $protocol = "HTTP/1.1";
    my int $status = $res{"status"};
    my str $body = $res{"body"};
    my int $size = length($body);
    my str $referer = Cannoli::Request::get_header(%req, "Referer");
    my str $user_agent = Cannoli::Request::get_header(%req, "User-Agent");

    ::access($remote_ip, $method, $path, $protocol, $status, $size, $referer, $user_agent, $time_ms);
}

# Convenience function for logging a Cannoli::Log::request(backwards compatible, 0ms timing)
func Cannoli_Log_request(hash %req, hash %res) void {
    ::request_timed(%req, %res, 0);
}

# ============================================================
# Log Rotation
# ============================================================

# Global rotation settings
my int $g_rotate_size = 10485760;  # 10MB default
my int $g_rotate_keep = 5;         # Keep 5 old files

# Configure log rotation
func Cannoli_Log_set_rotation(int $max_size, int $keep_files) void {
    if ($max_size > 0) {
        $g_rotate_size = $max_size;
    }
    if ($keep_files > 0) {
        $g_rotate_keep = $keep_files;
    }
}

# Get file size (returns 0 if file doesn't exist)
func Cannoli_Log_file_size(str $path) int {
    if (sys::is_file($path) == 0) {
        return 0;
    }
    my str $content = slurp($path);
    return length($content);
}

# Rotate a log file
# Renames: file -> file.1, file.1 -> file.2, etc.
func Cannoli_Log_rotate(str $path) void {
    if (sys::is_file($path) == 0) {
        return;
    }

    # Check if file needs rotation
    my int $size = ::file_size($path);
    if ($size < $g_rotate_size) {
        return;
    }

    # Rotate existing numbered files (work backwards)
    my int $i = $g_rotate_keep - 1;
    while ($i >= 1) {
        my str $old_path = $path . "." . $i;
        my str $new_path = $path . "." . ($i + 1);

        if (sys::is_file($old_path) == 1) {
            if ($i == $g_rotate_keep - 1) {
                # Delete oldest file
                sys::unlink($old_path);
            } else {
                # Rename to next number
                sys::rename($old_path, $new_path);
            }
        }
        $i = $i - 1;
    }

    # Rename current file to .1
    my str $rotated_path = $path . ".1";
    sys::rename($path, $rotated_path);
}

# Check and rotate all log files if needed
func Cannoli_Log_check_rotation() void {
    if (length($g_error_log_file) > 0) {
        ::rotate($g_error_log_file);
    }
    if (length($g_access_log_file) > 0) {
        ::rotate($g_access_log_file);
    }
}

# ============================================================
# JSON Structured Logging
# ============================================================

# Global JSON log flag
my int $g_json_log = 0;

# Enable/disable JSON logging
func Cannoli_Log_set_json_format(int $enabled) void {
    $g_json_log = $enabled;
}

# Log access in JSON format
func Cannoli_Log_access_json(str $remote_ip, str $method, str $path, str $protocol, int $status, int $size, str $referer, str $user_agent, int $time_ms) str {
    my str $timestamp = "" . sys::time();

    my str $json = "{";
    $json = $json . "\"timestamp\":" . $timestamp;
    $json = $json . ",\"type\":\"access\"";
    $json = $json . ",\"remote_ip\":\"" . ::json_escape($remote_ip) . "\"";
    $json = $json . ",\"method\":\"" . $method . "\"";
    $json = $json . ",\"path\":\"" . ::json_escape($path) . "\"";
    $json = $json . ",\"protocol\":\"" . $protocol . "\"";
    $json = $json . ",\"status\":" . $status;
    $json = $json . ",\"size\":" . $size;
    $json = $json . ",\"time_ms\":" . $time_ms;

    if (length($referer) > 0 && $referer ne "-") {
        $json = $json . ",\"referer\":\"" . ::json_escape($referer) . "\"";
    }
    if (length($user_agent) > 0 && $user_agent ne "-") {
        $json = $json . ",\"user_agent\":\"" . ::json_escape($user_agent) . "\"";
    }

    $json = $json . "}";
    return $json;
}

# Log error in JSON format
func Cannoli_Log_error_json(str $level, str $message) str {
    my str $timestamp = "" . sys::time();

    my str $json = "{";
    $json = $json . "\"timestamp\":" . $timestamp;
    $json = $json . ",\"type\":\"error\"";
    $json = $json . ",\"level\":\"" . $level . "\"";
    $json = $json . ",\"message\":\"" . ::json_escape($message) . "\"";
    $json = $json . "}";
    return $json;
}

# JSON string escape helper
func Cannoli_Log_json_escape(str $s) str {
    my str $result = "";
    my int $len = length($s);
    my int $i = 0;

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        my int $code = ord($ch);

        if ($ch eq "\"") {
            $result = $result . "\\\"";
        } elsif ($ch eq "\\") {
            $result = $result . "\\\\";
        } elsif ($code == 10) {
            $result = $result . "\\n";
        } elsif ($code == 13) {
            $result = $result . "\\r";
        } elsif ($code == 9) {
            $result = $result . "\\t";
        } else {
            $result = $result . $ch;
        }
        $i = $i + 1;
    }

    return $result;
}

# Enhanced write to error log with optional JSON format
func Cannoli_Log_write_error_enhanced(str $level, str $message) void {
    my str $line = "";

    if ($g_json_log == 1) {
        $line = ::error_json($level, $message) . "\n";
    } else {
        my str $timestamp = ::timestamp();
        $line = $timestamp . " [" . $level . "] " . $message . "\n";
    }

    if (length($g_error_log_file) > 0) {
        ::check_rotation();  # Check rotation before writing
        my scalar $fh = sys::open($g_error_log_file, "a");
        if (defined($fh)) {
            sys::fwrite($fh, $line);
            sys::close($fh);
        }
    }

    if ($g_log_to_stderr == 1) {
        print($line);
    }
}

# Enhanced access log with optional JSON format
func Cannoli_Log_access_enhanced(str $remote_ip, str $method, str $path, str $protocol, int $status, int $size, str $referer, str $user_agent, int $time_ms) void {
    # Escape or default values
    if (length($referer) == 0) {
        $referer = "-";
    }
    if (length($user_agent) == 0) {
        $user_agent = "-";
    }

    # Write to file
    if (length($g_access_log_file) > 0) {
        ::check_rotation();  # Check rotation before writing

        my str $line = "";
        if ($g_json_log == 1) {
            $line = ::access_json($remote_ip, $method, $path, $protocol, $status, $size, $referer, $user_agent, $time_ms) . "\n";
        } else {
            my str $timestamp = ::access_timestamp();
            $line = $remote_ip . " - - " . $timestamp . " \"";
            $line = $line . $method . " " . $path . " " . $protocol . "\" ";
            $line = $line . $status . " " . $size . " ";
            $line = $line . "\"" . $referer . "\" \"" . $user_agent . "\" " . $time_ms . "ms\n";
        }

        my scalar $fh = sys::open($g_access_log_file, "a");
        if (defined($fh)) {
            sys::fwrite($fh, $line);
            sys::close($fh);
        }
    }

    # Log to stdout if --debug flag or debug level
    if ($g_log_to_stdout == 1 || $g_log_level >= 4) {
        my str $console_line = "";
        if ($g_json_log == 1) {
            $console_line = ::access_json($remote_ip, $method, $path, $protocol, $status, $size, $referer, $user_agent, $time_ms);
        } else {
            $console_line = ::format_line($g_log_format, $remote_ip, $method, $path, $protocol, $status, $size, $referer, $user_agent, $time_ms);
        }
        say($console_line);
    }
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Response;


# cannoli/src/response.strada - HTTP Response building
#
# Build and send HTTP responses

# HTTP status code messages
func Cannoli_Response_status_message(int $code) str {
    if ($code == 200) { return "OK"; }
    if ($code == 201) { return "Created"; }
    if ($code == 204) { return "No Content"; }
    if ($code == 301) { return "Moved Permanently"; }
    if ($code == 302) { return "Found"; }
    if ($code == 304) { return "Not Modified"; }
    if ($code == 400) { return "Bad Request"; }
    if ($code == 401) { return "Unauthorized"; }
    if ($code == 403) { return "Forbidden"; }
    if ($code == 404) { return "Not Found"; }
    if ($code == 405) { return "Method Not Allowed"; }
    if ($code == 413) { return "Payload Too Large"; }
    if ($code == 431) { return "Request Header Fields Too Large"; }
    if ($code == 500) { return "Internal Server Error"; }
    if ($code == 502) { return "Bad Gateway"; }
    if ($code == 503) { return "Service Unavailable"; }
    return "Unknown";
}

# Create a new response object
func Cannoli_Response_new() hash {
    my hash %res = ();

    $res{"status"} = 200;
    $res{"headers"} = {};
    $res{"body"} = "";
    $res{"sent"} = 0;

    # Set default headers
    my scalar $headers = $res{"headers"};
    $headers->{"Content-Type"} = "text/html; charset=utf-8";
    $headers->{"Server"} = "Cannoli/1.0";
    $headers->{"Connection"} = "close";

    return %res;
}

# Set status code
func Cannoli_Response_status(hash %res, int $code) void {
    $res{"status"} = $code;
}

# Set a header
func Cannoli_Response_header(hash %res, str $name, str $value) void {
    my scalar $headers = $res{"headers"};
    $headers->{$name} = $value;
}

# Set content type
func Cannoli_Response_content_type(hash %res, str $type) void {
    ::header(%res, "Content-Type", $type);
}

# Set body content
func Cannoli_Response_body(hash %res, str $content) void {
    $res{"body"} = $content;
}

# Append to body
func Cannoli_Response_write(hash %res, str $content) void {
    $res{"body"} = $res{"body"} . $content;
}

# Build the complete HTTP response string
func Cannoli_Response_build(hash %res) str {
    my int $status_code = $res{"status"};
    my str $status_msg = ::status_message($status_code);
    my str $body_content = $res{"body"};
    my scalar $headers = $res{"headers"};

    # Set content length
    $headers->{"Content-Length"} = "" . length($body_content);

    # Build status line
    my str $response = "HTTP/1.1 " . $status_code . " " . $status_msg . "\r\n";

    # Add Cannoli::Response::headers(skip empty values)
    my array @header_names = keys(%{$headers});
    my int $i = 0;
    while ($i < scalar(@header_names)) {
        my str $name = $header_names[$i];
        my str $value = $headers->{$name};
        if (length($value) > 0) {
            $response = $response . $name . ": " . $value . "\r\n";
        }
        $i = $i + 1;
    }

    # End headers, add body
    $response = $response . "\r\n" . $body_content;

    return $response;
}

# Send response to a file descriptor
func Cannoli_Response_send_to(hash %res, int $fd) int {
    if ($res{"sent"} == 1) {
        return 0;
    }

    my str $data = ::build(%res);
    my int $written = sys::write_fd($fd, $data);
    $res{"sent"} = 1;

    return $written;
}

# Convenience: Create and return a simple text response
func Cannoli_Response_text(int $status, str $content) hash {
    my hash %res = ::new();
    ::status(%res, $status);
    ::content_type(%res, "text/plain; charset=utf-8");
    ::body(%res, $content);
    return %res;
}

# Convenience: Create and return an HTML response
func Cannoli_Response_html(int $status, str $content) hash {
    my hash %res = ::new();
    ::status(%res, $status);
    ::content_type(%res, "text/html; charset=utf-8");
    ::body(%res, $content);
    return %res;
}

# Convenience: Create and return a JSON response
func Cannoli_Response_json(int $status, str $content) hash {
    my hash %res = ::new();
    ::status(%res, $status);
    ::content_type(%res, "application/json");
    ::body(%res, $content);
    return %res;
}

# Convenience: Redirect response
func Cannoli_Response_redirect(str $url, int $permanent) hash {
    my hash %res = ::new();

    if ($permanent == 1) {
        ::status(%res, 301);
    } else {
        ::status(%res, 302);
    }

    ::header(%res, "Location", $url);
    ::body(%res, "");
    return %res;
}

# HTML escape helper
func Cannoli_Response_html_escape(str $s) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        if ($ch eq "<") {
            $result = $result . "&lt;";
        } elsif ($ch eq ">") {
            $result = $result . "&gt;";
        } elsif ($ch eq "&") {
            $result = $result . "&amp;";
        } elsif ($ch eq "\"") {
            $result = $result . "&quot;";
        } else {
            $result = $result . $ch;
        }

        $i = $i + 1;
    }

    return $result;
}

# Error page responses
func Cannoli_Response_error_page(int $code, str $message) hash {
    my str $status_msg = ::status_message($code);
    my str $html_content = "<!DOCTYPE html>\n";
    $html_content = $html_content . "<html>\n<head>\n";
    $html_content = $html_content . "<title>" . $code . " " . $status_msg . "</title>\n";
    $html_content = $html_content . "<style>\n";
    $html_content = $html_content . "body { font-family: sans-serif; text-align: center; padding: 50px; }\n";
    $html_content = $html_content . "h1 { color: #333; }\n";
    $html_content = $html_content . "p { color: #666; }\n";
    $html_content = $html_content . ".code { font-size: 72px; color: #999; }\n";
    $html_content = $html_content . "</style>\n</head>\n<body>\n";
    $html_content = $html_content . "<div class=\"code\">" . $code . "</div>\n";
    $html_content = $html_content . "<h1>" . $status_msg . "</h1>\n";

    if (length($message) > 0) {
        $html_content = $html_content . "<p>" . ::html_escape($message) . "</p>\n";
    }

    $html_content = $html_content . "<hr>\n<p><em>Cannoli/1.0</em></p>\n";
    $html_content = $html_content . "</body>\n</html>\n";

    return ::html($code, $html_content);
}

# Not found (404)
func Cannoli_Response_not_found() hash {
    return ::error_page(404, "The requested resource was not found.");
}

# Method not allowed (405)
func Cannoli_Response_method_not_allowed(str $allowed) hash {
    my hash %res = ::error_page(405, "Method not allowed.");
    ::header(%res, "Allow", $allowed);
    return %res;
}

# Internal server error (500)
func Cannoli_Response_internal_error(str $message) hash {
    return ::error_page(500, $message);
}

# Payload too large (413)
func Cannoli_Response_payload_too_large(int $max_size) hash {
    my str $msg = "Request body exceeds maximum allowed size of " . $max_size . " bytes.";
    return ::error_page(413, $msg);
}

# Request header fields too large (431)
func Cannoli_Response_header_too_large(int $max_size) hash {
    my str $msg = "Request headers exceed maximum allowed size of " . $max_size . " bytes.";
    return ::error_page(431, $msg);
}

# Set multiple headers from a hash
func Cannoli_Response_headers(hash %res, hash %hdrs) void {
    my array @names = keys(%hdrs);
    my int $i = 0;
    while ($i < scalar(@names)) {
        my str $name = $names[$i];
        ::header(%res, $name, $hdrs{$name});
        $i = $i + 1;
    }
}

# Get all response headers as a hash reference
func Cannoli_Response_get_headers(hash %res) scalar {
    return $res{"headers"};
}

# Check if a response header is set
func Cannoli_Response_has_header(hash %res, str $name) int {
    my scalar $headers = $res{"headers"};
    return exists(%{$headers}, $name);
}

# Get a response header value
func Cannoli_Response_get_header(hash %res, str $name) str {
    my scalar $headers = $res{"headers"};
    if (exists(%{$headers}, $name)) {
        return $headers->{$name};
    }
    return "";
}

# Remove a response Cannoli::Response::header(sets to empty string)
# Note: To fully remove, rebuild headers hash without the key
func Cannoli_Response_remove_header(hash %res, str $name) void {
    my scalar $headers = $res{"headers"};
    # Since Strada doesn't have delete, we set to empty
    # The build function will skip empty headers
    $headers->{$name} = "";
}

# Convenience: Text response with custom headers
func Cannoli_Response_text_with_headers(int $status, str $content, hash %hdrs) hash {
    my hash %res = ::text($status, $content);
    ::headers(%res, %hdrs);
    return %res;
}

# Convenience: HTML response with custom headers
func Cannoli_Response_html_with_headers(int $status, str $content, hash %hdrs) hash {
    my hash %res = ::html($status, $content);
    ::headers(%res, %hdrs);
    return %res;
}

# Convenience: JSON response with custom headers
func Cannoli_Response_json_with_headers(int $status, str $content, hash %hdrs) hash {
    my hash %res = ::json($status, $content);
    ::headers(%res, %hdrs);
    return %res;
}

# Set Cache-Control header
func Cannoli_Response_cache(hash %res, int $max_age) void {
    if ($max_age <= 0) {
        ::header(%res, "Cache-Control", "no-cache, no-store, must-revalidate");
        ::header(%res, "Pragma", "no-cache");
        ::header(%res, "Expires", "0");
    } else {
        ::header(%res, "Cache-Control", "public, max-age=" . $max_age);
    }
}

# Set CORS headers for cross-origin requests
func Cannoli_Response_cors(hash %res, str $origin) void {
    if (length($origin) == 0) {
        $origin = "*";
    }
    ::header(%res, "Access-Control-Allow-Origin", $origin);
    ::header(%res, "Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
    ::header(%res, "Access-Control-Allow-Headers", "Content-Type, Authorization");
}

# Set cookie header
func Cannoli_Response_set_cookie(hash %res, str $name, str $value, str $options) void {
    my str $cookie = $name . "=" . $value;
    if (length($options) > 0) {
        $cookie = $cookie . "; " . $options;
    }
    ::header(%res, "Set-Cookie", $cookie);
}

# ============================================================
# Chunked Transfer Encoding
# ============================================================

# Integer modulo operation (a mod b)
func Cannoli_Response_mod(int $a, int $b) int {
    my num $div = $a / $b;
    my int $floored = math::floor($div);
    return $a - ($floored * $b);
}

# Convert integer to lowercase hexadecimal string
func Cannoli_Response_to_hex(int $value) str {
    if ($value == 0) {
        return "0";
    }

    my str $result = "";
    my int $n = $value;

    while ($n > 0) {
        my int $digit = ::mod($n, 16);
        my str $ch = "";
        if ($digit < 10) {
            $ch = chr(48 + $digit);  # 0-9
        } else {
            $ch = chr(97 + $digit - 10);  # a-f
        }
        $result = $ch . $result;
        my num $div = $n / 16;
        $n = math::floor($div);
    }

    return $result;
}

# Build only the HTTP Cannoli::Response::headers(status line + headers + blank line)
# Used for chunked responses where body is sent separately
func Cannoli_Response_build_headers(hash %res) str {
    my int $status_code = $res{"status"};
    my str $status_msg = ::status_message($status_code);
    my scalar $headers = $res{"headers"};

    # Build status line
    my str $response = "HTTP/1.1 " . $status_code . " " . $status_msg . "\r\n";

    # Add Cannoli::Response::headers(skip empty values and Content-Length for chunked)
    my array @header_names = keys(%{$headers});
    my int $i = 0;
    while ($i < scalar(@header_names)) {
        my str $name = $header_names[$i];
        my str $value = $headers->{$name};
        # Skip Content-Length for chunked (it's not allowed)
        if (length($value) > 0 && $name ne "Content-Length") {
            $response = $response . $name . ": " . $value . "\r\n";
        }
        $i = $i + 1;
    }

    # End headers with blank line
    $response = $response . "\r\n";

    return $response;
}

# Initialize chunked response and send headers
# Sets Transfer-Encoding: chunked and sends headers immediately
# Returns the modified response hash
func Cannoli_Response_chunked_start(hash %res, int $fd) hash {
    # Set chunked encoding header
    ::header(%res, "Transfer-Encoding", "chunked");

    # Remove Content-Length if set (not allowed with chunked)
    ::remove_header(%res, "Content-Length");

    # Store the fd for later chunk writes
    $res{"_fd"} = $fd;
    $res{"_chunked"} = 1;

    # Send headers immediately
    my str $headers = ::build_headers(%res);
    sys::write_fd($fd, $headers);

    $res{"sent"} = 1;  # Mark as sent (headers sent)

    return %res;
}

# Send a data chunk
# Format: hex_size\r\n data\r\n
# Returns bytes written
func Cannoli_Response_send_chunk(hash %res, str $data) int {
    if (length($data) == 0) {
        return 0;  # Skip empty chunks
    }

    my int $fd = $res{"_fd"};
    if ($fd <= 0) {
        return -1;  # No fd set
    }

    # Format: {hex_length}\r\n{data}\r\n
    my str $hex_len = ::to_hex(length($data));
    my str $chunk = $hex_len . "\r\n" . $data . "\r\n";

    return sys::write_fd($fd, $chunk);
}

# Send the final (terminating) chunk
# Format: 0\r\n\r\n
# Returns bytes written
func Cannoli_Response_end_chunked(hash %res) int {
    my int $fd = $res{"_fd"};
    if ($fd <= 0) {
        return -1;
    }

    # Terminating chunk: 0 length followed by empty trailer
    return sys::write_fd($fd, "0\r\n\r\n");
}

# Create an empty response to signal "already handled"
# Used when handler sends response directly (e.g., chunked)
func Cannoli_Response_empty() hash {
    my hash %res = ();
    $res{"status"} = 0;
    $res{"headers"} = {};
    $res{"body"} = "";
    $res{"sent"} = 1;  # Already sent
    $res{"_chunked"} = 1;
    return %res;
}

# Create an empty response with status for logging
func Cannoli_Response_sent(int $status = 200) hash {
    my hash %res = ();
    $res{"status"} = $status;
    $res{"headers"} = {};
    $res{"body"} = "";
    $res{"sent"} = 1;
    $res{"_chunked"} = 1;
    return %res;
}

# Check if response is chunked
func Cannoli_Response_is_chunked(hash %res) int {
    if (exists(%res, "_chunked")) {
        return $res{"_chunked"};
    }
    return 0;
}

# ============================================================
# Response Compression
# ============================================================

# Compress response body using gzip
# Returns 1 if compressed, 0 if not
func Cannoli_Response_compress_gzip(hash %res) int {
    my str $body = $res{"body"};

    # Don't compress if body is empty or too small
    if (length($body) < 1024) {
        return 0;
    }

    # Don't compress if already compressed
    if (::has_header(%res, "Content-Encoding")) {
        return 0;
    }

    # Check content type - only compress text-based
    my str $content_type = ::get_header(%res, "Content-Type");
    if (compress::should_compress($content_type, $body) == 0) {
        return 0;
    }

    # Compress the body
    my str $compressed = compress::gzip($body);

    # Only use compressed if it's actually smaller
    if (length($compressed) < length($body)) {
        $res{"body"} = $compressed;
        ::header(%res, "Content-Encoding", "gzip");
        ::header(%res, "Vary", "Accept-Encoding");
        return 1;
    }

    return 0;
}

# Compress response if client accepts gzip encoding
func Cannoli_Response_auto_compress(hash %res, str $accept_encoding) int {
    # Check if client accepts gzip
    if (index($accept_encoding, "gzip") < 0) {
        return 0;
    }

    return ::compress_gzip(%res);
}

# Check if response is compressed
func Cannoli_Response_is_compressed(hash %res) int {
    my str $encoding = ::get_header(%res, "Content-Encoding");
    if (length($encoding) > 0) {
        return 1;
    }
    return 0;
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::WebSocket;


# cannoli/src/websocket.strada - Basic WebSocket support
#
# Provides handshake helpers and simple frame send/receive utilities.

# WebSocket GUID for Sec-WebSocket-Accept
func Cannoli_WebSocket_guid() str {
    return "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
}

# Check if request looks like a WebSocket upgrade
func Cannoli_WebSocket_is_upgrade_request(hash %req) int {
    my str $method = $req{"method"};
    if ($method ne "GET") {
        return 0;
    }

    my str $upgrade = lc(Cannoli::Request::get_header(%req, "Upgrade"));
    my str $connection = lc(Cannoli::Request::get_header(%req, "Connection"));

    if ($upgrade ne "websocket") {
        return 0;
    }
    if (index($connection, "upgrade") < 0) {
        return 0;
    }

    return 1;
}

# Create a WebSocket connection from a request hash
func Cannoli_WebSocket_from_request(hash %req) scalar {
    my hash %ws = ();

    $ws{"_buffer"} = "";
    $ws{"_ssl"} = 0;
    $ws{"_client"} = undef;

    if (exists(%req, "_ssl") && $req{"_ssl"} == 1) {
        $ws{"_ssl"} = 1;
        $ws{"_ssl_conn"} = $req{"_ssl_conn"};
        $ws{"_ssl_read_fn"} = $req{"_ssl_read_fn"};
        $ws{"_ssl_write_fn"} = $req{"_ssl_write_fn"};
        $ws{"_ssl_close_fn"} = $req{"_ssl_close_fn"};
    } else {
        $ws{"_client"} = $req{"_client"};
        $ws{"_fd"} = $req{"_fd"};
    }

    return \%ws;
}

# Perform WebSocket handshake and return ws handle (undef on failure)
func Cannoli_WebSocket_accept(hash %req, str $protocol = "") scalar {
    if (::is_upgrade_request(%req) == 0) {
        return undef;
    }

    my str $version = Cannoli::Request::get_header(%req, "Sec-WebSocket-Version");
    if (length($version) > 0 && $version ne "13") {
        return undef;
    }

    my str $key = Cannoli::Request::get_header(%req, "Sec-WebSocket-Key");
    if (length($key) == 0) {
        return undef;
    }

    my str $accept = ::make_accept($key);
    my str $resp = "HTTP/1.1 101 Switching Protocols\r\n";
    $resp = $resp . "Upgrade: websocket\r\n";
    $resp = $resp . "Connection: Upgrade\r\n";
    $resp = $resp . "Sec-WebSocket-Accept: " . $accept . "\r\n";

    if (length($protocol) > 0) {
        $resp = $resp . "Sec-WebSocket-Protocol: " . $protocol . "\r\n";
    }

    $resp = $resp . "\r\n";

    my int $written = ::write_response(%req, $resp);
    if ($written <= 0) {
        return undef;
    }

    return ::from_request(%req);
}

# Send a text message (opcode 1)
func Cannoli_WebSocket_send_text(scalar $ws, str $payload) int {
    return ::send_frame($ws, 1, $payload);
}

# Send a binary message (opcode 2)
func Cannoli_WebSocket_send_binary(scalar $ws, str $payload) int {
    return ::send_frame($ws, 2, $payload);
}

# Send ping (opcode 9)
func Cannoli_WebSocket_send_ping(scalar $ws, str $payload) int {
    return ::send_frame($ws, 9, $payload);
}

# Send pong (opcode 10)
func Cannoli_WebSocket_send_pong(scalar $ws, str $payload) int {
    return ::send_frame($ws, 10, $payload);
}

# Send close frame (opcode 8)
func Cannoli_WebSocket_send_close(scalar $ws, int $code, str $reason) int {
    my str $payload = "";
    if ($code > 0) {
        $payload = ::pack_u16($code) . $reason;
    }
    return ::send_frame($ws, 8, $payload);
}

# Close connection (sends close frame then closes socket)
func Cannoli_WebSocket_close(scalar $ws, int $code, str $reason) void {
    ::send_close($ws, $code, $reason);
    ::close_socket($ws);
}

# Receive a single frame, returns hash {fin, opcode, payload} or undef on EOF
func Cannoli_WebSocket_recv_frame(scalar $ws) scalar {
    # Ensure at least 2 bytes for header
    if (::ensure_bytes($ws, 2) == 0) {
        return undef;
    }

    my str $buffer = $ws->{"_buffer"};
    my int $b1 = sys::get_byte($buffer, 0);
    my int $b2 = sys::get_byte($buffer, 1);

    my int $fin = $b1 / 128;
    my int $opcode = $b1 % 16;
    my int $masked = $b2 / 128;
    my int $payload_len = $b2 % 128;
    my int $offset = 2;

    if ($payload_len == 126) {
        if (::ensure_bytes($ws, $offset + 2) == 0) {
            return undef;
        }
        $buffer = $ws->{"_buffer"};
        my int $b3 = sys::get_byte($buffer, $offset);
        my int $b4 = sys::get_byte($buffer, $offset + 1);
        $payload_len = ($b3 * 256) + $b4;
        $offset = $offset + 2;
    } elsif ($payload_len == 127) {
        if (::ensure_bytes($ws, $offset + 8) == 0) {
            return undef;
        }
        $buffer = $ws->{"_buffer"};
        my num $len = 0;
        my int $i = 0;
        while ($i < 8) {
            my int $b = sys::get_byte($buffer, $offset + $i);
            $len = ($len * 256) + $b;
            $i = $i + 1;
        }
        $payload_len = $len;
        $offset = $offset + 8;
    }

    my int $mask0 = 0;
    my int $mask1 = 0;
    my int $mask2 = 0;
    my int $mask3 = 0;
    if ($masked == 1) {
        if (::ensure_bytes($ws, $offset + 4) == 0) {
            return undef;
        }
        $buffer = $ws->{"_buffer"};
        $mask0 = sys::get_byte($buffer, $offset);
        $mask1 = sys::get_byte($buffer, $offset + 1);
        $mask2 = sys::get_byte($buffer, $offset + 2);
        $mask3 = sys::get_byte($buffer, $offset + 3);
        $offset = $offset + 4;
    }

    if (::ensure_bytes($ws, $offset + $payload_len) == 0) {
        return undef;
    }
    $buffer = $ws->{"_buffer"};

    my str $payload = "";
    if ($payload_len > 0) {
        $payload = sys::byte_substr($buffer, $offset, $payload_len);
    }

    my int $remaining_start = $offset + $payload_len;
    my int $remaining_len = sys::byte_length($buffer) - $remaining_start;
    if ($remaining_len > 0) {
        $ws->{"_buffer"} = sys::byte_substr($buffer, $remaining_start, $remaining_len);
    } else {
        $ws->{"_buffer"} = "";
    }

    if ($masked == 1 && $payload_len > 0) {
        my str $decoded = "";
        my int $i = 0;
        while ($i < $payload_len) {
            my int $byte = sys::get_byte($payload, $i);
            my int $mask = 0;
            my int $m = $i % 4;
            if ($m == 0) { $mask = $mask0; }
            elsif ($m == 1) { $mask = $mask1; }
            elsif ($m == 2) { $mask = $mask2; }
            else { $mask = $mask3; }
            my int $out = ::xor8($byte, $mask);
            $decoded = $decoded . chr($out);
            $i = $i + 1;
        }
        $payload = $decoded;
    }

    my hash %frame = ();
    $frame{"fin"} = $fin;
    $frame{"opcode"} = $opcode;
    $frame{"payload"} = $payload;
    return \%frame;
}

# ============================================================
# Internal helpers (binary/frame building)
# ============================================================

func Cannoli_WebSocket_send_frame(scalar $ws, int $opcode, str $payload) int {
    my int $len = sys::byte_length($payload);
    my int $byte1 = 128 + ($opcode % 16);
    my str $header = chr($byte1);

    if ($len <= 125) {
        $header = $header . chr($len);
    } elsif ($len <= 65535) {
        $header = $header . chr(126) . ::pack_u16($len);
    } else {
        $header = $header . chr(127) . ::pack_u64($len);
    }

    return ::write_ws($ws, $header . $payload);
}

func Cannoli_WebSocket_pack_u16(int $value) str {
    return sys::pack("n", $value);
}

func Cannoli_WebSocket_pack_u64(num $value) str {
    my num $len = $value;
    my int $high = math::floor($len / 4294967296);
    my int $low = $len - ($high * 4294967296);
    return sys::pack("N2", $high, $low);
}

func Cannoli_WebSocket_write_ws(scalar $ws, str $data) int {
    if ($ws->{"_ssl"} == 1) {
        my scalar $ssl_conn = $ws->{"_ssl_conn"};
        my scalar $ssl_write_fn = $ws->{"_ssl_write_fn"};
        return sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $data]);
    }
    my int $fd = $ws->{"_fd"};
    return sys::write_fd($fd, $data);
}

func Cannoli_WebSocket_close_socket(scalar $ws) void {
    if ($ws->{"_ssl"} == 1) {
        my scalar $ssl_conn = $ws->{"_ssl_conn"};
        my scalar $ssl_close_fn = $ws->{"_ssl_close_fn"};
        sys::dl_call_void_sv($ssl_close_fn, [$ssl_conn]);
    } else {
        sys::socket_close($ws->{"_client"});
    }
}

func Cannoli_WebSocket_write_response(hash %req, str $data) int {
    if (exists(%req, "_ssl") && $req{"_ssl"} == 1) {
        my scalar $ssl_conn = $req{"_ssl_conn"};
        my scalar $ssl_write_fn = $req{"_ssl_write_fn"};
        return sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $data]);
    }
    my int $fd = $req{"_fd"};
    return sys::write_fd($fd, $data);
}

func Cannoli_WebSocket_read_ws(scalar $ws, int $len) str {
    if ($ws->{"_ssl"} == 1) {
        my scalar $ssl_conn = $ws->{"_ssl_conn"};
        my scalar $ssl_read_fn = $ws->{"_ssl_read_fn"};
        return sys::dl_call_str_sv($ssl_read_fn, [$ssl_conn, $len]);
    }
    return sys::socket_recv($ws->{"_client"}, $len);
}

func Cannoli_WebSocket_ensure_bytes(scalar $ws, int $needed) int {
    my str $buffer = $ws->{"_buffer"};
    while (sys::byte_length($buffer) < $needed) {
        my str $chunk = ::read_ws($ws, 4096);
        if (sys::byte_length($chunk) == 0) {
            $ws->{"_buffer"} = $buffer;
            return 0;
        }
        $buffer = $buffer . $chunk;
    }
    $ws->{"_buffer"} = $buffer;
    return 1;
}

func Cannoli_WebSocket_make_accept(str $key) str {
    my str $digest = ::sha1_bin($key . ::guid());
    return sys::base64_encode($digest);
}

# ============================================================
# SHA1 implementation (pure Strada, uses arithmetic-only bit ops)
# ============================================================

func Cannoli_WebSocket_sha1_bin(str $data) str {
    my int $len = sys::byte_length($data);
    my array @bytes = ();

    my int $i = 0;
    while ($i < $len) {
        push(@bytes, sys::get_byte($data, $i));
        $i = $i + 1;
    }

    # Append 0x80 then pad with 0x00 to 56 mod 64
    push(@bytes, 128);
    while ((scalar(@bytes) % 64) != 56) {
        push(@bytes, 0);
    }

    # Append length in bits as 64-bit big-endian
    my num $bit_len = $len * 8;
    my array @len_bytes = (0, 0, 0, 0, 0, 0, 0, 0);
    $i = 7;
    while ($i >= 0) {
        $len_bytes[$i] = $bit_len % 256;
        $bit_len = math::floor($bit_len / 256);
        $i = $i - 1;
    }
    $i = 0;
    while ($i < 8) {
        push(@bytes, $len_bytes[$i]);
        $i = $i + 1;
    }

    my int $h0 = 1732584193;
    my int $h1 = 4023233417;
    my int $h2 = 2562383102;
    my int $h3 = 271733878;
    my int $h4 = 3285377520;

    my int $chunk = 0;
    my int $total = scalar(@bytes);
    while ($chunk < $total) {
        my array @w = ();
        $i = 0;
        while ($i < 16) {
            my int $idx = $chunk + ($i * 4);
            my int $b0 = $bytes[$idx];
            my int $b1 = $bytes[$idx + 1];
            my int $b2 = $bytes[$idx + 2];
            my int $b3 = $bytes[$idx + 3];
            my int $word = ($b0 * 16777216) + ($b1 * 65536) + ($b2 * 256) + $b3;
            push(@w, $word);
            $i = $i + 1;
        }

        $i = 16;
        while ($i < 80) {
            my int $v = ::xor32(::xor32($w[$i - 3], $w[$i - 8]), ::xor32($w[$i - 14], $w[$i - 16]));
            my int $word = ::rol32($v, 1);
            push(@w, $word);
            $i = $i + 1;
        }

        my int $a = $h0;
        my int $b = $h1;
        my int $c = $h2;
        my int $d = $h3;
        my int $e = $h4;

        $i = 0;
        while ($i < 80) {
            my int $f = 0;
            my int $k = 0;

            if ($i < 20) {
                $f = ::or32(::and32($b, $c), ::and32(::not32($b), $d));
                $k = 1518500249;
            } elsif ($i < 40) {
                $f = ::xor32(::xor32($b, $c), $d);
                $k = 1859775393;
            } elsif ($i < 60) {
                $f = ::or32(::or32(::and32($b, $c), ::and32($b, $d)), ::and32($c, $d));
                $k = 2400959708;
            } else {
                $f = ::xor32(::xor32($b, $c), $d);
                $k = 3395469782;
            }

            my int $temp = ::add32(::rol32($a, 5), $f, $e, $k, $w[$i]);
            $e = $d;
            $d = $c;
            $c = ::rol32($b, 30);
            $b = $a;
            $a = $temp;

            $i = $i + 1;
        }

        $h0 = ::add32($h0, $a);
        $h1 = ::add32($h1, $b);
        $h2 = ::add32($h2, $c);
        $h3 = ::add32($h3, $d);
        $h4 = ::add32($h4, $e);

        $chunk = $chunk + 64;
    }

    my str $out = "";
    $out = $out . sys::pack("N", ::u32($h0));
    $out = $out . sys::pack("N", ::u32($h1));
    $out = $out . sys::pack("N", ::u32($h2));
    $out = $out . sys::pack("N", ::u32($h3));
    $out = $out . sys::pack("N", ::u32($h4));
    return $out;
}

func Cannoli_WebSocket_add32(int ...@vals) int {
    my num $sum = 0;
    my int $i = 0;
    while ($i < scalar(@vals)) {
        $sum = $sum + $vals[$i];
        $i = $i + 1;
    }
    return ::u32($sum);
}

func Cannoli_WebSocket_u32(num $value) int {
    my num $mod = 4294967296;
    my num $div = $value / $mod;
    my int $q = math::floor($div);
    my num $res = $value - ($q * $mod);
    if ($res < 0) {
        $res = $res + $mod;
    }
    return $res;
}

func Cannoli_WebSocket_pow2(int $n) num {
    my num $v = 1;
    my int $i = 0;
    while ($i < $n) {
        $v = $v * 2;
        $i = $i + 1;
    }
    return $v;
}

func Cannoli_WebSocket_rol32(int $value, int $bits) int {
    my int $shift = $bits % 32;
    if ($shift == 0) {
        return ::u32($value);
    }
    my num $pow = ::pow2($shift);
    my num $pow_rev = ::pow2(32 - $shift);
    my int $left = ::u32($value * $pow);
    my int $right = ::u32($value / $pow_rev);
    return ::u32($left + $right);
}

func Cannoli_WebSocket_and32(int $a, int $b) int {
    my int $aa = ::u32($a);
    my int $bb = ::u32($b);
    my int $result = 0;
    my int $bit = 1;
    my int $i = 0;

    while ($i < 32) {
        if (($aa % 2) == 1 && ($bb % 2) == 1) {
            $result = $result + $bit;
        }
        $aa = $aa / 2;
        $bb = $bb / 2;
        $bit = $bit * 2;
        $i = $i + 1;
    }

    return $result;
}

func Cannoli_WebSocket_or32(int $a, int $b) int {
    my int $aa = ::u32($a);
    my int $bb = ::u32($b);
    my int $result = 0;
    my int $bit = 1;
    my int $i = 0;

    while ($i < 32) {
        if (($aa % 2) == 1 || ($bb % 2) == 1) {
            $result = $result + $bit;
        }
        $aa = $aa / 2;
        $bb = $bb / 2;
        $bit = $bit * 2;
        $i = $i + 1;
    }

    return $result;
}

func Cannoli_WebSocket_xor32(int $a, int $b) int {
    my int $aa = ::u32($a);
    my int $bb = ::u32($b);
    my int $result = 0;
    my int $bit = 1;
    my int $i = 0;

    while ($i < 32) {
        my int $bit_val = ($aa % 2) + ($bb % 2);
        if (($bit_val % 2) == 1) {
            $result = $result + $bit;
        }
        $aa = $aa / 2;
        $bb = $bb / 2;
        $bit = $bit * 2;
        $i = $i + 1;
    }

    return $result;
}

func Cannoli_WebSocket_not32(int $a) int {
    return ::u32(4294967295 - ::u32($a));
}

func Cannoli_WebSocket_xor8(int $a, int $b) int {
    my int $aa = $a % 256;
    my int $bb = $b % 256;
    my int $result = 0;
    my int $bit = 1;
    my int $i = 0;

    while ($i < 8) {
        my int $bit_val = ($aa % 2) + ($bb % 2);
        if (($bit_val % 2) == 1) {
            $result = $result + $bit;
        }
        $aa = $aa / 2;
        $bb = $bb / 2;
        $bit = $bit * 2;
        $i = $i + 1;
    }

    return $result;
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

package Cannoli;


# cannoli_obj.strada - Request/Response object for Strada handlers
#
# This module provides an object-oriented interface for handling
# HTTP requests in Cannoli Strada handlers, matching the Perl Cannoli interface.
#
# Usage:
#   func handle(scalar $c) hash {
#       my str $method = $c->method();
#       my str $path = $c->path();
#       $c->status(200);
#       $c->content_type("application/json");
#       $c->write_body('{"ok":true}');
#       return $c->build_response();
#   }

# Methods are defined on the Cannoli object package

# Constructor - create from request hash
func Cannoli_new(hash %req) scalar {
    my hash %self = ();

    # Request data
    $self{"_method"} = $req{"method"};
    $self{"_path"} = $req{"path"};
    $self{"_path_info"} = $req{"path_info"};
    $self{"_query_string"} = $req{"query_string"};
    $self{"_body"} = $req{"body"};
    $self{"_headers"} = $req{"headers"};
    $self{"_remote_addr"} = $req{"remote_addr"};
    $self{"_content_type"} = $req{"content_type"};
    $self{"_params"} = $req{"params"};
    $self{"_captures"} = $req{"captures"};
    $self{"_files"} = $req{"files"};
    $self{"_variables"} = {};
    $self{"_document_root"} = "";

    # Extract Accept-Encoding for compression support
    my str $accept_enc = Cannoli::Request::get_header(%req, "Accept-Encoding");
    $self{"_req_accept_encoding"} = $accept_enc;

    # Socket/connection info for chunked responses
    if (exists(%req, "_fd")) {
        $self{"_fd"} = $req{"_fd"};
    }
    if (exists(%req, "_client")) {
        $self{"_client"} = $req{"_client"};
    }
    if (exists(%req, "_ssl")) {
        $self{"_ssl"} = $req{"_ssl"};
        $self{"_ssl_conn"} = $req{"_ssl_conn"};
        if (exists(%req, "_ssl_read_fn")) {
            $self{"_ssl_read_fn"} = $req{"_ssl_read_fn"};
        }
        $self{"_ssl_write_fn"} = $req{"_ssl_write_fn"};
        if (exists(%req, "_ssl_close_fn")) {
            $self{"_ssl_close_fn"} = $req{"_ssl_close_fn"};
        }
    }

    # Response data
    $self{"_res_status"} = 200;
    $self{"_res_content_type"} = "";
    $self{"_res_headers"} = {};
    $self{"_res_body"} = "";
    $self{"_res_redirect"} = "";
    $self{"_allow_ranges"} = 0;

    return bless(\%self, "Cannoli");
}

#
# Request Accessors
#

func Cannoli_method(scalar $self) str {
    return $self->{"_method"};
}

func Cannoli_path(scalar $self) str {
    return $self->{"_path"};
}

func Cannoli_path_info(scalar $self) str {
    return $self->{"_path_info"};
}

func Cannoli_query_string(scalar $self) str {
    return $self->{"_query_string"};
}

func Cannoli_body(scalar $self) str {
    return $self->{"_body"};
}

# Get parsed JSON Cannoli_body(lazy parsing)
func Cannoli_json_body(scalar $self) scalar {
    # Return cached if already parsed
    if (exists(%{$self}, "_json_body_parsed")) {
        return $self->{"_json_body"};
    }

    # Check content type
    my str $ct = $self->{"_content_type"};
    if (index($ct, "application/json") < 0) {
        $self->{"_json_body_parsed"} = 1;
        $self->{"_json_body"} = undef;
        return undef;
    }

    # Parse JSON body
    my str $body_str = $self->{"_body"};
    if (length($body_str) == 0) {
        $self->{"_json_body_parsed"} = 1;
        $self->{"_json_body"} = undef;
        return undef;
    }

    my scalar $parsed = Cannoli::Request::json_parse($body_str);
    $self->{"_json_body_parsed"} = 1;
    $self->{"_json_body"} = $parsed;
    return $parsed;
}

# Get a value from JSON body by key
func Cannoli_json_param(scalar $self, str $key) scalar {
    my scalar $json = $self->json_body();
    if (!defined($json)) {
        return undef;
    }
    if (ref($json) ne "HASH") {
        return undef;
    }
    if (exists(%{$json}, $key)) {
        return $json->{$key};
    }
    return undef;
}

# Check if request has JSON content type
func Cannoli_is_json(scalar $self) int {
    my str $ct = $self->{"_content_type"};
    return index($ct, "application/json") >= 0;
}

func Cannoli_remote_addr(scalar $self) str {
    return $self->{"_remote_addr"};
}

func Cannoli_request_content_type(scalar $self) str {
    return $self->{"_content_type"};
}

# Get all request headers as hash ref
func Cannoli_headers(scalar $self) scalar {
    return $self->{"_headers"};
}

# Get a specific request Cannoli_header(case-insensitive)
func Cannoli_header(scalar $self, str $name) str {
    my str $lc_name = lc($name);
    my scalar $hdrs = $self->{"_headers"};
    if (exists(%{$hdrs}, $lc_name)) {
        return $hdrs->{$lc_name};
    }
    return "";
}

# Check if request has a header
func Cannoli_has_header(scalar $self, str $name) int {
    my str $lc_name = lc($name);
    return exists(%{$self->{"_headers"}}, $lc_name);
}

# Get all parsed parameters
func Cannoli_params(scalar $self) scalar {
    return $self->{"_params"};
}

# Get a specific parameter
func Cannoli_param(scalar $self, str $name) str {
    my scalar $p = $self->{"_params"};
    if (exists(%{$p}, $name)) {
        return $p->{$name};
    }
    return "";
}

# Check if parameter exists
func Cannoli_has_param(scalar $self, str $name) int {
    return exists(%{$self->{"_params"}}, $name);
}

#
# File Upload Accessors
#

# Get an uploaded file by field name
# Returns hash with: name, filename, content_type, content, size
func Cannoli_file(scalar $self, str $name) scalar {
    my scalar $files = $self->{"_files"};
    if (!defined($files)) {
        return undef;
    }
    if (exists(%{$files}, $name)) {
        return $files->{$name};
    }
    return undef;
}

# Get all uploaded files as hash ref
func Cannoli_files(scalar $self) scalar {
    my scalar $files = $self->{"_files"};
    if (!defined($files)) {
        my hash %empty = ();
        return \%empty;
    }
    return $files;
}

# Check if a file was uploaded with the given field name
func Cannoli_has_file(scalar $self, str $name) int {
    my scalar $files = $self->{"_files"};
    if (!defined($files)) {
        return 0;
    }
    return exists(%{$files}, $name);
}

# Get file content by field name
func Cannoli_file_content(scalar $self, str $name) str {
    my scalar $file = $self->file($name);
    if (!defined($file)) {
        return "";
    }
    return $file->{"content"};
}

# Get original filename by field name
func Cannoli_file_name(scalar $self, str $name) str {
    my scalar $file = $self->file($name);
    if (!defined($file)) {
        return "";
    }
    return $file->{"filename"};
}

# Get file size by field name
func Cannoli_file_size(scalar $self, str $name) int {
    my scalar $file = $self->file($name);
    if (!defined($file)) {
        return 0;
    }
    return $file->{"size"};
}

# Get file content type by field name
func Cannoli_file_type(scalar $self, str $name) str {
    my scalar $file = $self->file($name);
    if (!defined($file)) {
        return "";
    }
    return $file->{"content_type"};
}

# Get route captures
func Cannoli_captures(scalar $self) scalar {
    return $self->{"_captures"};
}

# Get a specific capture by index
func Cannoli_capture(scalar $self, int $idx) str {
    my scalar $caps = $self->{"_captures"};
    if ($idx < scalar(@{$caps})) {
        return $caps->[$idx];
    }
    return "";
}

# Check request method helpers
func Cannoli_is_get(scalar $self) int {
    return $self->{"_method"} eq "GET";
}

func Cannoli_is_post(scalar $self) int {
    return $self->{"_method"} eq "POST";
}

func Cannoli_is_put(scalar $self) int {
    return $self->{"_method"} eq "PUT";
}

func Cannoli_is_delete(scalar $self) int {
    return $self->{"_method"} eq "DELETE";
}

func Cannoli_is_patch(scalar $self) int {
    return $self->{"_method"} eq "PATCH";
}

func Cannoli_is_head(scalar $self) int {
    return $self->{"_method"} eq "HEAD";
}

func Cannoli_is_options(scalar $self) int {
    return $self->{"_method"} eq "OPTIONS";
}

# Check if AJAX request
func Cannoli_is_ajax(scalar $self) int {
    return $self->header("x-requested-with") eq "XMLHttpRequest";
}

# Get user agent
func Cannoli_user_agent(scalar $self) str {
    return $self->header("user-agent");
}

# Get referer
func Cannoli_referer(scalar $self) str {
    return $self->header("referer");
}

# Get host
func Cannoli_host(scalar $self) str {
    return $self->header("host");
}

#
# nginx-compatible aliases
#

# $r->args - returns request arguments (query string)
func Cannoli_args(scalar $self) str {
    return $self->{"_query_string"};
}

# $r->uri - returns request URI (path)
func Cannoli_uri(scalar $self) str {
    return $self->{"_path"};
}

# $r->request_method - returns HTTP method
func Cannoli_request_method(scalar $self) str {
    return $self->{"_method"};
}

# $r->request_body - returns client request body
func Cannoli_request_body(scalar $self) str {
    return $self->{"_body"};
}

# $r->header_in(field) - returns value of client request header
func Cannoli_header_in(scalar $self, str $field) str {
    return $self->header($field);
}

# $r->header_out(field, value) - sets response header field
func Cannoli_header_out(scalar $self, str $field, str $value) scalar {
    return $self->set_header($field, $value);
}

# $r->header_only - returns true if HEAD request
func Cannoli_header_only(scalar $self) int {
    return $self->{"_method"} eq "HEAD";
}

# $r->filename - returns document_root + path
func Cannoli_filename(scalar $self) str {
    my str $root = $self->{"_document_root"};
    if (length($root) == 0) {
        return "";
    }
    return $root . $self->{"_path"};
}

# $r->unescape(text) - URL decode
func Cannoli_unescape(scalar $self, str $text) str {
    defined($self);
    return Cannoli_url_decode($text);
}

# $r->variable(name, value) - get/set request variable
func Cannoli_variable(scalar $self, str $name, str $value) scalar {
    my scalar $vars = $self->{"_variables"};
    if (length($value) > 0) {
        $vars->{$name} = $value;
        return $self;
    }
    if (exists(%{$vars}, $name)) {
        return $vars->{$name};
    }
    return "";
}

# Alias: stash
func Cannoli_stash(scalar $self, str $name, str $value) scalar {
    return $self->variable($name, $value);
}

# $r->log_error(errno, message) - log error
func Cannoli_log_error(scalar $self, int $errno, str $message) scalar {
    if ($errno != 0) {
        say("[error] " . $message . " (errno: " . $errno . ")");
    } else {
        say("[error] " . $message);
    }
    return $self;
}

# $r->allow_ranges - enable byte-range support
func Cannoli_allow_ranges(scalar $self) scalar {
    $self->{"_allow_ranges"} = 1;
    return $self;
}

# $r->flush - no-op in our model
func Cannoli_flush(scalar $self) scalar {
    return $self;
}

# $r->discard_request_body - no-op
func Cannoli_discard_request_body(scalar $self) scalar {
    return $self;
}

# $r->send_http_header(type) - set content type
func Cannoli_send_http_header(scalar $self, str $type) scalar {
    if (length($type) > 0) {
        $self->content_type($type);
    }
    return $self;
}

#
# Response Methods
#

# Set/get response status
func Cannoli_status(scalar $self, int $code) scalar {
    if ($code > 0) {
        $self->{"_res_status"} = $code;
    }
    return $self;
}

# Get status code
func Cannoli_get_status(scalar $self) int {
    return $self->{"_res_status"};
}

# Set/get response content type
func Cannoli_content_type(scalar $self, str $type) scalar {
    if (length($type) > 0) {
        $self->{"_res_content_type"} = $type;
    }
    return $self;
}

# Get content type
func Cannoli_get_content_type(scalar $self) str {
    return $self->{"_res_content_type"};
}

# Set a response header
func Cannoli_set_header(scalar $self, str $name, str $value) scalar {
    my scalar $hdrs = $self->{"_res_headers"};
    $hdrs->{$name} = $value;
    return $self;
}

# Get response headers
func Cannoli_response_headers(scalar $self) scalar {
    return $self->{"_res_headers"};
}

# Write to response body
func Cannoli_write_body(scalar $self, str $content) scalar {
    $self->{"_res_body"} = $self->{"_res_body"} . $content;
    return $self;
}

# Alias for Cannoli_write_body(nginx compat: print)
func Cannoli_print_body(scalar $self, str $content) scalar {
    return $self->write_body($content);
}

# Set response Cannoli_body(replaces existing)
func Cannoli_body_set(scalar $self, str $content) scalar {
    $self->{"_res_body"} = $content;
    return $self;
}

# Get response body
func Cannoli_response_body(scalar $self) str {
    return $self->{"_res_body"};
}

# Send redirect
func Cannoli_redirect(scalar $self, str $url, int $code) scalar {
    $self->{"_res_redirect"} = $url;
    if ($code > 0) {
        $self->{"_res_status"} = $code;
    } else {
        $self->{"_res_status"} = 302;
    }
    return $self;
}

# Render JSON response
func Cannoli_render_json(scalar $self, scalar $data) scalar {
    $self->content_type("application/json");
    $self->write_body(Cannoli_to_json($data));
    return $self;
}

# Render text response
func Cannoli_render_text(scalar $self, str $text) scalar {
    $self->content_type("text/plain");
    $self->write_body($text);
    return $self;
}

# Render HTML response
func Cannoli_render_html(scalar $self, str $html) scalar {
    $self->content_type("text/html");
    $self->write_body($html);
    return $self;
}

# Send error response
func Cannoli_error(scalar $self, int $code, str $message) scalar {
    if ($code == 0) {
        $code = 500;
    }
    $self->status($code);
    $self->content_type("application/json");
    if (length($message) == 0) {
        $message = "Internal Server Error";
    }
    $self->body_set("{\"error\":\"" . $message . "\"}");
    return $self;
}

# Send not found response
func Cannoli_not_found(scalar $self, str $message) scalar {
    if (length($message) == 0) {
        $message = "Not Found";
    }
    return $self->error(404, $message);
}

# Send bad request response
func Cannoli_bad_request(scalar $self, str $message) scalar {
    if (length($message) == 0) {
        $message = "Bad Request";
    }
    return $self->error(400, $message);
}

# Set cookie
func Cannoli_set_cookie(scalar $self, str $name, str $value, str $path, int $max_age, int $httponly, int $secure) scalar {
    my str $cookie = $name . "=" . $value;
    if (length($path) > 0) {
        $cookie = $cookie . "; Path=" . $path;
    }
    if ($max_age > 0) {
        $cookie = $cookie . "; Max-Age=" . $max_age;
    }
    if ($httponly == 1) {
        $cookie = $cookie . "; HttpOnly";
    }
    if ($secure == 1) {
        $cookie = $cookie . "; Secure";
    }
    $self->set_header("Set-Cookie", $cookie);
    return $self;
}

# Send file content
func Cannoli_sendfile(scalar $self, str $filepath) scalar {
    if (!sys::is_file($filepath)) {
        $self->log_error(0, "File not found: " . $filepath);
        return $self;
    }

    my str $content = sys::slurp($filepath);

    # Auto-detect content type
    my str $ct = "application/octet-stream";
    if ($filepath =~ /\.html?$/i) { $ct = "text/html"; }
    elsif ($filepath =~ /\.css$/i) { $ct = "text/css"; }
    elsif ($filepath =~ /\.js$/i) { $ct = "application/javascript"; }
    elsif ($filepath =~ /\.json$/i) { $ct = "application/json"; }
    elsif ($filepath =~ /\.xml$/i) { $ct = "application/xml"; }
    elsif ($filepath =~ /\.txt$/i) { $ct = "text/plain"; }
    elsif ($filepath =~ /\.png$/i) { $ct = "image/png"; }
    elsif ($filepath =~ /\.jpe?g$/i) { $ct = "image/jpeg"; }
    elsif ($filepath =~ /\.gif$/i) { $ct = "image/gif"; }
    elsif ($filepath =~ /\.svg$/i) { $ct = "image/svg+xml"; }
    elsif ($filepath =~ /\.ico$/i) { $ct = "image/x-icon"; }
    elsif ($filepath =~ /\.pdf$/i) { $ct = "application/pdf"; }
    elsif ($filepath =~ /\.zip$/i) { $ct = "application/zip"; }

    if (length($self->{"_res_content_type"}) == 0) {
        $self->content_type($ct);
    }
    $self->write_body($content);

    if ($self->{"_allow_ranges"} == 1) {
        $self->set_header("Accept-Ranges", "bytes");
    }

    return $self;
}

#
# Chunked Transfer Encoding Methods
#

# Start a chunked response - sends headers immediately
# After calling this, use Cannoli_write_chunk() to send data, then Cannoli_end_chunked() to finish
func Cannoli_start_chunked(scalar $self) scalar {
    # Build a response hash with current settings
    my hash %res = Cannoli::Response::new();
    Cannoli::Response::status(%res, $self->{"_res_status"});

    # Set content type
    if (length($self->{"_res_content_type"}) > 0) {
        Cannoli::Response::content_type(%res, $self->{"_res_content_type"});
    }

    # Set custom headers
    my scalar $custom_hdrs = $self->{"_res_headers"};
    my array @hdr_names = keys(%{$custom_hdrs});
    my int $i = 0;
    while ($i < scalar(@hdr_names)) {
        my str $name = $hdr_names[$i];
        my str $value = $custom_hdrs->{$name};
        Cannoli::Response::header(%res, $name, $value);
        $i = $i + 1;
    }

    # Check if SSL or regular socket
    if (exists(%{$self}, "_ssl") && $self->{"_ssl"} == 1) {
        # SSL chunked - need to send headers via SSL write
        my scalar $ssl_conn = $self->{"_ssl_conn"};
        my scalar $ssl_write_fn = $self->{"_ssl_write_fn"};

        Cannoli::Response::header(%res, "Transfer-Encoding", "chunked");
        Cannoli::Response::remove_header(%res, "Content-Length");
        my str $headers = Cannoli::Response::build_headers(%res);
        sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $headers]);

        $self->{"_chunked"} = 1;
        $self->{"_chunked_ssl"} = 1;
    } else {
        # Regular socket chunked
        my int $fd = $self->{"_fd"};
        %res = Cannoli::Response::chunked_start(%res, $fd);
        $self->{"_chunked"} = 1;
        $self->{"_chunked_res"} = \%res;
    }

    return $self;
}

# Write a chunk of data
# Returns bytes written, or -1 on error
func Cannoli_write_chunk(scalar $self, str $data) int {
    if (length($data) == 0) {
        return 0;
    }

    # Format chunk: hex_length\r\n data \r\n
    my str $hex_len = Cannoli::Response::to_hex(length($data));
    my str $chunk = $hex_len . "\r\n" . $data . "\r\n";

    if (exists(%{$self}, "_chunked_ssl") && $self->{"_chunked_ssl"} == 1) {
        # SSL write
        my scalar $ssl_conn = $self->{"_ssl_conn"};
        my scalar $ssl_write_fn = $self->{"_ssl_write_fn"};
        return sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $chunk]);
    } else {
        # Regular socket write
        my int $fd = $self->{"_fd"};
        return sys::write_fd($fd, $chunk);
    }
}

# End the chunked response - sends terminating chunk
func Cannoli_end_chunked(scalar $self) scalar {
    my str $terminator = "0\r\n\r\n";

    if (exists(%{$self}, "_chunked_ssl") && $self->{"_chunked_ssl"} == 1) {
        # SSL write
        my scalar $ssl_conn = $self->{"_ssl_conn"};
        my scalar $ssl_write_fn = $self->{"_ssl_write_fn"};
        sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $terminator]);
    } else {
        # Regular socket write
        my int $fd = $self->{"_fd"};
        sys::write_fd($fd, $terminator);
    }

    return $self;
}

# Check if response is in chunked mode
func Cannoli_is_chunked(scalar $self) int {
    if (exists(%{$self}, "_chunked")) {
        return $self->{"_chunked"};
    }
    return 0;
}

#
# WebSocket Methods
#

func Cannoli_ws_accept(scalar $self, str $protocol = "") scalar {
    my hash %req = ();
    $req{"method"} = $self->{"_method"};
    $req{"headers"} = $self->{"_headers"};

    if (exists(%{$self}, "_client")) {
        $req{"_client"} = $self->{"_client"};
        $req{"_fd"} = $self->{"_fd"};
    }

    if (exists(%{$self}, "_ssl") && $self->{"_ssl"} == 1) {
        $req{"_ssl"} = $self->{"_ssl"};
        $req{"_ssl_conn"} = $self->{"_ssl_conn"};
        if (exists(%{$self}, "_ssl_read_fn")) {
            $req{"_ssl_read_fn"} = $self->{"_ssl_read_fn"};
        }
        $req{"_ssl_write_fn"} = $self->{"_ssl_write_fn"};
        if (exists(%{$self}, "_ssl_close_fn")) {
            $req{"_ssl_close_fn"} = $self->{"_ssl_close_fn"};
        }
    }

    my scalar $ws = Cannoli::WebSocket::accept(%req, $protocol);
    if (defined($ws)) {
        $self->{"_ws_active"} = 1;
        $self->{"_ws_status"} = 101;
    }
    return $ws;
}

#
# Build response hash from Cannoli state
#

func Cannoli_build_response(scalar $self) hash {
    if (exists(%{$self}, "_ws_active") && $self->{"_ws_active"} == 1) {
        my int $status = 101;
        if (exists(%{$self}, "_ws_status")) {
            $status = $self->{"_ws_status"};
        }
        return Cannoli::Response::sent($status);
    }

    # If chunked mode, response was already sent
    if ($self->is_chunked() == 1) {
        return Cannoli::Response::empty();
    }

    my hash %res = Cannoli::Response::new();

    # Handle redirect
    if (length($self->{"_res_redirect"}) > 0) {
        return Cannoli::Response::redirect($self->{"_res_redirect"}, $self->{"_res_status"});
    }

    # Set status
    Cannoli::Response::status(%res, $self->{"_res_status"});

    # Set content type
    if (length($self->{"_res_content_type"}) > 0) {
        Cannoli::Response::content_type(%res, $self->{"_res_content_type"});
    }

    # Set body
    Cannoli::Response::body(%res, $self->{"_res_body"});

    # Set custom headers
    my scalar $custom_hdrs = $self->{"_res_headers"};
    my array @hdr_names = keys(%{$custom_hdrs});
    my int $i = 0;
    while ($i < scalar(@hdr_names)) {
        my str $name = $hdr_names[$i];
        my str $value = $custom_hdrs->{$name};
        Cannoli::Response::header(%res, $name, $value);
        $i = $i + 1;
    }

    # Apply compression if enabled
    if ($self->is_compress_enabled() == 1) {
        if (exists(%{$self}, "_auto_compress")) {
            # Auto-compress based on Accept-Encoding
            my str $accept = $self->{"_req_accept_encoding"};
            Cannoli::Response::auto_compress(%res, $accept);
        } else {
            # Force gzip compression
            Cannoli::Response::compress_gzip(%res);
        }
    }

    return %res;
}

# end package Cannoli

#
# Helper functions (utility routines in Cannoli package)
#

# URL decode helper
func Cannoli_url_decode(str $s) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch eq "+") {
            $result = $result . " ";
            $i = $i + 1;
        } elsif ($ch eq "%" && $i + 2 < $len) {
            my str $hex = substr($s, $i + 1, 2);
            my int $code = Cannoli_hex_to_int($hex);
            $result = $result . chr($code);
            $i = $i + 3;
        } else {
            $result = $result . $ch;
            $i = $i + 1;
        }
    }

    return $result;
}

# Hex to int helper
func Cannoli_hex_to_int(str $hex) int {
    my int $result = 0;
    my int $i = 0;
    my int $len = length($hex);

    while ($i < $len) {
        my str $ch = substr($hex, $i, 1);
        my int $val = 0;

        if ($ch ge "0" && $ch le "9") {
            $val = ord($ch) - ord("0");
        } elsif ($ch ge "a" && $ch le "f") {
            $val = ord($ch) - ord("a") + 10;
        } elsif ($ch ge "A" && $ch le "F") {
            $val = ord($ch) - ord("A") + 10;
        }

        $result = $result * 16 + $val;
        $i = $i + 1;
    }

    return $result;
}

# Create Cannoli object from request hash (convenience function)
func Cannoli_from_request(hash %req) scalar {
    return Cannoli_new(%req);
}

# Simple JSON encoder
func Cannoli_to_json(scalar $data) str {
    if (!defined($data)) {
        return "null";
    }

    my str $type = ref($data);

    if ($type eq "HASH") {
        my array @keys = keys(%{$data});
        my int $num = scalar(@keys);
        my str $result = "{";
        my int $i = 0;

        while ($i < $num) {
            my str $key = $keys[$i];
            my scalar $val = $data->{$key};

            if ($i > 0) {
                $result = $result . ",";
            }
            $result = $result . "\"" . Cannoli_json_escape($key) . "\":" . Cannoli_to_json($val);
            $i = $i + 1;
        }
        return $result . "}";
    }

    # Array (both anonymous arrays and named array refs)
    if ($type eq "ARRAY" || $type eq "REF") {
        my int $num = scalar(@{$data});
        my str $result = "[";
        my int $i = 0;

        while ($i < $num) {
            if ($i > 0) {
                $result = $result . ",";
            }
            $result = $result . Cannoli_to_json($data->[$i]);
            $i = $i + 1;
        }
        return $result . "]";
    }

    # Scalar value (ref() returns empty string for non-references)
    # Stringify and check if it's a number
    my str $s = "" . $data;
    if ($s =~ /^-?\d+$/) {
        return $s;
    }
    if ($s =~ /^-?\d+\.\d+$/) {
        return $s;
    }

    return "\"" . Cannoli_json_escape($s) . "\"";
}

# JSON string escape helper
func Cannoli_json_escape(str $s) str {
    my str $result = "";
    my int $len = length($s);
    my int $i = 0;

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        my int $code = ord($ch);

        if ($ch eq "\"") {
            $result = $result . "\\\"";
        } elsif ($ch eq "\\") {
            $result = $result . "\\\\";
        } elsif ($code == 10) {
            $result = $result . "\\n";
        } elsif ($code == 13) {
            $result = $result . "\\r";
        } elsif ($code == 9) {
            $result = $result . "\\t";
        } else {
            $result = $result . $ch;
        }
        $i = $i + 1;
    }

    return $result;
}

# ===== Error handling methods =====

# Get the error code (set when error handler is called)
func Cannoli_error_code(scalar $self) int {
    if (exists(%{$self}, "_error_code")) {
        return $self->{"_error_code"};
    }
    return 0;
}

# Get the error message (set when error handler is called)
func Cannoli_error_message(scalar $self) str {
    if (exists(%{$self}, "_error_message")) {
        return $self->{"_error_message"};
    }
    return "";
}

# Throw an exception (will be caught by error handler)
func Cannoli_throw_error(scalar $self, str $message) void {
    defined($self);
    throw $message;
}

# Render a custom error page
func Cannoli_render_error(scalar $self, int $code, str $message) void {
    $self->status($code);
    $self->content_type("text/html");

    my str $title = Cannoli::Response::status_message($code);

    my str $html = "<!DOCTYPE html>\n";
    $html = $html . "<html><head><title>" . $code . " " . $title . "</title>\n";
    $html = $html . "<style>\n";
    $html = $html . "body { font-family: sans-serif; text-align: center; padding: 50px; }\n";
    $html = $html . "h1 { color: #333; }\n";
    $html = $html . ".code { font-size: 72px; color: #e74c3c; }\n";
    $html = $html . ".message { color: #666; margin-top: 20px; }\n";
    $html = $html . "</style></head><body>\n";
    $html = $html . "<div class=\"code\">" . $code . "</div>\n";
    $html = $html . "<h1>" . $title . "</h1>\n";
    if (length($message) > 0) {
        $html = $html . "<p class=\"message\">" . Cannoli::Response::html_escape($message) . "</p>\n";
    }
    $html = $html . "</body></html>\n";

    $self->write_body($html);
}

# ===== Compression methods =====

# Enable gzip compression for this response
func Cannoli_compress(scalar $self) void {
    $self->{"_compress"} = 1;
}

# Enable auto-compression (based on Accept-Encoding)
func Cannoli_auto_compress(scalar $self) void {
    $self->{"_auto_compress"} = 1;
}

# Check if compression is enabled
func Cannoli_is_compress_enabled(scalar $self) int {
    if (exists(%{$self}, "_compress")) {
        return $self->{"_compress"};
    }
    if (exists(%{$self}, "_auto_compress")) {
        return $self->{"_auto_compress"};
    }
    return 0;
}

# ===== Session methods =====

# Get or create Cannoli_session(lazy loading from cookie)
func Cannoli_session(scalar $self) scalar {
    # Return cached session if already loaded
    if (exists(%{$self}, "_session")) {
        return $self->{"_session"};
    }

    # Try to load from session cookie
    my str $cookie_name = Cannoli::Session::cookie_name();
    my str $session_id = "";

    # Get cookies from request headers
    my scalar $hdrs = $self->{"_headers"};
    if (exists(%{$hdrs}, "cookie")) {
        my str $cookie_header = $hdrs->{"cookie"};
        # Parse cookies (format: name=value; name2=value2)
        my array @cookies = split($cookie_header, "; ");
        my int $i = 0;
        while ($i < scalar(@cookies)) {
            my str $cookie = $cookies[$i];
            my int $eq_pos = index($cookie, "=");
            if ($eq_pos > 0) {
                my str $name = substr($cookie, 0, $eq_pos);
                my str $value = substr($cookie, $eq_pos + 1, length($cookie) - $eq_pos - 1);
                if ($name eq $cookie_name) {
                    $session_id = $value;
                    last;
                }
            }
            $i = $i + 1;
        }
    }

    my scalar $session = undef;

    # Try to load existing session
    if (length($session_id) > 0) {
        $session = Cannoli::Session::load($session_id);
    }

    # Create new session if not found
    if (!defined($session)) {
        $session = Cannoli::Session::new();
        $self->{"_session_new"} = 1;  # Flag to set cookie
    }

    $self->{"_session"} = $session;
    return $session;
}

# Get a value from session
func Cannoli_session_get(scalar $self, str $key) scalar {
    my scalar $session = $self->session();
    return Cannoli::Session::get($session, $key);
}

# Set a value in session
func Cannoli_session_set(scalar $self, str $key, scalar $value) scalar {
    my scalar $session = $self->session();
    Cannoli::Session::set($session, $key, $value);
    return $self;
}

# Check if session has a key
func Cannoli_session_has(scalar $self, str $key) int {
    my scalar $session = $self->session();
    return Cannoli::Session::has($session, $key);
}

# Delete a value from session
func Cannoli_session_delete(scalar $self, str $key) scalar {
    my scalar $session = $self->session();
    Cannoli::Session::delete($session, $key);
    return $self;
}

# Save session and set cookie if new
func Cannoli_session_save(scalar $self) scalar {
    if (!exists(%{$self}, "_session")) {
        return $self;
    }

    my scalar $session = $self->{"_session"};
    Cannoli::Session::save($session);

    # Set session cookie if this is a new session
    if (exists(%{$self}, "_session_new") && $self->{"_session_new"} == 1) {
        my str $cookie_name = Cannoli::Session::cookie_name();
        my str $session_id = Cannoli::Session::id($session);
        my int $ttl = Cannoli::Session::ttl();
        $self->set_cookie($cookie_name, $session_id, "/", $ttl, 1, 0);
        $self->{"_session_new"} = 0;
    }

    return $self;
}

# Destroy session and clear cookie
func Cannoli_session_destroy(scalar $self) scalar {
    if (exists(%{$self}, "_session")) {
        my scalar $session = $self->{"_session"};
        my str $session_id = Cannoli::Session::id($session);
        Cannoli::Session::destroy($session_id);

        # Clear cookie by setting max-age to 0
        my str $cookie_name = Cannoli::Session::cookie_name();
        $self->set_cookie($cookie_name, "", "/", 0, 1, 0);

        $self->{"_session"} = undef;
    }

    return $self;
}

# Get session ID
func Cannoli_session_id(scalar $self) str {
    my scalar $session = $self->session();
    return Cannoli::Session::id($session);
}

# ===== Template methods =====

# Render a template and set response body
func Cannoli_render(scalar $self, str $template_name, scalar $vars) scalar {
    my str $html = Cannoli::Template::render($template_name, $vars);
    if (length($self->{"_res_content_type"}) == 0) {
        $self->content_type("text/html; charset=utf-8");
    }
    $self->write_body($html);
    return $self;
}

# Render a template with HTML escaping (safe mode)
func Cannoli_render_safe(scalar $self, str $template_name, scalar $vars) scalar {
    my str $html = Cannoli::Template::render_safe($template_name, $vars);
    if (length($self->{"_res_content_type"}) == 0) {
        $self->content_type("text/html; charset=utf-8");
    }
    $self->write_body($html);
    return $self;
}

# Render a template with a layout
func Cannoli_render_with_layout(scalar $self, str $template_name, str $layout_name, scalar $vars) scalar {
    my str $html = Cannoli::Template::render_with_layout($template_name, $layout_name, $vars);
    if (length($self->{"_res_content_type"}) == 0) {
        $self->content_type("text/html; charset=utf-8");
    }
    $self->write_body($html);
    return $self;
}

# Render a template string directly
func Cannoli_render_string(scalar $self, str $template, scalar $vars) scalar {
    my str $html = Cannoli::Template::render_string($template, $vars);
    if (length($self->{"_res_content_type"}) == 0) {
        $self->content_type("text/html; charset=utf-8");
    }
    $self->write_body($html);
    return $self;
}

# ===== Validation methods =====

# Create a validator from rules hash
# rules format: { "email" => ["required", "email"], "password" => ["required", "min_length:8"] }
func Cannoli_validate(scalar $self, scalar $rules) scalar {
    my scalar $params = $self->{"_params"};

    # Also include JSON body params if available
    if ($self->is_json() == 1) {
        my scalar $json_body = $self->json_body();
        if (defined($json_body) && ref($json_body) eq "HASH") {
            # Merge JSON body into Cannoli_params(JSON takes precedence)
            my array @json_keys = keys(%{$json_body});
            my int $i = 0;
            while ($i < scalar(@json_keys)) {
                my str $key = $json_keys[$i];
                $params->{$key} = $json_body->{$key};
                $i = $i + 1;
            }
        }
    }

    return Cannoli::Validation::from_rules($params, $rules);
}

# Validate and return JSON error response if invalid
# Returns 1 if valid, 0 if invalid (and sets error response)
func Cannoli_validate_or_error(scalar $self, scalar $rules) int {
    my scalar $v = $self->validate($rules);

    if (Cannoli::Validation::validate($v) == 0) {
        my scalar $errors = Cannoli::Validation::errors($v);
        $self->status(400);
        $self->content_type("application/json");
        $self->render_json({"errors" => $errors});
        return 0;
    }

    return 1;
}

# ===== CORS methods =====

# Set CORS headers for cross-origin requests
# Usage: $c->cors("*") or $c->cors("https://example.com")
func Cannoli_cors(scalar $self, str $origin) scalar {
    $self->set_header("Access-Control-Allow-Origin", $origin);
    $self->set_header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS");
    $self->set_header("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With");
    $self->set_header("Access-Control-Max-Age", "86400");
    return $self;
}

# Set CORS headers with custom options
# $options: { "methods" => "GET,POST", "headers" => "X-Custom", "credentials" => 1, "max_age" => 3600 }
func Cannoli_cors_options(scalar $self, str $origin, scalar $options) scalar {
    $self->set_header("Access-Control-Allow-Origin", $origin);

    if (defined($options)) {
        if (exists(%{$options}, "methods")) {
            $self->set_header("Access-Control-Allow-Methods", $options->{"methods"});
        } else {
            $self->set_header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS");
        }

        if (exists(%{$options}, "headers")) {
            $self->set_header("Access-Control-Allow-Headers", $options->{"headers"});
        } else {
            $self->set_header("Access-Control-Allow-Headers", "Content-Type, Authorization");
        }

        if (exists(%{$options}, "credentials") && $options->{"credentials"} == 1) {
            $self->set_header("Access-Control-Allow-Credentials", "true");
        }

        if (exists(%{$options}, "max_age")) {
            $self->set_header("Access-Control-Max-Age", "" . $options->{"max_age"});
        } else {
            $self->set_header("Access-Control-Max-Age", "86400");
        }
    }

    return $self;
}

# Handle OPTIONS preflight request (returns 1 if handled, 0 otherwise)
func Cannoli_handle_preflight(scalar $self, str $origin) int {
    if ($self->method() ne "OPTIONS") {
        return 0;
    }

    $self->cors($origin);
    $self->status(204);
    return 1;
}

# ===== Flash message methods =====

# Set a flash message (stored in session, cleared after read)
func Cannoli_flash(scalar $self, str $key, str $message) scalar {
    my scalar $session = $self->session();
    my scalar $flash = Cannoli::Session::get($session, "_flash");

    if (!defined($flash)) {
        $flash = {};
    }

    $flash->{$key} = $message;
    Cannoli::Session::set($session, "_flash", $flash);

    return $self;
}

# Get and clear a flash message
func Cannoli_get_flash(scalar $self, str $key) str {
    my scalar $session = $self->session();
    my scalar $flash = Cannoli::Session::get($session, "_flash");

    if (!defined($flash)) {
        return "";
    }

    if (!exists(%{$flash}, $key)) {
        return "";
    }

    my str $message = $flash->{$key};

    # Remove the message after reading - create new hash without this key
    my hash %new_flash = ();
    my array @flash_keys = keys(%{$flash});
    my int $i = 0;
    while ($i < scalar(@flash_keys)) {
        my str $k = $flash_keys[$i];
        if ($k ne $key) {
            $new_flash{$k} = $flash->{$k};
        }
        $i = $i + 1;
    }
    Cannoli::Session::set($session, "_flash", \%new_flash);

    return $message;
}

# Check if a flash message exists
func Cannoli_has_flash(scalar $self, str $key) int {
    my scalar $session = $self->session();
    my scalar $flash = Cannoli::Session::get($session, "_flash");

    if (!defined($flash)) {
        return 0;
    }

    return exists(%{$flash}, $key);
}

# Get all flash messages and clear them
func Cannoli_get_all_flash(scalar $self) scalar {
    my scalar $session = $self->session();
    my scalar $flash = Cannoli::Session::get($session, "_flash");

    if (!defined($flash)) {
        my hash %empty = ();
        return \%empty;
    }

    # Clear all flash messages
    Cannoli::Session::set($session, "_flash", {});

    return $flash;
}

# Common flash types
func Cannoli_flash_success(scalar $self, str $message) scalar {
    return $self->flash("success", $message);
}

func Cannoli_flash_error(scalar $self, str $message) scalar {
    return $self->flash("error", $message);
}

func Cannoli_flash_warning(scalar $self, str $message) scalar {
    return $self->flash("warning", $message);
}

func Cannoli_flash_info(scalar $self, str $message) scalar {
    return $self->flash("info", $message);
}

# ============================================================
# Basic Auth Helpers
# ============================================================

# Base64 decoding table (global)
my hash %g_b64_decode = ();

# Initialize base64 decode table
func Cannoli_init_base64() void {
    my str $chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    my int $i = 0;
    while ($i < 64) {
        my str $ch = substr($chars, $i, 1);
        $g_b64_decode{$ch} = $i;
        $i = $i + 1;
    }
    $g_b64_decode{"="} = 0;
}

# Decode base64 string
func Cannoli_base64_decode(str $encoded) str {
    # Initialize table if needed
    if (scalar(keys(%g_b64_decode)) == 0) {
        Cannoli_init_base64();
    }

    my str $result = "";
    my int $len = length($encoded);
    my int $i = 0;

    while ($i < $len) {
        # Get 4 characters
        my str $c1 = substr($encoded, $i, 1);
        my str $c2 = "";
        my str $c3 = "";
        my str $c4 = "";

        if ($i + 1 < $len) { $c2 = substr($encoded, $i + 1, 1); }
        if ($i + 2 < $len) { $c3 = substr($encoded, $i + 2, 1); }
        if ($i + 3 < $len) { $c4 = substr($encoded, $i + 3, 1); }

        # Skip whitespace
        if ($c1 eq " " || $c1 eq "\n" || $c1 eq "\r" || $c1 eq "\t") {
            $i = $i + 1;
            next;
        }

        # Get values from table
        my int $v1 = 0;
        my int $v2 = 0;
        my int $v3 = 0;
        my int $v4 = 0;

        if (exists(%g_b64_decode, $c1)) { $v1 = $g_b64_decode{$c1}; }
        if (exists(%g_b64_decode, $c2)) { $v2 = $g_b64_decode{$c2}; }
        if (exists(%g_b64_decode, $c3)) { $v3 = $g_b64_decode{$c3}; }
        if (exists(%g_b64_decode, $c4)) { $v4 = $g_b64_decode{$c4}; }

        # Decode 4 chars into 3 bytes
        my int $b1 = ($v1 * 4) + ($v2 / 16);
        my int $b2 = (($v2 % 16) * 16) + ($v3 / 4);
        my int $b3 = (($v3 % 4) * 64) + $v4;

        $result = $result . chr($b1);
        if ($c3 ne "=") {
            $result = $result . chr($b2);
        }
        if ($c4 ne "=") {
            $result = $result . chr($b3);
        }

        $i = $i + 4;
    }

    return $result;
}

# Get Basic Auth credentials from request
# Returns hash with {username, password} or undef if not present/invalid
func Cannoli_basic_auth_credentials(scalar $self) scalar {
    my str $auth_header = $self->header_in("Authorization");

    if (length($auth_header) == 0) {
        return undef;
    }

    # Check for "Basic " prefix
    if (length($auth_header) < 7) {
        return undef;
    }

    my str $prefix = substr($auth_header, 0, 6);
    if ($prefix ne "Basic ") {
        return undef;
    }

    # Extract and decode base64 part
    my str $encoded = substr($auth_header, 6, length($auth_header) - 6);
    my str $decoded = Cannoli_base64_decode($encoded);

    # Split on first colon (username:password)
    my int $colon_pos = index($decoded, ":");
    if ($colon_pos < 0) {
        return undef;
    }

    my str $username = substr($decoded, 0, $colon_pos);
    my str $password = substr($decoded, $colon_pos + 1, length($decoded) - $colon_pos - 1);

    my hash %creds = ();
    $creds{"username"} = $username;
    $creds{"password"} = $password;

    return \%creds;
}

# Get Basic Auth username (empty string if not present)
func Cannoli_basic_auth_user(scalar $self) str {
    my scalar $creds = $self->basic_auth_credentials();
    if (!defined($creds)) {
        return "";
    }
    return $creds->{"username"};
}

# Get Basic Auth password (empty string if not present)
func Cannoli_basic_auth_pass(scalar $self) str {
    my scalar $creds = $self->basic_auth_credentials();
    if (!defined($creds)) {
        return "";
    }
    return $creds->{"password"};
}

# Check if valid Basic Auth credentials are present
func Cannoli_has_basic_auth(scalar $self) int {
    my scalar $creds = $self->basic_auth_credentials();
    if (!defined($creds)) {
        return 0;
    }
    return 1;
}

# Send 401 Unauthorized response with WWW-Authenticate header
# Returns a response hash that should be returned from handler
func Cannoli_require_basic_auth(scalar $self, str $realm) hash {
    if (length($realm) == 0) {
        $realm = "Protected Area";
    }

    $self->status(401);
    $self->set_header("WWW-Authenticate", "Basic realm=\"" . $realm . "\"");
    $self->content_type("text/plain");
    $self->write_body("401 Unauthorized\n\nAuthentication required.");
    return $self->build_response();
}

# Validate Basic Auth against a username/password pair
# Returns 1 if valid, 0 if not
func Cannoli_check_basic_auth(scalar $self, str $expected_user, str $expected_pass) int {
    my scalar $creds = $self->basic_auth_credentials();
    if (!defined($creds)) {
        return 0;
    }

    my str $user = $creds->{"username"};
    my str $pass = $creds->{"password"};

    if ($user eq $expected_user && $pass eq $expected_pass) {
        return 1;
    }

    return 0;
}

# Validate Basic Auth using a callback function
# Callback receives (username, password) and returns 1 if valid
func Cannoli_validate_basic_auth(scalar $self, scalar $validator) int {
    my scalar $creds = $self->basic_auth_credentials();
    if (!defined($creds)) {
        return 0;
    }

    my str $user = $creds->{"username"};
    my str $pass = $creds->{"password"};

    return $validator->($user, $pass);
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Router;


# cannoli/src/router.strada - URL Router with regex support
#
# Routes incoming requests to handler functions based on:
# - Exact path matching
# - Regex pattern matching with captures
# - HTTP method filtering
#
# Usage:
#   my scalar $router = Cannoli::Router::new();
#   Cannoli::Router::get($router, "/", \&home_handler);
#   Cannoli::Router::get($router, "/users/([0-9]+)", \&user_handler);
#   Cannoli::Router::post($router, "/api/submit", \&submit_handler);

# Create a new router
func Cannoli_Router_new() scalar {
    my hash %router = ();
    $router{"routes"} = [];
    $router{"not_found_handler"} = undef;
    $router{"error_handler"} = undef;
    $router{"error_code_handlers"} = {};  # Handlers by status code (404, 500, etc.)
    $router{"global_middleware"} = [];    # Middleware run before all routes
    $router{"after_middleware"} = [];     # Middleware run after all routes
    return \%router;
}

# Add global middleware (runs before route handler)
func Cannoli_Router_use(scalar $router, scalar $middleware) void {
    push(@{$router->{"global_middleware"}}, $middleware);
}

# Add global after-middleware (runs after route handler)
func Cannoli_Router_use_after(scalar $router, scalar $middleware) void {
    push(@{$router->{"after_middleware"}}, $middleware);
}

# Internal: Add a route
func Cannoli_Router_add_route(scalar $router, str $method, str $pattern, scalar $handler) void {
    ::add_route_full($router, $method, $pattern, $handler, 0, undef);
}

# Internal: Add a route with Cannoli flag
func Cannoli_Router_add_route_ex(scalar $router, str $method, str $pattern, scalar $handler, int $use_cannoli) void {
    ::add_route_full($router, $method, $pattern, $handler, $use_cannoli, undef);
}

# Internal: Add a route with Cannoli flag and middleware
func Cannoli_Router_add_route_full(scalar $router, str $method, str $pattern, scalar $handler, int $use_cannoli, scalar $middleware) void {
    my hash %route = ();
    $route{"method"} = $method;
    $route{"handler"} = $handler;
    $route{"use_cannoli"} = $use_cannoli;
    $route{"original_pattern"} = $pattern;  # Store original for debugging
    $route{"param_names"} = [];

    # Check for named parameters like :id, :name
    my int $has_named = ::contains_named_params($pattern);

    if ($has_named == 1) {
        # Extract parameter names and convert to regex
        $route{"param_names"} = ::extract_param_names($pattern);
        $route{"pattern"} = ::convert_named_params($pattern);
        $route{"is_regex"} = 1;  # Named params require regex matching
    } else {
        $route{"pattern"} = $pattern;
        $route{"is_regex"} = ::contains_regex_chars($pattern);
    }

    # Store route-specific middleware
    if (defined($middleware)) {
        $route{"middleware"} = $middleware;
    } else {
        $route{"middleware"} = [];
    }

    my scalar $routes = $router->{"routes"};
    push(@{$routes}, \%route);
}

# Check if pattern contains regex special characters
func Cannoli_Router_contains_regex_chars(str $pattern) int {
    # Check for common regex patterns
    if (index($pattern, "(") >= 0) { return 1; }
    if (index($pattern, "[") >= 0) { return 1; }
    if (index($pattern, "*") >= 0) { return 1; }
    if (index($pattern, "+") >= 0) { return 1; }
    if (index($pattern, "?") >= 0) { return 1; }
    if (index($pattern, "^") >= 0) { return 1; }
    if (index($pattern, "$") >= 0) { return 1; }
    if (index($pattern, "|") >= 0) { return 1; }
    if (index($pattern, ".") >= 0) { return 1; }
    return 0;
}

# Check if pattern contains named parameters (e.g., :id, :name)
func Cannoli_Router_contains_named_params(str $pattern) int {
    if (index($pattern, ":") >= 0) { return 1; }
    return 0;
}

# Extract parameter names from pattern (e.g., "/users/:id/posts/:post_id" -> ["id", "post_id"])
func Cannoli_Router_extract_param_names(str $pattern) scalar {
    my array @names = ();
    my int $len = length($pattern);
    my int $i = 0;

    while ($i < $len) {
        my str $ch = substr($pattern, $i, 1);

        if ($ch eq ":") {
            # Found start of param name, extract until / or end
            my str $name = "";
            $i = $i + 1;

            while ($i < $len) {
                $ch = substr($pattern, $i, 1);
                if ($ch eq "/" || $ch eq "-" || $ch eq ".") {
                    last;
                }
                $name = $name . $ch;
                $i = $i + 1;
            }

            if (length($name) > 0) {
                push(@names, $name);
            }
        } else {
            $i = $i + 1;
        }
    }

    return \@names;
}

# Convert named params to regex: "/users/:id/posts/:post_id" -> "/users/([^/]+)/posts/([^/]+)"
func Cannoli_Router_convert_named_params(str $pattern) str {
    my str $result = "";
    my int $len = length($pattern);
    my int $i = 0;

    while ($i < $len) {
        my str $ch = substr($pattern, $i, 1);

        if ($ch eq ":") {
            # Replace :param with capture group
            $result = $result . "([^/]+)";

            # Skip the parameter name
            $i = $i + 1;
            while ($i < $len) {
                $ch = substr($pattern, $i, 1);
                if ($ch eq "/" || $ch eq "-" || $ch eq ".") {
                    last;
                }
                $i = $i + 1;
            }
        } else {
            $result = $result . $ch;
            $i = $i + 1;
        }
    }

    return $result;
}

# Add GET route
func Cannoli_Router_get(scalar $router, str $pattern, scalar $handler) void {
    ::add_route($router, "GET", $pattern, $handler);
}

# Add POST route
func Cannoli_Router_post(scalar $router, str $pattern, scalar $handler) void {
    ::add_route($router, "POST", $pattern, $handler);
}

# Add PUT route
func Cannoli_Router_put(scalar $router, str $pattern, scalar $handler) void {
    ::add_route($router, "PUT", $pattern, $handler);
}

# Add DELETE route
func Cannoli_Router_delete_route(scalar $router, str $pattern, scalar $handler) void {
    ::add_route($router, "DELETE", $pattern, $handler);
}

# Add route for any method
func Cannoli_Router_any(scalar $router, str $pattern, scalar $handler) void {
    ::add_route($router, "*", $pattern, $handler);
}

# Set 404 handler
func Cannoli_Router_set_not_found(scalar $router, scalar $handler) void {
    $router->{"not_found_handler"} = $handler;
}

# Set error handler (generic catch-all)
func Cannoli_Router_set_error_handler(scalar $router, scalar $handler) void {
    $router->{"error_handler"} = $handler;
}

# Set error handler for specific status code (404, 500, etc.)
func Cannoli_Router_set_error_code_handler(scalar $router, int $code, scalar $handler) void {
    my scalar $handlers = $router->{"error_code_handlers"};
    my str $code_key = "" . $code;
    $handlers->{$code_key} = $handler;
}

# Get error handler for a specific code
func Cannoli_Router_get_error_handler(scalar $router, int $code) scalar {
    my scalar $handlers = $router->{"error_code_handlers"};
    my str $code_key = "" . $code;
    if (exists(%{$handlers}, $code_key)) {
        return $handlers->{$code_key};
    }
    return undef;
}

#
# Cannoli-style route registration (handlers receive Cannoli object)
#

# Add GET route with Cannoli handler
func Cannoli_Router_get_c(scalar $router, str $pattern, scalar $handler) void {
    ::add_route_ex($router, "GET", $pattern, $handler, 1);
}

# Add POST route with Cannoli handler
func Cannoli_Router_post_c(scalar $router, str $pattern, scalar $handler) void {
    ::add_route_ex($router, "POST", $pattern, $handler, 1);
}

# Add PUT route with Cannoli handler
func Cannoli_Router_put_c(scalar $router, str $pattern, scalar $handler) void {
    ::add_route_ex($router, "PUT", $pattern, $handler, 1);
}

# Add DELETE route with Cannoli handler
func Cannoli_Router_delete_c(scalar $router, str $pattern, scalar $handler) void {
    ::add_route_ex($router, "DELETE", $pattern, $handler, 1);
}

# Add PATCH route with Cannoli handler
func Cannoli_Router_patch_c(scalar $router, str $pattern, scalar $handler) void {
    ::add_route_ex($router, "PATCH", $pattern, $handler, 1);
}

# Add route for any method with Cannoli handler
func Cannoli_Router_any_c(scalar $router, str $pattern, scalar $handler) void {
    ::add_route_ex($router, "*", $pattern, $handler, 1);
}

#
# Cannoli-style route registration with middleware
#

# Add GET route with Cannoli handler and middleware
func Cannoli_Router_get_m(scalar $router, str $pattern, scalar $handler, scalar $middleware) void {
    ::add_route_full($router, "GET", $pattern, $handler, 1, $middleware);
}

# Add POST route with Cannoli handler and middleware
func Cannoli_Router_post_m(scalar $router, str $pattern, scalar $handler, scalar $middleware) void {
    ::add_route_full($router, "POST", $pattern, $handler, 1, $middleware);
}

# Add PUT route with Cannoli handler and middleware
func Cannoli_Router_put_m(scalar $router, str $pattern, scalar $handler, scalar $middleware) void {
    ::add_route_full($router, "PUT", $pattern, $handler, 1, $middleware);
}

# Add DELETE route with Cannoli handler and middleware
func Cannoli_Router_delete_m(scalar $router, str $pattern, scalar $handler, scalar $middleware) void {
    ::add_route_full($router, "DELETE", $pattern, $handler, 1, $middleware);
}

# Add PATCH route with Cannoli handler and middleware
func Cannoli_Router_patch_m(scalar $router, str $pattern, scalar $handler, scalar $middleware) void {
    ::add_route_full($router, "PATCH", $pattern, $handler, 1, $middleware);
}

# Add route for any method with Cannoli handler and middleware
func Cannoli_Router_any_m(scalar $router, str $pattern, scalar $handler, scalar $middleware) void {
    ::add_route_full($router, "*", $pattern, $handler, 1, $middleware);
}

# Match a request against routes and return the matching route
func Cannoli_Router_match(scalar $router, hash %req) scalar {
    my str $method = $req{"method"};
    my str $path = $req{"path"};
    my scalar $routes = $router->{"routes"};
    my int $num_routes = scalar(@{$routes});

    my int $i = 0;
    while ($i < $num_routes) {
        my scalar $route = $routes->[$i];
        my str $route_method = $route->{"method"};
        my str $route_pattern = $route->{"pattern"};

        # Check method (or * for any)
        # HEAD requests also match GET routes (per HTTP spec)
        my int $method_match = 0;
        if ($route_method eq "*") {
            $method_match = 1;
        } elsif ($route_method eq $method) {
            $method_match = 1;
        } elsif ($route_method eq "GET" && $method eq "HEAD") {
            $method_match = 1;
        }
        if ($method_match == 0) {
            $i = $i + 1;
            next;
        }

        # Check pattern
        my int $is_regex = $route->{"is_regex"};

        if ($is_regex == 0) {
            # Exact match
            if ($path eq $route_pattern) {
                my hash %result = ();
                $result{"route"} = $route;
                $result{"captures"} = [];
                return \%result;
            }
        } else {
            # Regex match
            my str $regex_pattern = "^" . $route_pattern . "$";

            if ($path =~ /$regex_pattern/) {
                # Try to extract captures
                my scalar $caps = capture($path, $regex_pattern);
                my hash %result = ();
                $result{"route"} = $route;

                if (defined($caps) && scalar(@{$caps}) > 1) {
                    # Skip index 0 (full match), return only capture groups
                    my array @groups = ();
                    my int $j = 1;
                    my int $num_caps = scalar(@{$caps});
                    while ($j < $num_caps) {
                        push(@groups, $caps->[$j]);
                        $j = $j + 1;
                    }
                    $result{"captures"} = \@groups;
                } else {
                    $result{"captures"} = [];
                }

                return \%result;
            }
        }

        $i = $i + 1;
    }

    return undef;
}

# Execute middleware chain recursively
# $middlewares: array of middleware functions
# $c: Cannoli object
# $idx: current index in middleware array
# $final_handler: the route handler to call after all middleware
func Cannoli_Router_run_middleware_chain(scalar $middlewares, scalar $c, int $idx, scalar $final_handler) hash {
    my int $num_middleware = scalar(@{$middlewares});

    # If we've run all middleware, call the final handler
    if ($idx >= $num_middleware) {
        $final_handler->($c);
        return $c->build_response();
    }

    # Get current middleware
    my scalar $mw = $middlewares->[$idx];

    # Create the next function that continues the chain
    my scalar $next_fn = func (scalar $ctx) {
        return ::run_middleware_chain($middlewares, $ctx, $idx + 1, $final_handler);
    };

    # Call middleware with context and next function
    return $mw->($c, $next_fn);
}

# Dispatch a request to the appropriate handler (with middleware support)
func Cannoli_Router_dispatch(scalar $router, hash %req) hash {
    my scalar $match_result = ::match($router, %req);

    if (!defined($match_result)) {
        # No route matched - check for custom 404 handlers
        # First try error code handler
        my scalar $code_handler = ::get_error_handler($router, 404);
        if (defined($code_handler)) {
            my scalar $c = Cannoli::new(%req);
            $c->{"_error_code"} = 404;
            $code_handler->($c);
            return $c->build_response();
        }

        # Then try the legacy not_found_handler
        my scalar $not_found = $router->{"not_found_handler"};
        if (defined($not_found)) {
            return $not_found->(%req);
        }

        # Default 404 response
        return Cannoli::Response::not_found();
    }

    # Get the matched route and captures
    my scalar $route = $match_result->{"route"};
    my scalar $captures = $match_result->{"captures"};

    # Store captures in request
    $req{"captures"} = $captures;

    # Map captures to named parameters if route has param_names
    my scalar $param_names = $route->{"param_names"};
    if (defined($param_names) && scalar(@{$param_names}) > 0) {
        # Ensure params hash exists
        if (!exists(%req, "params")) {
            $req{"params"} = {};
        }
        my scalar $params = $req{"params"};

        # Map each capture to its named parameter
        my int $num_params = scalar(@{$param_names});
        my int $num_captures = scalar(@{$captures});
        my int $p = 0;

        while ($p < $num_params && $p < $num_captures) {
            my str $name = $param_names->[$p];
            my str $value = $captures->[$p];
            $params->{$name} = $value;
            $p = $p + 1;
        }
    }

    # Get handler and check if it uses Cannoli object
    my scalar $handler = $route->{"handler"};
    my int $use_cannoli = $route->{"use_cannoli"};

    # Execute handler with error handling
    try {
        if ($use_cannoli == 1) {
            # Cannoli-style handler: receives Cannoli object
            my scalar $c = Cannoli::new(%req);

            # Build middleware chain: global -> route-specific -> handler
            my array @all_middleware = ();

            # Add global middleware
            my scalar $global_mw = $router->{"global_middleware"};
            my int $i = 0;
            while ($i < scalar(@{$global_mw})) {
                push(@all_middleware, $global_mw->[$i]);
                $i = $i + 1;
            }

            # Add route-specific middleware
            my scalar $route_mw = $route->{"middleware"};
            if (defined($route_mw)) {
                $i = 0;
                while ($i < scalar(@{$route_mw})) {
                    push(@all_middleware, $route_mw->[$i]);
                    $i = $i + 1;
                }
            }

            # If there's middleware, run the chain
            if (scalar(@all_middleware) > 0) {
                my hash %result = ::run_middleware_chain(\@all_middleware, $c, 0, $handler);

                # Run after-middleware (doesn't affect response, just for cleanup/logging)
                my scalar $after_mw = $router->{"after_middleware"};
                $i = 0;
                while ($i < scalar(@{$after_mw})) {
                    my scalar $mw = $after_mw->[$i];
                    # After middleware just receives $c, no next
                    $mw->($c);
                    $i = $i + 1;
                }

                return %result;
            } else {
                # No middleware, call handler directly
                $handler->($c);

                # Run after-middleware
                my scalar $after_mw = $router->{"after_middleware"};
                $i = 0;
                while ($i < scalar(@{$after_mw})) {
                    my scalar $mw = $after_mw->[$i];
                    $mw->($c);
                    $i = $i + 1;
                }

                return $c->build_response();
            }
        } else {
            # Classic handler: receives hash, returns hash (no middleware support)
            my hash %result = $handler->(%req);
            return %result;
        }
    } catch ($error) {
        # Handler threw an exception - use 500 error handler
        # First try error code handler
        my scalar $code_handler = ::get_error_handler($router, 500);
        if (defined($code_handler)) {
            my scalar $c = Cannoli::new(%req);
            $c->{"_error_code"} = 500;
            $c->{"_error_message"} = $error;
            $code_handler->($c);
            return $c->build_response();
        }

        # Then try generic error handler
        my scalar $err_handler = $router->{"error_handler"};
        if (defined($err_handler)) {
            $req{"_error"} = $error;
            return $err_handler->(%req);
        }

        # Default 500 response
        return Cannoli::Response::internal_error($error);
    }
}

# Print all registered routes (for debugging)
func Cannoli_Router_dump_routes(scalar $router) void {
    say("=== Registered Routes ===");
    my scalar $routes = $router->{"routes"};
    my int $num_routes = scalar(@{$routes});
    my int $i = 0;

    while ($i < $num_routes) {
        my scalar $route = $routes->[$i];
        my str $method = $route->{"method"};
        my str $pattern = $route->{"pattern"};
        my int $is_regex = $route->{"is_regex"};
        my scalar $param_names = $route->{"param_names"};

        my str $type = "exact";
        if ($is_regex == 1) {
            $type = "regex";
        }

        # Use original pattern for display if it has named params
        my str $display_pattern = $pattern;
        if (exists(%{$route}, "original_pattern")) {
            my str $orig = $route->{"original_pattern"};
            if ($orig ne $pattern) {
                $display_pattern = $orig;
            }
        }

        my str $line = "  " . $method . " " . $display_pattern . " (" . $type . ")";

        # Show param names if present
        if (defined($param_names) && scalar(@{$param_names}) > 0) {
            $line = $line . " params: ";
            my int $j = 0;
            while ($j < scalar(@{$param_names})) {
                if ($j > 0) { $line = $line . ", "; }
                $line = $line . ":" . $param_names->[$j];
                $j = $j + 1;
            }
        }

        say($line);
        $i = $i + 1;
    }
    say("");
}

# Group routes under a common prefix
func Cannoli_Router_group(scalar $router, str $prefix, scalar $setup_func) void {
    # Create a sub-router that prefixes all patterns
    my scalar $sub_router = ::new();

    # Call the setup function to register routes on sub-router
    $setup_func->($sub_router);

    # Copy routes from sub-router to main router with prefix
    my scalar $sub_routes = $sub_router->{"routes"};
    my int $num = scalar(@{$sub_routes});
    my int $i = 0;

    while ($i < $num) {
        my scalar $route = $sub_routes->[$i];
        my str $pattern = $prefix . $route->{"pattern"};
        ::add_route($router, $route->{"method"}, $pattern, $route->{"handler"});
        $i = $i + 1;
    }
}

# Guess content type from file extension
func Cannoli_Router_guess_content_type(str $filename) str {
    my str $ext = sys::file_ext($filename);

    if ($ext eq "html" || $ext eq "htm") { return "text/html; charset=utf-8"; }
    if ($ext eq "css") { return "text/css"; }
    if ($ext eq "js") { return "application/javascript"; }
    if ($ext eq "json") { return "application/json"; }
    if ($ext eq "xml") { return "application/xml"; }
    if ($ext eq "txt") { return "text/plain"; }
    if ($ext eq "png") { return "image/png"; }
    if ($ext eq "jpg" || $ext eq "jpeg") { return "image/jpeg"; }
    if ($ext eq "gif") { return "image/gif"; }
    if ($ext eq "svg") { return "image/svg+xml"; }
    if ($ext eq "ico") { return "image/x-icon"; }
    if ($ext eq "pdf") { return "application/pdf"; }
    if ($ext eq "zip") { return "application/zip"; }

    return "application/octet-stream";
}

# ============================================================
# Built-in Middleware
# ============================================================

# Compression middleware - automatically compresses responses
# Usage: Cannoli::Router::use($router, \&Cannoli_Router_compression_middleware);
func Cannoli_Router_compression_middleware(scalar $c, scalar $next_fn) hash {
    # Enable auto-compression based on Accept-Encoding
    $c->auto_compress();

    # Continue to next handler
    return $next_fn->($c);
}

# Logging middleware - logs all requests
# Usage: Cannoli::Router::use($router, \&Cannoli_Router_logging_middleware);
func Cannoli_Router_logging_middleware(scalar $c, scalar $next_fn) hash {
    my str $method = $c->method();
    my str $path = $c->path();
    my str $remote = $c->remote_addr();

    # Log request start
    say("[" . $remote . "] " . $method . " " . $path);

    # Continue to handler
    return $next_fn->($c);
}

# CORS middleware - adds CORS headers
# Usage: Cannoli::Router::use($router, Cannoli::Router::cors_middleware("*"));
func Cannoli_Router_cors_middleware(str $origin) scalar {
    return func (scalar $c, scalar $next_fn) {
        # Add CORS headers
        $c->set_header("Access-Control-Allow-Origin", $origin);
        $c->set_header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS");
        $c->set_header("Access-Control-Allow-Headers", "Content-Type, Authorization");

        # Handle preflight OPTIONS request
        if ($c->method() eq "OPTIONS") {
            $c->status(204);
            return $c->build_response();
        }

        return $next_fn->($c);
    };
}

# Session middleware - ensures session is saved after request
# Usage: Cannoli::Router::use_after($router, \&Cannoli_Router_session_middleware);
func Cannoli_Router_session_middleware(scalar $c) void {
    # Save session if it was accessed
    $c->session_save();
}

# ============================================================
# Rate Limiting Middleware
# ============================================================

# Global rate limit storage (in-memory, resets on restart)
# Format: { "ip:key" => { "count" => N, "reset_at" => timestamp } }
my hash %g_rate_limits = ();

# Rate limiting middleware factory
# $requests: max requests allowed
# $window: time window in seconds
# $key: optional key for different limiters (default: "default")
#
# Usage:
#   Cannoli::Router::use($router, Cannoli::Router::rate_limit(100, 60));  # 100 req/min
#   Cannoli::Router::use($router, Cannoli::Router::rate_limit(10, 60, "api"));  # 10 req/min for API
#
func Cannoli_Router_rate_limit(int $requests, int $window, str $key) scalar {
    if (length($key) == 0) {
        $key = "default";
    }

    return func (scalar $c, scalar $next_fn) {
        my str $ip = $c->remote_addr();
        my str $limit_key = $ip . ":" . $key;
        my int $now = sys::time();

        # Get or create rate limit entry
        my scalar $entry = undef;
        if (exists(%g_rate_limits, $limit_key)) {
            $entry = $g_rate_limits{$limit_key};
        }

        # Check if window expired and reset
        if (defined($entry)) {
            my int $reset_at = $entry->{"reset_at"};
            if ($now >= $reset_at) {
                # Window expired, reset counter
                $entry->{"count"} = 0;
                $entry->{"reset_at"} = $now + $window;
            }
        } else {
            # Create new entry
            $entry = {
                "count" => 0,
                "reset_at" => $now + $window
            };
            $g_rate_limits{$limit_key} = $entry;
        }

        # Increment counter
        my int $count = $entry->{"count"} + 1;
        $entry->{"count"} = $count;

        # Calculate remaining
        my int $remaining = $requests - $count;
        if ($remaining < 0) {
            $remaining = 0;
        }

        # Add rate limit headers
        $c->set_header("X-RateLimit-Limit", "" . $requests);
        $c->set_header("X-RateLimit-Remaining", "" . $remaining);
        $c->set_header("X-RateLimit-Reset", "" . $entry->{"reset_at"});

        # Check if over limit
        if ($count > $requests) {
            my int $retry_after = $entry->{"reset_at"} - $now;
            $c->set_header("Retry-After", "" . $retry_after);
            $c->status(429);
            $c->content_type("application/json");
            $c->write_body("{\"error\":\"Too Many Requests\",\"retry_after\":" . $retry_after . "}");
            return $c->build_response();
        }

        # Continue to next handler
        return $next_fn->($c);
    };
}

# Simple rate limit middleware with default key
# Usage: Cannoli::Router::use($router, Cannoli::Router::rate_limit_simple(100, 60));  # 100 req/min
func Cannoli_Router_rate_limit_simple(int $requests, int $window) scalar {
    return ::rate_limit($requests, $window, "default");
}

# Note: rate_limit_path removed due to compiler bug with regex interpolation
# in closures. Use rate_limit with a custom key instead, and check paths
# manually in your middleware if needed.

# Clear rate limit for an IP (useful for testing or after successful auth)
func Cannoli_Router_rate_limit_clear(str $ip, str $key) void {
    if (length($key) == 0) {
        $key = "default";
    }
    my str $limit_key = $ip . ":" . $key;
    if (exists(%g_rate_limits, $limit_key)) {
        # Set to undef to effectively remove (can't delete from global hash in closure)
        $g_rate_limits{$limit_key} = undef;
    }
}

# Get current rate limit status for an IP
func Cannoli_Router_rate_limit_status(str $ip, str $key) scalar {
    if (length($key) == 0) {
        $key = "default";
    }
    my str $limit_key = $ip . ":" . $key;
    if (exists(%g_rate_limits, $limit_key)) {
        return $g_rate_limits{$limit_key};
    }
    return undef;
}

# ============================================================
# Basic Auth Middleware
# ============================================================

# Basic auth middleware with simple username/password check
# Usage: Cannoli::Router::use($router, Cannoli::Router::basic_auth("admin", "secret", "Admin Area"));
func Cannoli_Router_basic_auth(str $username, str $password, str $realm) scalar {
    if (length($realm) == 0) {
        $realm = "Protected Area";
    }

    return func (scalar $c, scalar $next_fn) {
        if ($c->check_basic_auth($username, $password) == 1) {
            return $next_fn->($c);
        }
        return $c->require_basic_auth($realm);
    };
}

# Basic auth middleware with validator callback
# Usage: Cannoli::Router::use($router, Cannoli::Router::basic_auth_validate(\&check_user, "Members Only"));
# Validator receives (username, password) and returns 1 if valid
func Cannoli_Router_basic_auth_validate(scalar $validator, str $realm) scalar {
    if (length($realm) == 0) {
        $realm = "Protected Area";
    }

    return func (scalar $c, scalar $next_fn) {
        if ($c->validate_basic_auth($validator) == 1) {
            return $next_fn->($c);
        }
        return $c->require_basic_auth($realm);
    };
}

# Basic auth middleware with user hash lookup
# Usage: Cannoli::Router::use($router, Cannoli::Router::basic_auth_users(\%users, "Admin Panel"));
# Users hash: {"username" => "password", ...}
func Cannoli_Router_basic_auth_users(scalar $users, str $realm) scalar {
    if (length($realm) == 0) {
        $realm = "Protected Area";
    }

    return func (scalar $c, scalar $next_fn) {
        my scalar $creds = $c->basic_auth_credentials();

        if (!defined($creds)) {
            return $c->require_basic_auth($realm);
        }

        my str $user = $creds->{"username"};
        my str $pass = $creds->{"password"};

        if (exists(%{$users}, $user)) {
            my str $expected = $users->{$user};
            if ($pass eq $expected) {
                # Store authenticated user in stash for later access
                $c->stash("auth_user", $user);
                return $next_fn->($c);
            }
        }

        return $c->require_basic_auth($realm);
    };
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Static;


# cannoli/src/static.strada - Static file server

func Cannoli_Static_new() scalar {
    my hash %s = ();
    $s{"document_root"} = ".";
    $s{"index_files"} = "index.html,index.htm";
    $s{"directory_listing"} = 0;
    my hash %aliases = ();
    $s{"aliases"} = \%aliases;
    return \%s;
}

func Cannoli_Static_resolve_path(scalar $srv, str $url) str {
    my scalar $aliases = $srv->{"aliases"};
    my array @keys = keys(%{$aliases});
    my str $best = "";
    my str $target = "";
    my int $i = 0;
    while ($i < scalar(@keys)) {
        my str $prefix = $keys[$i];
        my int $plen = length($prefix);
        my int $ulen = length($url);
        if ($ulen >= $plen) {
            my str $url_prefix = substr($url, 0, $plen);
            if ($url_prefix eq $prefix) {
                my int $blen = length($best);
                if ($plen > $blen) {
                    $best = $prefix;
                    $target = $aliases->{$prefix};
                }
            }
        }
        $i = $i + 1;
    }
    my int $best_len = length($best);
    if ($best_len > 0) {
        my str $rest = "";
        my int $url_len = length($url);
        if ($url_len > $best_len) {
            $rest = substr($url, $best_len, $url_len - $best_len);
        }
        return $target . $rest;
    }
    return $srv->{"document_root"} . $url;
}

func Cannoli_Static_is_safe(str $path) int {
    my int $dotdot = index($path, "..");
    if ($dotdot >= 0) { return 0; }
    return 1;
}

func Cannoli_Static_find_index(scalar $srv, str $dir) str {
    my str $idx_list = $srv->{"index_files"};
    my array @idx = split(",", $idx_list);
    my int $i = 0;
    while ($i < scalar(@idx)) {
        my str $name = trim($idx[$i]);
        my str $path = $dir . "/" . $name;
        if (sys::is_file($path)) { return $path; }
        $i = $i + 1;
    }
    return "";
}

func Cannoli_Static_format_size(int $size) str {
    if ($size < 1024) {
        return $size . " B";
    }
    if ($size < 1048576) {
        my int $kb = $size / 1024;
        return $kb . " KB";
    }
    if ($size < 1073741824) {
        my int $mb = $size / 1048576;
        return $mb . " MB";
    }
    my int $gb = $size / 1073741824;
    return $gb . " GB";
}

func Cannoli_Static_dir_listing(str $dir, str $url) str {
    my str $html = "<!DOCTYPE html>\n<html>\n<head>\n";
    $html = $html . "<title>Index of " . $url . "</title>\n";
    $html = $html . "<style>\n";
    $html = $html . "body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; }\n";
    $html = $html . "h1 { color: #333; border-bottom: 1px solid #ddd; padding-bottom: 10px; }\n";
    $html = $html . "table { border-collapse: collapse; width: 100%; }\n";
    $html = $html . "th, td { text-align: left; padding: 8px 12px; border-bottom: 1px solid #eee; }\n";
    $html = $html . "th { background: #f5f5f5; font-weight: 600; }\n";
    $html = $html . "tr:hover { background: #f9f9f9; }\n";
    $html = $html . "a { color: #0066cc; text-decoration: none; }\n";
    $html = $html . "a:hover { text-decoration: underline; }\n";
    $html = $html . ".icon { margin-right: 8px; }\n";
    $html = $html . ".size { color: #666; }\n";
    $html = $html . "</style>\n</head>\n<body>\n";
    $html = $html . "<h1>Index of " . $url . "</h1>\n";
    $html = $html . "<table>\n<tr><th>Name</th><th>Size</th></tr>\n";

    # Parent directory link
    if ($url ne "/") {
        $html = $html . "<tr><td><span class=\"icon\">&#128193;</span><a href=\"..\">..</a></td><td>-</td></tr>\n";
    }

    # Read directory entries
    my array @entries = sys::readdir_full($dir);
    my int $i = 0;
    while ($i < scalar(@entries)) {
        my str $full_entry = $entries[$i];
        # Extract just the filename from the full path
        my str $name = sys::basename($full_entry);

        # Skip hidden files and . / ..
        my str $first = substr($name, 0, 1);
        if ($first ne ".") {
            my str $href = $name;
            my str $icon = "&#128196;";  # File icon
            my str $size_str = "-";

            if (sys::is_dir($full_entry)) {
                $icon = "&#128193;";  # Folder icon
                $href = $name . "/";
            } else {
                my int $size = sys::file_size($full_entry);
                $size_str = ::format_size($size);
            }

            $html = $html . "<tr><td><span class=\"icon\">" . $icon . "</span>";
            $html = $html . "<a href=\"" . $href . "\">" . $name . "</a></td>";
            $html = $html . "<td class=\"size\">" . $size_str . "</td></tr>\n";
        }
        $i = $i + 1;
    }

    $html = $html . "</table>\n</body>\n</html>\n";
    return $html;
}

func Cannoli_Static_handle_request(scalar $srv, str $method, str $url) hash {
    my hash %res = ();
    if ($method ne "GET" && $method ne "HEAD") { return %res; }

    my int $safe = ::is_safe($url);
    if ($safe == 0) { return Cannoli::Response::error_page(403, "Forbidden"); }

    my str $fs = ::resolve_path($srv, $url);

    if (sys::is_dir($fs)) {
        my str $idx = ::find_index($srv, $fs);
        my int $idx_len = length($idx);
        if ($idx_len > 0) {
            $fs = $idx;
        } else {
            # Check if directory listing is enabled
            my int $listing_enabled = $srv->{"directory_listing"};
            if ($listing_enabled == 1) {
                my str $listing = ::dir_listing($fs, $url);
                $res{"status"} = 200;
                $res{"content_type"} = "text/html";
                $res{"body"} = $listing;
                return %res;
            }
            return Cannoli::Response::error_page(403, "Directory listing disabled");
        }
    }

    if (!sys::is_file($fs)) { return Cannoli::Response::not_found(); }

    my str $content = slurp($fs);
    my str $mime = Cannoli::Mime::type($fs);
    $res{"status"} = 200;
    $res{"content_type"} = $mime;
    $res{"body"} = $content;
    return %res;
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Server;


# cannoli/src/server.strada - Preforking HTTP server
#
# A preforking server that spawns multiple worker processes to handle
# incoming HTTP connections. Based on the classic Unix preforking model.
#
# Features:
#   - Dynamic library loading (multiple libraries supported, comma-separated)
#   - SSL/HTTPS support
#   - Regex and prefix matching with path_info
#
# Library interface:
#   cannoli_dispatch($c) -> response_body
#   $c is a Cannoli object with all request data and response methods

# Create a new server from configuration
# Returns a reference to the server hash
func Cannoli_Server_new(hash %config) scalar {
    my hash %server = ();

    $server{"host"} = Cannoli::Config::get_str(%config, "server.host", "0.0.0.0");
    $server{"port"} = Cannoli::Config::get_int(%config, "server.port", 8080);
    $server{"num_workers"} = Cannoli::Config::get_int(%config, "server.workers", 5);
    $server{"max_requests"} = Cannoli::Config::get_int(%config, "server.max_requests", 1000);
    $server{"timeout"} = Cannoli::Config::get_int(%config, "server.timeout", 30);
    $server{"backlog"} = Cannoli::Config::get_int(%config, "server.backlog", 128);
    $server{"max_body_size"} = Cannoli::Config::get_int(%config, "server.max_body_size", 10485760);
    $server{"max_header_size"} = Cannoli::Config::get_int(%config, "server.max_header_size", 8192);
    $server{"router"} = undef;
    $server{"server_sock"} = undef;
    $server{"running"} = 0;
    $server{"worker_pids"} = [];

    # SSL configuration
    $server{"ssl_enabled"} = Cannoli::Config::get_bool(%config, "ssl.enabled", 0);
    $server{"ssl_port"} = Cannoli::Config::get_int(%config, "ssl.port", 443);
    $server{"ssl_cert"} = Cannoli::Config::get_str(%config, "ssl.cert", "");
    $server{"ssl_key"} = Cannoli::Config::get_str(%config, "ssl.key", "");

    $server{"ssl_ctx"} = undef;
    $server{"ssl_server"} = undef;
    $server{"ssl_lib"} = undef;
    $server{"ssl_accept_fn"} = undef;
    $server{"ssl_read_fn"} = undef;
    $server{"ssl_write_fn"} = undef;
    $server{"ssl_close_fn"} = undef;

    # Dynamic library support
    # New style: library./prefix = path.so (prefix-based routing)
    # Old style: app.library = path1.so,path2.so (chain of responsibility)
    $server{"app_library"} = Cannoli::Config::get_str(%config, "app.library", "");
    $server{"lib_handles"} = [];       # Array of library handles
    $server{"dispatch_funcs"} = [];    # Array of dispatch functions (old style)
    $server{"library_routes"} = [];    # Array of {prefix, dispatch_func} (new style)

    # Load SSL library if SSL is enabled
    if ($server{"ssl_enabled"} == 1) {
        my str $ssl_lib_path = "../lib/ssl/libstrada_ssl.so";
        say("Loading SSL library: " . $ssl_lib_path);
        my scalar $ssl_lib = sys::dl_open($ssl_lib_path);
        if (defined($ssl_lib)) {
            $server{"ssl_lib"} = $ssl_lib;
            $server{"ssl_server_fn"} = sys::dl_sym($ssl_lib, "strada_ssl_server_sv");
            $server{"ssl_accept_fn"} = sys::dl_sym($ssl_lib, "strada_ssl_accept_sv");
            $server{"ssl_read_fn"} = sys::dl_sym($ssl_lib, "strada_ssl_read_str");
            $server{"ssl_write_fn"} = sys::dl_sym($ssl_lib, "strada_ssl_write_str");
            $server{"ssl_close_fn"} = sys::dl_sym($ssl_lib, "strada_ssl_close");
            $server{"ssl_fd_fn"} = sys::dl_sym($ssl_lib, "strada_ssl_fd");
            say("  SSL library loaded");
            if (defined($server{"ssl_server_fn"})) {
                say("  Found strada_ssl_server_sv");
            } else {
                say("  ERROR: strada_ssl_server_sv not found!");
            }
        } else {
            say("  Warning: Could not load SSL library");
            $server{"ssl_enabled"} = 0;
        }
    }

    # Load dynamic libraries if specified
    my str $lib_paths = $server{"app_library"};
    if (length($lib_paths) > 0) {
        my array @paths = split(",", $lib_paths);
        my int $i = 0;
        while ($i < scalar(@paths)) {
            my str $lib_spec = trim($paths[$i]);
            if (length($lib_spec) > 0) {
                # Parse library spec: path.so or path.so:config
                my str $lib_path = $lib_spec;
                my str $lib_config = "";

                # Find first colon (config separator)
                my int $colon_pos = -1;
                my int $k = 0;
                while ($k < length($lib_spec)) {
                    if (substr($lib_spec, $k, 1) eq ":") {
                        $colon_pos = $k;
                        last;
                    }
                    $k = $k + 1;
                }

                if ($colon_pos > 0) {
                    $lib_path = substr($lib_spec, 0, $colon_pos);
                    $lib_config = substr($lib_spec, $colon_pos + 1, length($lib_spec) - $colon_pos - 1);
                }

                say("Loading library: " . $lib_path);
                if (length($lib_config) > 0) {
                    say("  Config: " . $lib_config);
                }

                my scalar $lib = sys::dl_open($lib_path);
                if (defined($lib)) {
                    # Call cannoli_init if it exists (for libraries that need configuration)
                    my scalar $init_sym = sys::dl_sym($lib, "cannoli_init");
                    if (defined($init_sym)) {
                        my int $init_result = sys::dl_call_int_sv($init_sym, [$lib_config]);
                        if ($init_result == 0) {
                            say("  Error: cannoli_init failed");
                            $i = $i + 1;
                            next;
                        }
                        say("  Initialized: cannoli_init");
                    }

                    my scalar $sym = sys::dl_sym($lib, "cannoli_dispatch");
                    if (defined($sym)) {
                        push(@{$server{"lib_handles"}}, $lib);
                        push(@{$server{"dispatch_funcs"}}, $sym);
                        say("  Loaded: cannoli_dispatch");
                    } else {
                        say("  Warning: cannoli_dispatch not found");
                    }
                } else {
                    say("  Error: Could not load library");
                }
            }
            $i = $i + 1;
        }
    }

    # Load prefix-based library routes (new style: library./prefix = path.so:config)
    my scalar $lib_routes = Cannoli::Config::get_library_routes(%config);
    my int $num_routes = scalar(@{$lib_routes});
    if ($num_routes > 0) {
        say("=== Library Routes ===");
        my int $j = 0;
        while ($j < $num_routes) {
            my scalar $route = $lib_routes->[$j];
            my str $prefix = $route->{"prefix"};
            my str $lib_spec = $route->{"path"};

            # Parse library spec: path.so or path.so:config
            my str $lib_path = $lib_spec;
            my str $lib_config = "";

            my int $colon_pos = -1;
            my int $k = 0;
            while ($k < length($lib_spec)) {
                if (substr($lib_spec, $k, 1) eq ":") {
                    $colon_pos = $k;
                    last;
                }
                $k = $k + 1;
            }

            if ($colon_pos > 0) {
                $lib_path = substr($lib_spec, 0, $colon_pos);
                $lib_config = substr($lib_spec, $colon_pos + 1, length($lib_spec) - $colon_pos - 1);
            }

            say("  " . $prefix . " -> " . $lib_path);
            if (length($lib_config) > 0) {
                say("    Config: " . $lib_config);
            }

            my scalar $lib = sys::dl_open($lib_path);
            if (defined($lib)) {
                # Call cannoli_init if it exists
                my scalar $init_sym = sys::dl_sym($lib, "cannoli_init");
                if (defined($init_sym)) {
                    my int $init_result = sys::dl_call_int_sv($init_sym, [$lib_config]);
                    if ($init_result == 0) {
                        say("    Error: cannoli_init failed");
                        $j = $j + 1;
                        next;
                    }
                    say("    Initialized: cannoli_init");
                }

                my scalar $sym = sys::dl_sym($lib, "cannoli_dispatch");
                if (defined($sym)) {
                    push(@{$server{"lib_handles"}}, $lib);
                    my hash %lib_route = ();
                    $lib_route{"prefix"} = $prefix;
                    $lib_route{"dispatch"} = $sym;
                    push(@{$server{"library_routes"}}, \%lib_route);
                    say("    Loaded: cannoli_dispatch");
                } else {
                    say("    Warning: cannoli_dispatch not found");
                }
            } else {
                say("    Error: Could not load library");
            }
            $j = $j + 1;
        }
        say("");
    }

    return \%server;
}

# Set the router for the server
func Cannoli_Server_set_router(scalar $server_ref, scalar $router) void {
    $server_ref->{"router"} = $router;
}

# Create the SSL listening socket
func Cannoli_Server_create_ssl_socket(scalar $server_ref) scalar {
    my int $ssl_port = $server_ref->{"ssl_port"};
    my str $cert = $server_ref->{"ssl_cert"};
    my str $key = $server_ref->{"ssl_key"};
    my scalar $ssl_server_fn = $server_ref->{"ssl_server_fn"};


    if (!defined($ssl_server_fn)) {
        say("Error: SSL library not loaded");
        return undef;
    }

    if (length($cert) == 0 || length($key) == 0) {
        say("Error: SSL cert and key paths required");
        return undef;
    }

    # Call strada_ssl_server(port, cert, key)
    my scalar $ssl_server = sys::dl_call_sv($ssl_server_fn, [$ssl_port, $cert, $key]);

    if (!defined($ssl_server)) {
        say("Error: Could not create SSL server on port " . $ssl_port);
        return undef;
    }

    $server_ref->{"ssl_server"} = $ssl_server;
    say("SSL listening on " . $server_ref->{"host"} . ":" . $ssl_port);

    return $ssl_server;
}

# Create the listening socket
func Cannoli_Server_create_socket(scalar $server_ref) scalar {
    my str $host = $server_ref->{"host"};
    my int $port = $server_ref->{"port"};
    my int $backlog = $server_ref->{"backlog"};

    my scalar $server_sock = sys::socket_server_backlog($port, $backlog);

    if (!defined($server_sock)) {
        say("Error: Could not create server socket on port " . $port);
        return undef;
    }

    # Set non-blocking to prevent thundering herd problem with multiple workers
    # When select() wakes all workers, only one will get the connection;
    # others will get EAGAIN from accept() instead of blocking
    sys::socket_set_nonblocking($server_sock, 1);

    $server_ref->{"server_sock"} = $server_sock;
    say("Listening on " . $host . ":" . $port . " (backlog=" . $backlog . ")");

    return $server_sock;
}

# Serialize request headers hash to string format: "name:value\nname:value\n..."
func Cannoli_Server_serialize_headers(scalar $headers_ref) str {
    my str $result = "";
    my array @keys = keys(%{$headers_ref});
    my int $i = 0;
    while ($i < scalar(@keys)) {
        my str $name = $keys[$i];
        my str $value = $headers_ref->{$name};
        $result = $result . $name . ":" . $value . "\n";
        $i = $i + 1;
    }
    return $result;
}

# Parse a response body from a library into a response hash
# Supports special prefixes:
#   STATUS:xxx:content - custom status code
#   REDIRECT:url - redirect response
#   RESPONSE:status:headers_len:headers:body - full response with headers
# Auto-detects JSON (starts with { or [) and HTML (starts with <)
func Cannoli_Server_parse_response(str $response_body) hash {
    my hash %res = ();

    if (substr($response_body, 0, 9) eq "RESPONSE:") {
        # RESPONSE:status:headers_len:headers:body - full response with custom headers
        # Note: index() with offset arg is buggy, so we use substr + index workaround
        my str $rest = substr($response_body, 9, length($response_body) - 9);
        my int $colon1 = index($rest, ":");
        if ($colon1 > 0) {
            my str $status_str = substr($rest, 0, $colon1);
            my int $status = $status_str + 0;

            $rest = substr($rest, $colon1 + 1, length($rest) - $colon1 - 1);
            my int $colon2 = index($rest, ":");
            if ($colon2 > 0) {
                my str $headers_len_str = substr($rest, 0, $colon2);
                my int $headers_len = $headers_len_str + 0;

                $rest = substr($rest, $colon2 + 1, length($rest) - $colon2 - 1);
                my str $headers_str = substr($rest, 0, $headers_len);

                # Body is after headers and the separating colon
                my str $content = substr($rest, $headers_len + 1, length($rest) - $headers_len - 1);

                # Start with text response, then override headers
                %res = Cannoli::Response::text($status, $content);
                my scalar $res_headers = $res{"headers"};

                # Parse and apply custom headers (Content-Type:value\nHeader:value...)
                my array @header_lines = split("\n", $headers_str);
                my int $j = 0;
                while ($j < scalar(@header_lines)) {
                    my str $line = $header_lines[$j];
                    my int $colon = index($line, ":");
                    if ($colon > 0) {
                        my str $name = substr($line, 0, $colon);
                        my str $value = substr($line, $colon + 1, length($line) - $colon - 1);
                        # Set header directly in the headers hash
                        $res_headers->{$name} = $value;
                    }
                    $j = $j + 1;
                }
            } else {
                %res = Cannoli::Response::text(200, $response_body);
            }
        } else {
            %res = Cannoli::Response::text(200, $response_body);
        }
    } elsif (substr($response_body, 0, 7) eq "STATUS:") {
        # STATUS:xxx:content - custom status code
        my int $colon1 = 7;
        my int $colon2 = index($response_body, ":", $colon1);
        if ($colon2 > $colon1) {
            my str $status_str = substr($response_body, $colon1, $colon2 - $colon1);
            my int $status = $status_str + 0;
            my str $content = substr($response_body, $colon2 + 1, length($response_body) - $colon2 - 1);
            %res = Cannoli::Response::text($status, $content);
        } else {
            %res = Cannoli::Response::text(200, $response_body);
        }
    } elsif (substr($response_body, 0, 9) eq "REDIRECT:") {
        # REDIRECT:url - redirect response
        my str $url = substr($response_body, 9, length($response_body) - 9);
        %res = Cannoli::Response::redirect($url, 0);
    } elsif (substr($response_body, 0, 1) eq "{" || substr($response_body, 0, 1) eq "[") {
        # JSON response
        %res = Cannoli::Response::json(200, $response_body);
    } elsif (substr($response_body, 0, 1) eq "<") {
        # HTML response
        %res = Cannoli::Response::html(200, $response_body);
    } else {
        # Plain text
        %res = Cannoli::Response::text(200, $response_body);
    }

    return %res;
}

# Build an error result for read_request
func Cannoli_Server_read_error(str $code, int $limit) scalar {
    my hash %result = ();
    $result{"error"} = $code;
    $result{"limit"} = $limit;
    return \%result;
}

# Parse Content-Length from request headers (returns 0 if missing)
func Cannoli_Server_parse_content_length(str $header_section) int {
    my array @lines = split("\r\n", $header_section);
    my int $i = 1;  # skip request line
    while ($i < scalar(@lines)) {
        my str $line = $lines[$i];
        my int $colon = index($line, ":");
        if ($colon > 0) {
            my str $name = trim(substr($line, 0, $colon));
            my str $value = trim(substr($line, $colon + 1, length($line) - $colon - 1));
            $name = lc($name);
            if ($name eq "content-length") {
                return $value + 0;
            }
        }
        $i = $i + 1;
    }
    return 0;
}

# Decide if the connection should be kept alive
func Cannoli_Server_should_keep_alive(hash %req) int {
    my str $version = $req{"http_version"};
    my str $conn = lc(Cannoli::Request::get_header(%req, "Connection"));

    if ($version eq "HTTP/1.1") {
        if (index($conn, "close") >= 0) {
            return 0;
        }
        return 1;
    }

    if ($version eq "HTTP/1.0") {
        if (index($conn, "keep-alive") >= 0) {
            return 1;
        }
        return 0;
    }

    return 0;
}

# Read and parse a full HTTP request from a socket (supports keep-alive buffer)
func Cannoli_Server_read_request(scalar $server_ref, scalar $client, str $buffer) scalar {
    my int $max_header = $server_ref->{"max_header_size"};
    my int $max_body = $server_ref->{"max_body_size"};
    my int $timeout_ms = $server_ref->{"timeout"} * 1000;

    if (length($buffer) == 0) {
        my int $client_fd = sys::socket_fd($client);

        # During keep-alive wait, also monitor the server socket so this
        # worker can break out and accept new connections if needed
        my scalar $server_sock = $server_ref->{"server_sock"};
        my int $server_fd = defined($server_sock) ? sys::socket_fd($server_sock) : -1;

        my array @fds = ($client_fd);
        if ($server_fd >= 0) {
            push(@fds, $server_fd);
        }

        my array @ready = sys::select_fds(\@fds, $timeout_ms);
        if (scalar(@ready) == 0) {
            return undef;
        }

        # If server socket is ready but client is not, a new connection is
        # waiting and this worker should drop keep-alive to go accept it
        my int $client_ready = 0;
        my int $j = 0;
        while ($j < scalar(@ready)) {
            if ($ready[$j] == $client_fd) {
                $client_ready = 1;
            }
            $j++;
        }
        if ($client_ready == 0) {
            return undef;
        }
    }

    my int $header_end = index($buffer, "\r\n\r\n");
    while ($header_end < 0) {
        if (length($buffer) > $max_header) {
            return ::read_error("header_too_large", $max_header);
        }
        my str $chunk = sys::socket_recv($client, 65536);
        if (length($chunk) == 0) {
            return undef;
        }
        $buffer = $buffer . $chunk;
        $header_end = index($buffer, "\r\n\r\n");
    }

    if ($header_end > $max_header) {
        return ::read_error("header_too_large", $max_header);
    }

    my str $header_section = substr($buffer, 0, $header_end);
    my int $content_len = ::parse_content_length($header_section);
    if ($content_len > $max_body) {
        return ::read_error("body_too_large", $max_body);
    }

    my int $total_needed = $header_end + 4 + $content_len;
    while (length($buffer) < $total_needed) {
        my str $chunk = sys::socket_recv($client, 65536);
        if (length($chunk) == 0) {
            return undef;
        }
        $buffer = $buffer . $chunk;
    }

    my str $request_data = substr($buffer, 0, $total_needed);
    my int $remaining_len = length($buffer) - $total_needed;
    my str $remaining = "";
    if ($remaining_len > 0) {
        $remaining = substr($buffer, $total_needed, $remaining_len);
    }

    my hash %req = Cannoli::Request::parse($request_data);
    my hash %result = ();
    $result{"req"} = \%req;
    $result{"buffer"} = $remaining;
    return \%result;
}

# Read and parse a full HTTP request from an SSL connection
func Cannoli_Server_read_ssl_request(scalar $server_ref, scalar $ssl_conn, scalar $ssl_read_fn, int $ssl_fd, str $buffer) scalar {
    my int $max_header = $server_ref->{"max_header_size"};
    my int $max_body = $server_ref->{"max_body_size"};
    my int $timeout_ms = $server_ref->{"timeout"} * 1000;

    if (length($buffer) == 0 && $ssl_fd > 0) {
        # During keep-alive wait, also monitor the server socket
        my scalar $server_sock = $server_ref->{"server_sock"};
        my int $server_fd = defined($server_sock) ? sys::socket_fd($server_sock) : -1;

        my array @fds = ($ssl_fd);
        if ($server_fd >= 0) {
            push(@fds, $server_fd);
        }

        my array @ready = sys::select_fds(\@fds, $timeout_ms);
        if (scalar(@ready) == 0) {
            return undef;
        }

        # If server socket is ready but client is not, drop keep-alive
        my int $client_ready = 0;
        my int $j = 0;
        while ($j < scalar(@ready)) {
            if ($ready[$j] == $ssl_fd) {
                $client_ready = 1;
            }
            $j++;
        }
        if ($client_ready == 0) {
            return undef;
        }
    }

    my int $header_end = index($buffer, "\r\n\r\n");
    while ($header_end < 0) {
        if (length($buffer) > $max_header) {
            return ::read_error("header_too_large", $max_header);
        }
        my str $chunk = sys::dl_call_str_sv($ssl_read_fn, [$ssl_conn, 65536]);
        if (length($chunk) == 0) {
            return undef;
        }
        $buffer = $buffer . $chunk;
        $header_end = index($buffer, "\r\n\r\n");
    }

    if ($header_end > $max_header) {
        return ::read_error("header_too_large", $max_header);
    }

    my str $header_section = substr($buffer, 0, $header_end);
    my int $content_len = ::parse_content_length($header_section);
    if ($content_len > $max_body) {
        return ::read_error("body_too_large", $max_body);
    }

    my int $total_needed = $header_end + 4 + $content_len;
    while (length($buffer) < $total_needed) {
        my str $chunk = sys::dl_call_str_sv($ssl_read_fn, [$ssl_conn, 65536]);
        if (length($chunk) == 0) {
            return undef;
        }
        $buffer = $buffer . $chunk;
    }

    my str $request_data = substr($buffer, 0, $total_needed);
    my int $remaining_len = length($buffer) - $total_needed;
    my str $remaining = "";
    if ($remaining_len > 0) {
        $remaining = substr($buffer, $total_needed, $remaining_len);
    }

    my hash %req = Cannoli::Request::parse($request_data);
    my hash %result = ();
    $result{"req"} = \%req;
    $result{"buffer"} = $remaining;
    return \%result;
}

# Handle a single client connection
func Cannoli_Server_handle_client(scalar $server_ref, scalar $client) void {
    my scalar $router = $server_ref->{"router"};
    my scalar $dispatch_funcs = $server_ref->{"dispatch_funcs"};
    my scalar $library_routes = $server_ref->{"library_routes"};
    my int $client_fd = sys::socket_fd($client);
    my str $buffer = "";

    while (1) {
        my scalar $read_result = ::read_request($server_ref, $client, $buffer);
        if (!defined($read_result)) {
            last;
        }

        if (exists(%{$read_result}, "error")) {
            my str $err = $read_result->{"error"};
            my int $limit = $read_result->{"limit"};
            my hash %err_res = ();
            if ($err eq "header_too_large") {
                %err_res = Cannoli::Response::header_too_large($limit);
            } elsif ($err eq "body_too_large") {
                %err_res = Cannoli::Response::payload_too_large($limit);
            } else {
                %err_res = Cannoli::Response::error_page(400, "Bad Request");
            }
            my str $err_data = Cannoli::Response::build(%err_res);
            sys::socket_send($client, $err_data);
            last;
        }

        $buffer = $read_result->{"buffer"};
        my hash %req = %{$read_result->{"req"}};

        # Start timing
        my hash %start_time = sys::gettimeofday();
        my int $start_sec = $start_time{"sec"};
        my int $start_usec = $start_time{"usec"};

        my str $method = $req{"method"};
        my str $path = $req{"path"};
        my str $body = $req{"body"};

        # Check request size limits
        my int $max_body = $server_ref->{"max_body_size"};
        my int $content_len = $req{"content_length"} + 0;
        my int $body_len = length($body);

        # Check Content-Length header against limit
        if ($content_len > $max_body) {
            my hash %err_res = Cannoli::Response::payload_too_large($max_body);
            my str $err_data = Cannoli::Response::build(%err_res);
            sys::socket_send($client, $err_data);
            last;
        }

        # Check actual body size against limit
        if ($body_len > $max_body) {
            my hash %err_res = Cannoli::Response::payload_too_large($max_body);
            my str $err_data = Cannoli::Response::build(%err_res);
            sys::socket_send($client, $err_data);
            last;
        }

        # Store client fd in request for chunked responses
        $req{"_fd"} = $client_fd;
        $req{"_client"} = $client;

        my hash %res = ();
        my int $handled = 0;

        # Try prefix-based library routes first (new style)
        my int $num_routes = scalar(@{$library_routes});
        if ($num_routes > 0 && $handled == 0) {
            my int $i = 0;
            while ($i < $num_routes && $handled == 0) {
                my scalar $route = $library_routes->[$i];
                my str $prefix = $route->{"prefix"};
                my scalar $dispatch = $route->{"dispatch"};

                # Check if path starts with prefix
                my int $prefix_len = length($prefix);
                my int $matches = 0;

                if ($prefix eq "/") {
                    # Root prefix matches everything
                    $matches = 1;
                } elsif (length($path) >= $prefix_len) {
                    my str $path_prefix = substr($path, 0, $prefix_len);
                    if ($path_prefix eq $prefix) {
                        # Ensure it's a proper prefix (followed by / or end of path)
                        if (length($path) == $prefix_len) {
                            $matches = 1;
                        } elsif (substr($path, $prefix_len, 1) eq "/") {
                            $matches = 1;
                        } elsif (substr($prefix, $prefix_len - 1, 1) eq "/") {
                            # Prefix ends with /, already matched
                            $matches = 1;
                        }
                    }
                }

                if ($matches == 1) {
                    # Calculate path_info (part of path after prefix)
                    my str $path_info = "";
                    if ($prefix eq "/") {
                        $path_info = $path;
                    } elsif (length($path) > $prefix_len) {
                        $path_info = substr($path, $prefix_len, length($path) - $prefix_len);
                    } else {
                        $path_info = "/";
                    }

                    # Create Cannoli object and pass to dispatch
                    $req{"path_info"} = $path_info;
                    my scalar $c = Cannoli::new(%req);

                    my scalar $result = sys::dl_call_sv($dispatch, [$c]);
                    my str $response_body = defined($result) ? ("" . $result) : "";

                    if (length($response_body) > 0) {
                        %res = ::parse_response($response_body);
                        $handled = 1;
                    }
                }
                $i = $i + 1;
            }
        }

        # Try chain-of-responsibility dispatch (old style: app.library)
        my int $num_funcs = scalar(@{$dispatch_funcs});
        if ($num_funcs > 0 && $handled == 0) {
            # Create Cannoli object once for all dispatch attempts
            $req{"path_info"} = "";  # Libraries handle their own prefix matching
            my scalar $c = Cannoli::new(%req);

            my int $i = 0;
            while ($i < $num_funcs && $handled == 0) {
                my scalar $dispatch = $dispatch_funcs->[$i];

                # Call: cannoli_dispatch($c) - pass Cannoli object
                my scalar $result = sys::dl_call_sv($dispatch, [$c]);
                my str $response_body = defined($result) ? ("" . $result) : "";

                if (length($response_body) > 0) {
                    %res = ::parse_response($response_body);
                    $handled = 1;
                }
                $i = $i + 1;
            }
        }

        # Fall back to router if no library handled the request
        if ($handled == 0 && defined($router)) {
            %res = Cannoli::Router::dispatch($router, %req);
            $handled = 1;
        }

        # Default response
        if ($handled == 0) {
            %res = Cannoli::Response::not_found();
        }

        my int $keep_alive = ::should_keep_alive(%req);

        # Build and send response (skip if already sent, e.g., chunked)
        if ($res{"sent"} != 1) {
            if ($keep_alive == 1) {
                Cannoli::Response::header(%res, "Connection", "keep-alive");
                Cannoli::Response::header(%res, "Keep-Alive", "timeout=" . $server_ref->{"timeout"});
            } else {
                Cannoli::Response::header(%res, "Connection", "close");
            }
            my str $response = Cannoli::Response::build(%res);
            sys::socket_send($client, $response);
        }

        # Calculate elapsed time in milliseconds
        my hash %end_time = sys::gettimeofday();
        my int $end_sec = $end_time{"sec"};
        my int $end_usec = $end_time{"usec"};
        my int $elapsed_ms = ($end_sec - $start_sec) * 1000 + ($end_usec - $start_usec) / 1000;

        # Log the request with timing
        Cannoli::Log::request_timed(%req, %res, $elapsed_ms);

        if ($res{"sent"} == 1) {
            last;
        }

        if ($keep_alive == 0) {
            last;
        }
    }

    # Close connection
    sys::socket_close($client);
}

# Handle a single SSL client connection
func Cannoli_Server_handle_ssl_client(scalar $server_ref, scalar $ssl_conn) void {
    my scalar $router = $server_ref->{"router"};
    my scalar $dispatch_funcs = $server_ref->{"dispatch_funcs"};
    my scalar $library_routes = $server_ref->{"library_routes"};
    my scalar $ssl_read_fn = $server_ref->{"ssl_read_fn"};
    my scalar $ssl_write_fn = $server_ref->{"ssl_write_fn"};
    my scalar $ssl_close_fn = $server_ref->{"ssl_close_fn"};
    my scalar $ssl_fd_fn = $server_ref->{"ssl_fd_fn"};
    my int $ssl_fd = -1;
    if (defined($ssl_fd_fn)) {
        $ssl_fd = sys::dl_call_int_sv($ssl_fd_fn, [$ssl_conn]);
    }
    my str $buffer = "";

    while (1) {
        my scalar $read_result = ::read_ssl_request($server_ref, $ssl_conn, $ssl_read_fn, $ssl_fd, $buffer);
        if (!defined($read_result)) {
            last;
        }

        if (exists(%{$read_result}, "error")) {
            my str $err = $read_result->{"error"};
            my int $limit = $read_result->{"limit"};
            my hash %err_res = ();
            if ($err eq "header_too_large") {
                %err_res = Cannoli::Response::header_too_large($limit);
            } elsif ($err eq "body_too_large") {
                %err_res = Cannoli::Response::payload_too_large($limit);
            } else {
                %err_res = Cannoli::Response::error_page(400, "Bad Request");
            }
            my str $err_data = Cannoli::Response::build(%err_res);
            sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $err_data]);
            last;
        }

        $buffer = $read_result->{"buffer"};
        my hash %req = %{$read_result->{"req"}};

        # Start timing
        my hash %start_time = sys::gettimeofday();
        my int $start_sec = $start_time{"sec"};
        my int $start_usec = $start_time{"usec"};

        my str $method = $req{"method"};
        my str $path = $req{"path"};
        my str $body = $req{"body"};

        # Check request size limits
        my int $max_body = $server_ref->{"max_body_size"};
        my int $content_len = $req{"content_length"} + 0;
        my int $body_len = length($body);

        # Check Content-Length header against limit
        if ($content_len > $max_body) {
            my hash %err_res = Cannoli::Response::payload_too_large($max_body);
            my str $err_data = Cannoli::Response::build(%err_res);
            sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $err_data]);
            last;
        }

        # Check actual body size against limit
        if ($body_len > $max_body) {
            my hash %err_res = Cannoli::Response::payload_too_large($max_body);
            my str $err_data = Cannoli::Response::build(%err_res);
            sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $err_data]);
            last;
        }

        # Store SSL connection info in request for chunked responses
        $req{"_ssl"} = 1;
        $req{"_ssl_conn"} = $ssl_conn;
        $req{"_ssl_read_fn"} = $ssl_read_fn;
        $req{"_ssl_write_fn"} = $ssl_write_fn;
        $req{"_ssl_close_fn"} = $ssl_close_fn;

        my hash %res = ();
        my int $handled = 0;

        # Try prefix-based library routes first (new style)
        my int $num_routes = scalar(@{$library_routes});
        if ($num_routes > 0 && $handled == 0) {
            my int $i = 0;
            while ($i < $num_routes && $handled == 0) {
                my scalar $route = $library_routes->[$i];
                my str $prefix = $route->{"prefix"};
                my scalar $dispatch = $route->{"dispatch"};

                # Check if path starts with prefix
                my int $prefix_len = length($prefix);
                my int $matches = 0;

                if ($prefix eq "/") {
                    $matches = 1;
                } elsif (length($path) >= $prefix_len) {
                    my str $path_prefix = substr($path, 0, $prefix_len);
                    if ($path_prefix eq $prefix) {
                        if (length($path) == $prefix_len) {
                            $matches = 1;
                        } elsif (substr($path, $prefix_len, 1) eq "/") {
                            $matches = 1;
                        } elsif (substr($prefix, $prefix_len - 1, 1) eq "/") {
                            $matches = 1;
                        }
                    }
                }

                if ($matches == 1) {
                    my str $path_info = "";
                    if ($prefix eq "/") {
                        $path_info = $path;
                    } elsif (length($path) > $prefix_len) {
                        $path_info = substr($path, $prefix_len, length($path) - $prefix_len);
                    } else {
                        $path_info = "/";
                    }

                    # Create Cannoli object and pass to dispatch
                    $req{"path_info"} = $path_info;
                    my scalar $c = Cannoli::new(%req);

                    my scalar $result = sys::dl_call_sv($dispatch, [$c]);
                    my str $response_body = defined($result) ? ("" . $result) : "";

                    if (length($response_body) > 0) {
                        %res = ::parse_response($response_body);
                        $handled = 1;
                    }
                }
                $i = $i + 1;
            }
        }

        # Try chain-of-responsibility dispatch (old style: app.library)
        my int $num_funcs = scalar(@{$dispatch_funcs});
        if ($num_funcs > 0 && $handled == 0) {
            # Create Cannoli object once for all dispatch attempts
            $req{"path_info"} = "";  # Libraries handle their own prefix matching
            my scalar $c = Cannoli::new(%req);

            my int $i = 0;
            while ($i < $num_funcs && $handled == 0) {
                my scalar $dispatch = $dispatch_funcs->[$i];

                # Call: cannoli_dispatch($c) - pass Cannoli object
                my scalar $result = sys::dl_call_sv($dispatch, [$c]);
                my str $response_body = defined($result) ? ("" . $result) : "";

                if (length($response_body) > 0) {
                    %res = ::parse_response($response_body);
                    $handled = 1;
                }
                $i = $i + 1;
            }
        }

        # Fall back to router if no library handled the request
        if ($handled == 0 && defined($router)) {
            %res = Cannoli::Router::dispatch($router, %req);
            $handled = 1;
        }

        # Default response
        if ($handled == 0) {
            %res = Cannoli::Response::not_found();
        }

        # Build and send response via SSL (skip if already sent, e.g., chunked)
        my int $keep_alive = ::should_keep_alive(%req);
        if ($res{"sent"} != 1) {
            if ($keep_alive == 1) {
                Cannoli::Response::header(%res, "Connection", "keep-alive");
                Cannoli::Response::header(%res, "Keep-Alive", "timeout=" . $server_ref->{"timeout"});
            } else {
                Cannoli::Response::header(%res, "Connection", "close");
            }
            my str $response = Cannoli::Response::build(%res);
            sys::dl_call_int_sv($ssl_write_fn, [$ssl_conn, $response]);
        }

        # Calculate elapsed time in milliseconds
        my hash %end_time = sys::gettimeofday();
        my int $end_sec = $end_time{"sec"};
        my int $end_usec = $end_time{"usec"};
        my int $elapsed_ms = ($end_sec - $start_sec) * 1000 + ($end_usec - $start_usec) / 1000;

        # Log the request with timing
        Cannoli::Log::request_timed(%req, %res, $elapsed_ms);

        if ($res{"sent"} == 1) {
            last;
        }

        if ($keep_alive == 0) {
            last;
        }
    }

    # Close SSL connection
    sys::dl_call_void_sv($ssl_close_fn, [$ssl_conn]);
}

# Worker process main loop
func Cannoli_Server_worker_loop(scalar $server_ref) void {
    my scalar $server_sock = $server_ref->{"server_sock"};
    my scalar $ssl_server = $server_ref->{"ssl_server"};
    my int $max_requests = $server_ref->{"max_requests"};
    my int $requests_handled = 0;

    # Save parent PID to detect if master dies
    my int $parent_pid = sys::getppid();

    my int $http_fd = sys::socket_fd($server_sock);
    my int $ssl_fd = -1;
    if (defined($ssl_server)) {
        my scalar $ssl_fd_fn = $server_ref->{"ssl_fd_fn"};
        $ssl_fd = sys::dl_call_int_sv($ssl_fd_fn, [$ssl_server]);
    }

    while ($requests_handled < $max_requests) {
        # Check if master process died (orphaned worker)
        my int $current_ppid = sys::getppid();
        if ($current_ppid != $parent_pid) {
            # Master died, exit cleanly
            exit(0);
        }

        # Build array of file descriptors to monitor
        my array @fds = ($http_fd);
        if ($ssl_fd >= 0) {
            push(\@fds, $ssl_fd);
        }

        # Wait for connections on either socket
        my array @ready = sys::select_fds(\@fds, 1000);
        my int $num_ready = scalar(@ready);

        if ($num_ready == 0) {
            next;
        }

        my int $i = 0;
        while ($i < $num_ready) {
            my int $ready_fd = $ready[$i];

            if ($ready_fd == $http_fd) {
                # HTTP connection
                my scalar $client = sys::socket_accept($server_sock);
                if (defined($client)) {
                    ::handle_client($server_ref, $client);
                    $requests_handled = $requests_handled + 1;
                }
            } elsif ($ready_fd == $ssl_fd) {
                # HTTPS connection
                my scalar $ssl_accept_fn = $server_ref->{"ssl_accept_fn"};
                my scalar $ssl_conn = sys::dl_call_sv($ssl_accept_fn, [$ssl_server]);
                if (defined($ssl_conn)) {
                    ::handle_ssl_client($server_ref, $ssl_conn);
                    $requests_handled = $requests_handled + 1;
                }
            }

            $i = $i + 1;
        }
    }

    # Worker exits after max requests (will be respawned by master)
}

# Spawn worker processes
func Cannoli_Server_spawn_workers(scalar $server_ref) void {
    my int $num_workers = $server_ref->{"num_workers"};
    my scalar $pids = $server_ref->{"worker_pids"};

    my int $i = 0;
    while ($i < $num_workers) {
        my int $pid = sys::fork();

        if ($pid == 0) {
            # Child process - set worker title and run worker loop
            sys::setproctitle("cannoli [worker]");
            # Install worker signal handlers
            sys::signal("TERM", \&Cannoli_Server_worker_handle_term);
            sys::signal("INT", "IGNORE");  # Let master handle Ctrl+C
            ::worker_loop($server_ref);
            exit(0);
        } elsif ($pid > 0) {
            # Parent - track child PID
            push(@{$pids}, $pid);
            say("Spawned worker " . ($i + 1) . " with PID " . $pid);
        } else {
            say("Error: fork() failed");
        }

        $i = $i + 1;
    }
}

# Global server reference for signal handlers
my scalar $_g_server_ref = undef;

# Worker signal handler for SIGTERM - exit cleanly
func Cannoli_Server_worker_handle_term(int $sig) void {
    defined($sig);
    exit(0);
}

# Signal handler for SIGINT (Ctrl+C)
func Cannoli_Server_handle_sigint(int $sig) void {
    defined($sig);
    if (defined($_g_server_ref)) {
        ::graceful_shutdown($_g_server_ref);
    }
}

# Signal handler for SIGTERM
func Cannoli_Server_handle_sigterm(int $sig) void {
    defined($sig);
    if (defined($_g_server_ref)) {
        ::graceful_shutdown($_g_server_ref);
    }
}

# Install signal handlers for graceful shutdown
func Cannoli_Server_install_signal_handlers(scalar $server_ref) void {
    $_g_server_ref = $server_ref;
    sys::signal("INT", \&Cannoli_Server_handle_sigint);
    sys::signal("TERM", \&Cannoli_Server_handle_sigterm);
    sys::signal("PIPE", "IGNORE");  # Ignore broken pipe
}

# Graceful shutdown - close sockets, wait for workers, cleanup
func Cannoli_Server_graceful_shutdown(scalar $server_ref) void {
    # Prevent multiple shutdown calls
    if ($server_ref->{"running"} == 0) {
        return;
    }

    say("\nGraceful shutdown initiated...");
    $server_ref->{"running"} = 0;

    # Close listening sockets first to stop accepting new connections
    my scalar $server_sock = $server_ref->{"server_sock"};
    if (defined($server_sock)) {
        say("Closing HTTP listening socket...");
        sys::socket_close($server_sock);
        $server_ref->{"server_sock"} = undef;
    }

    # Close SSL socket if present
    if ($server_ref->{"ssl_enabled"} == 1) {
        my scalar $ssl_server = $server_ref->{"ssl_server"};
        if (defined($ssl_server)) {
            say("Closing HTTPS listening socket...");
            my scalar $ssl_close_fn = $server_ref->{"ssl_close_fn"};
            if (defined($ssl_close_fn)) {
                sys::dl_call_void_sv($ssl_close_fn, [$ssl_server]);
            }
            $server_ref->{"ssl_server"} = undef;
        }
    }

    # Send SIGTERM to all workers
    my scalar $pids = $server_ref->{"worker_pids"};
    my int $num = scalar(@{$pids});
    my int $i = 0;

    if ($num > 0) {
        say("Sending SIGTERM to " . $num . " workers...");
        while ($i < $num) {
            my int $pid = $pids->[$i];
            sys::kill($pid, 15);  # SIGTERM
            $i = $i + 1;
        }

        # Wait for workers with timeout
        my int $timeout = 30;  # seconds
        my int $start = sys::time();
        my int $remaining = $num;

        say("Waiting for workers to exit (timeout: " . $timeout . "s)...");

        while ($remaining > 0) {
            my int $status = 0;
            my int $pid = sys::waitpid(-1, $status);

            if ($pid > 0) {
                $remaining = $remaining - 1;
                say("Worker " . $pid . " exited (" . $remaining . " remaining)");
            }

            # Check timeout
            my int $elapsed = sys::time() - $start;
            if ($elapsed > $timeout) {
                say("Timeout reached, force-killing remaining workers...");
                $i = 0;
                while ($i < scalar(@{$pids})) {
                    my int $kill_pid = $pids->[$i];
                    sys::kill($kill_pid, 9);  # SIGKILL
                    $i = $i + 1;
                }
                last;
            }

            sys::usleep(100000);  # 100ms
        }
    }

    say("Shutdown complete");

    # In single-process dev mode (no workers), exit immediately
    # Otherwise the main loop may try to use closed sockets
    if ($num == 0) {
        exit(0);
    }
}

# Legacy signal handler for graceful Cannoli::Server::shutdown(kept for compatibility)
func Cannoli_Server_shutdown(scalar $server_ref) void {
    ::graceful_shutdown($server_ref);
}

# Master process loop - monitor and respawn workers
func Cannoli_Server_master_loop(scalar $server_ref) void {
    $server_ref->{"running"} = 1;

    while ($server_ref->{"running"} == 1) {
        # Wait for any child to exit
        my int $status = 0;
        my int $pid = sys::waitpid(-1, $status);

        if ($pid > 0 && $server_ref->{"running"} == 1) {
            # A worker exited, respawn it
            say("Worker " . $pid . " exited, respawning...");

            # Remove old PID from list
            my scalar $pids = $server_ref->{"worker_pids"};
            my array @new_pids = ();
            my int $i = 0;
            my int $num = scalar(@{$pids});

            while ($i < $num) {
                my int $p = $pids->[$i];
                if ($p != $pid) {
                    push(\@new_pids, $p);
                }
                $i = $i + 1;
            }

            $server_ref->{"worker_pids"} = \@new_pids;

            # Fork new worker
            my int $new_pid = sys::fork();

            if ($new_pid == 0) {
                # Child - set worker title and signal handlers
                sys::setproctitle("cannoli [worker]");
                sys::signal("TERM", \&Cannoli_Server_worker_handle_term);
                sys::signal("INT", "IGNORE");
                ::worker_loop($server_ref);
                exit(0);
            } elsif ($new_pid > 0) {
                # Parent
                push(@{$server_ref->{"worker_pids"}}, $new_pid);
                say("Respawned worker with PID " . $new_pid);
            }
        }

        sys::usleep(100000);
    }
}

# Run the server in preforking mode
func Cannoli_Server_run(scalar $server_ref) int {
    # Create HTTP listening socket
    my scalar $server_sock = ::create_socket($server_ref);
    if (!defined($server_sock)) {
        return 1;
    }

    # Create SSL listening socket if SSL is enabled
    if ($server_ref->{"ssl_enabled"} == 1) {
        ::create_ssl_socket($server_ref);
    }

    # Install signal handlers for graceful Cannoli::Server::shutdown(before spawning workers)
    ::install_signal_handlers($server_ref);

    # Set master process title
    sys::setproctitle("cannoli [master]");

    say("Starting " . $server_ref->{"num_workers"} . " worker processes...");

    # Spawn workers
    ::spawn_workers($server_ref);

    # Run master loop
    ::master_loop($server_ref);

    return 0;
}

# Run the server in single-process mode (for development)
func Cannoli_Server_run_single(scalar $server_ref) int {
    # Create HTTP listening socket
    my scalar $server_sock = ::create_socket($server_ref);
    if (!defined($server_sock)) {
        return 1;
    }

    # Create SSL listening socket if SSL is enabled
    my scalar $ssl_server = undef;
    my int $ssl_fd = -1;
    if ($server_ref->{"ssl_enabled"} == 1) {
        $ssl_server = ::create_ssl_socket($server_ref);
        if (defined($ssl_server)) {
            my scalar $ssl_fd_fn = $server_ref->{"ssl_fd_fn"};
            $ssl_fd = sys::dl_call_int_sv($ssl_fd_fn, [$ssl_server]);
        }
    }

    # Install signal handlers for graceful shutdown
    ::install_signal_handlers($server_ref);

    say("Running in single-process development mode");
    say("Press Ctrl+C to stop");

    $server_ref->{"running"} = 1;
    my int $http_fd = sys::socket_fd($server_sock);

    while ($server_ref->{"running"} == 1) {
        # Build array of file descriptors to monitor
        my array @fds = ($http_fd);
        if ($ssl_fd >= 0) {
            push(\@fds, $ssl_fd);
        }

        # Wait for connections on either socket
        my array @ready = sys::select_fds(\@fds, 1000);
        my int $num_ready = scalar(@ready);
        my int $i = 0;

        while ($i < $num_ready) {
            my int $ready_fd = $ready[$i];

            if ($ready_fd == $http_fd) {
                # HTTP connection
                my scalar $client = sys::socket_accept($server_sock);
                if (defined($client)) {
                    ::handle_client($server_ref, $client);
                }
            } elsif ($ready_fd == $ssl_fd) {
                # HTTPS connection
                my scalar $ssl_accept_fn = $server_ref->{"ssl_accept_fn"};
                my scalar $ssl_conn = sys::dl_call_sv($ssl_accept_fn, [$ssl_server]);
                if (defined($ssl_conn)) {
                    ::handle_ssl_client($server_ref, $ssl_conn);
                }
            }

            $i = $i + 1;
        }
    }

    sys::socket_close($server_sock);
    if (defined($ssl_server)) {
        my scalar $ssl_close_fn = $server_ref->{"ssl_close_fn"};
        sys::dl_call_void_sv($ssl_close_fn, [$ssl_server]);
    }
    return 0;
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::FastCGI;


# cannoli/src/fastcgi.strada - FastCGI protocol implementation
#
# Implements the FastCGI protocol for use with web servers like nginx

# FastCGI record types
func FCGI_BEGIN_REQUEST() int { return 1; }
func FCGI_ABORT_REQUEST() int { return 2; }
func FCGI_END_REQUEST() int { return 3; }
func FCGI_PARAMS() int { return 4; }
func FCGI_STDIN() int { return 5; }
func FCGI_STDOUT() int { return 6; }
func FCGI_STDERR() int { return 7; }
func FCGI_DATA() int { return 8; }
func FCGI_GET_VALUES() int { return 9; }
func FCGI_GET_VALUES_RESULT() int { return 10; }

# FastCGI roles
func FCGI_RESPONDER() int { return 1; }
func FCGI_AUTHORIZER() int { return 2; }
func FCGI_FILTER() int { return 3; }

# FastCGI protocol status
func FCGI_REQUEST_COMPLETE() int { return 0; }
func FCGI_CANT_MPX_CONN() int { return 1; }
func FCGI_OVERLOADED() int { return 2; }
func FCGI_UNKNOWN_ROLE() int { return 3; }

# Helper: integer modulo (a mod b)
func fcgi_mod(int $a, int $b) int {
    my int $div = $a / $b;
    return $a - ($div * $b);
}

# Create a FastCGI header (8 bytes)
func Cannoli_FastCGI_make_header(int $type, int $request_id, int $content_len, int $padding_len) str {
    my str $header = "";

    # Version (1)
    $header = $header . chr(1);

    # Type
    $header = $header . chr($type);

    # Request ID (big-endian 16-bit)
    my int $req_high = $request_id / 256;
    $req_high = fcgi_mod($req_high, 256);
    my int $req_low = fcgi_mod($request_id, 256);
    $header = $header . chr($req_high);
    $header = $header . chr($req_low);

    # Content length (big-endian 16-bit)
    my int $len_high = $content_len / 256;
    $len_high = fcgi_mod($len_high, 256);
    my int $len_low = fcgi_mod($content_len, 256);
    $header = $header . chr($len_high);
    $header = $header . chr($len_low);

    # Padding length
    $header = $header . chr($padding_len);

    # Reserved
    $header = $header . chr(0);

    return $header;
}

# Parse a FastCGI header
func Cannoli_FastCGI_parse_header(str $data) hash {
    my hash %header = ();

    if (length($data) < 8) {
        $header{"valid"} = 0;
        return %header;
    }

    $header{"valid"} = 1;
    $header{"version"} = ord(substr($data, 0, 1));
    $header{"type"} = ord(substr($data, 1, 1));
    $header{"request_id"} = ord(substr($data, 2, 1)) * 256 + ord(substr($data, 3, 1));
    $header{"content_length"} = ord(substr($data, 4, 1)) * 256 + ord(substr($data, 5, 1));
    $header{"padding_length"} = ord(substr($data, 6, 1));

    return %header;
}

# Parse FastCGI name-value pairs (FCGI_PARAMS)
func Cannoli_FastCGI_parse_params(str $data) hash {
    my hash %params = ();
    my int $pos = 0;
    my int $len = length($data);

    while ($pos < $len) {
        # Read name length
        my int $name_len = ord(substr($data, $pos, 1));
        $pos = $pos + 1;

        if ($name_len > 127) {
            # 4-byte length
            my int $b0 = fcgi_mod($name_len, 128);
            my int $b1 = ord(substr($data, $pos, 1));
            my int $b2 = ord(substr($data, $pos + 1, 1));
            my int $b3 = ord(substr($data, $pos + 2, 1));
            $name_len = ($b0 * 16777216) + ($b1 * 65536) + ($b2 * 256) + $b3;
            $pos = $pos + 3;
        }

        if ($pos >= $len) { last; }

        # Read value length
        my int $value_len = ord(substr($data, $pos, 1));
        $pos = $pos + 1;

        if ($value_len > 127) {
            # 4-byte length
            my int $b0 = fcgi_mod($value_len, 128);
            my int $b1 = ord(substr($data, $pos, 1));
            my int $b2 = ord(substr($data, $pos + 1, 1));
            my int $b3 = ord(substr($data, $pos + 2, 1));
            $value_len = ($b0 * 16777216) + ($b1 * 65536) + ($b2 * 256) + $b3;
            $pos = $pos + 3;
        }

        if ($pos + $name_len + $value_len > $len) { last; }

        # Extract name and value
        my str $name = substr($data, $pos, $name_len);
        $pos = $pos + $name_len;

        my str $value = substr($data, $pos, $value_len);
        $pos = $pos + $value_len;

        $params{$name} = $value;
    }

    return %params;
}

# Build FastCGI params from CGI environment to request hash
func Cannoli_FastCGI_params_to_request(hash %params) hash {
    my hash %req = Cannoli::Request::new();

    # Map CGI variables to request object
    if (exists(%params, "REQUEST_METHOD")) {
        $req{"method"} = $params{"REQUEST_METHOD"};
    }
    if (exists(%params, "REQUEST_URI")) {
        $req{"uri"} = $params{"REQUEST_URI"};
    }
    if (exists(%params, "DOCUMENT_URI")) {
        $req{"path"} = $params{"DOCUMENT_URI"};
    } elsif (exists(%params, "SCRIPT_NAME")) {
        $req{"path"} = $params{"SCRIPT_NAME"};
    }
    if (exists(%params, "QUERY_STRING")) {
        $req{"query_string"} = $params{"QUERY_STRING"};
        $req{"params"} = Cannoli::Request::parse_query($params{"QUERY_STRING"});
    }
    if (exists(%params, "CONTENT_TYPE")) {
        $req{"content_type"} = $params{"CONTENT_TYPE"};
    }
    if (exists(%params, "CONTENT_LENGTH")) {
        $req{"content_length"} = $params{"CONTENT_LENGTH"};
    }
    if (exists(%params, "REMOTE_ADDR")) {
        $req{"remote_addr"} = $params{"REMOTE_ADDR"};
    }
    if (exists(%params, "REMOTE_PORT")) {
        $req{"remote_port"} = $params{"REMOTE_PORT"};
    }

    # Map HTTP headers
    my hash %headers = ();
    my array @k = keys(%params);
    my int $i = 0;

    while ($i < scalar(@k)) {
        my str $key = $k[$i];
        if (substr($key, 0, 5) eq "HTTP_") {
            my str $header_name = substr($key, 5, length($key) - 5);
            # Convert HTTP_CONTENT_TYPE to content-type
            $header_name = ::header_from_cgi($header_name);
            $headers{$header_name} = $params{$key};
        }
        $i = $i + 1;
    }

    $req{"headers"} = \%headers;

    return %req;
}

# Convert CGI header name to HTTP header name
func Cannoli_FastCGI_header_from_cgi(str $name) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($name);
    my int $next_upper = 1;

    while ($i < $len) {
        my str $ch = substr($name, $i, 1);

        if ($ch eq "_") {
            $result = $result . "-";
            $next_upper = 1;
        } elsif ($next_upper == 1) {
            $result = $result . $ch;
            $next_upper = 0;
        } else {
            # Lowercase
            my int $code = ord($ch);
            if ($code >= 65 && $code <= 90) {
                $result = $result . chr($code + 32);
            } else {
                $result = $result . $ch;
            }
        }

        $i = $i + 1;
    }

    return $result;
}

# Build FCGI_STDOUT response
func Cannoli_FastCGI_build_response(hash %res, int $request_id) str {
    # Build HTTP response
    my str $http_response = Cannoli::Response::build(%res);

    # Build FCGI_STDOUT record(s)
    my str $output = "";
    my int $pos = 0;
    my int $len = length($http_response);

    while ($pos < $len) {
        my int $chunk_size = $len - $pos;
        if ($chunk_size > 65535) {
            $chunk_size = 65535;
        }

        my str $chunk = substr($http_response, $pos, $chunk_size);

        # Calculate padding
        my int $mod8 = fcgi_mod($chunk_size, 8);
        my int $padding = 8 - $mod8;
        $padding = fcgi_mod($padding, 8);

        # Header
        $output = $output . ::make_header(FCGI_STDOUT(), $request_id, $chunk_size, $padding);

        # Content
        $output = $output . $chunk;

        # Padding
        my int $p = 0;
        while ($p < $padding) {
            $output = $output . chr(0);
            $p = $p + 1;
        }

        $pos = $pos + $chunk_size;
    }

    # Empty FCGI_STDOUT to signal end
    $output = $output . ::make_header(FCGI_STDOUT(), $request_id, 0, 0);

    # FCGI_END_REQUEST
    my str $end_body = "";
    # App status (4 bytes, big-endian)
    $end_body = $end_body . chr(0) . chr(0) . chr(0) . chr(0);
    # Protocol status
    $end_body = $end_body . chr(FCGI_REQUEST_COMPLETE());
    # Reserved (3 bytes)
    $end_body = $end_body . chr(0) . chr(0) . chr(0);

    $output = $output . ::make_header(FCGI_END_REQUEST(), $request_id, 8, 0);
    $output = $output . $end_body;

    return $output;
}

# Handle a single FastCGI connection
func Cannoli_FastCGI_handle_connection(int $fd, scalar $router) void {
    my hash %params = ();
    my str $stdin_data = "";
    my int $request_id = 0;
    my int $done = 0;

    while ($done == 0) {
        # Read header
        my str $header_data = sys::read_fd($fd, 8);
        if (length($header_data) < 8) {
            last;
        }

        my hash %header = ::parse_header($header_data);
        if ($header{"valid"} == 0) {
            last;
        }

        $request_id = $header{"request_id"};
        my int $content_len = $header{"content_length"};
        my int $padding_len = $header{"padding_length"};

        # Read content
        my str $content = "";
        if ($content_len > 0) {
            $content = sys::read_fd($fd, $content_len);
        }

        # Skip padding bytes
        if ($padding_len > 0) {
            sys::read_fd($fd, $padding_len);
        }

        # Handle record type
        my int $rec_type = $header{"type"};

        if ($rec_type == FCGI_BEGIN_REQUEST()) {
            # New request
        } elsif ($rec_type == FCGI_PARAMS()) {
            if ($content_len > 0) {
                my hash %new_params = ::parse_params($content);
                my array @k = keys(%new_params);
                my int $i = 0;
                while ($i < scalar(@k)) {
                    my str $key = $k[$i];
                    $params{$key} = $new_params{$key};
                    $i = $i + 1;
                }
            }
        } elsif ($rec_type == FCGI_STDIN()) {
            if ($content_len > 0) {
                $stdin_data = $stdin_data . $content;
            } else {
                # Empty STDIN means end of request
                $done = 1;
            }
        } elsif ($rec_type == FCGI_ABORT_REQUEST()) {
            last;
        }
    }

    # Build request from params
    my hash %req = ::params_to_request(%params);
    $req{"body"} = $stdin_data;

    # Dispatch to router
    my hash %res = ();
    if (defined($router)) {
        %res = Cannoli::Router::dispatch($router, %req);
    } else {
        %res = Cannoli::Response::text(200, "Cannoli FastCGI server running");
    }

    # Send response
    my str $response = ::build_response(%res, $request_id);
    sys::write_fd($fd, $response);

    sys::close_fd($fd);
}

# FastCGI worker loop
func Cannoli_FastCGI_worker_loop(int $listen_fd, scalar $router, int $max_requests) void {
    my int $requests_handled = 0;

    while ($requests_handled < $max_requests) {
        my int $fd = sys::socket_accept($listen_fd);

        if ($fd < 0) {
            sys::usleep(10000);
            next;
        }

        ::handle_connection($fd, $router);
        $requests_handled = $requests_handled + 1;
    }
}

# Run FastCGI server (TCP mode - nginx connects via TCP)
# Note: Unix sockets would require additional runtime support
func Cannoli_FastCGI_run(str $socket_path, scalar $router, int $num_workers) int {
    # For now, use TCP port 9000 (standard FastCGI port)
    # socket_path is ignored - would need Unix socket support in runtime
    length($socket_path);
    my int $port = 9000;

    my int $fd = sys::socket_server($port, 128);

    if ($fd < 0) {
        say("Error: Could not create FastCGI socket on port " . $port);
        return 1;
    }

    say("FastCGI listening on TCP port " . $port);
    say("Note: Configure nginx with 'fastcgi_pass 127.0.0.1:9000;'");
    say("Starting " . $num_workers . " worker processes...");

    # Fork workers
    my int $i = 0;
    while ($i < $num_workers) {
        my int $pid = sys::fork();

        if ($pid == 0) {
            # Child
            ::worker_loop($fd, $router, 1000);
            exit(0);
        } elsif ($pid > 0) {
            say("Spawned FastCGI worker " . ($i + 1) . " with PID " . $pid);
        }

        $i = $i + 1;
    }

    # Master waits for children
    while (1) {
        my int $status = 0;
        my int $pid = sys::waitpid(-1, $status);

        if ($pid > 0) {
            say("FastCGI worker " . $pid . " exited, respawning...");

            my int $new_pid = sys::fork();
            if ($new_pid == 0) {
                ::worker_loop($fd, $router, 1000);
                exit(0);
            } elsif ($new_pid > 0) {
                say("Respawned FastCGI worker with PID " . $new_pid);
            }
        }

        sys::usleep(100000);
    }

    return 0;
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::App;


# cannoli/src/app.strada - Application helpers and base
#
# Provides convenience functions for building web applications
# Note: Due to Strada closure limitations, handlers are function references

# Create a new application with router
func Cannoli_App_new() scalar {
    my hash %app = ();
    $app{"router"} = Cannoli::Router::new();
    $app{"config"} = Cannoli::Config::defaults();
    return \%app;
}

# Configure the application
func Cannoli_App_configure(scalar $app, str $config_file) void {
    if (length($config_file) > 0 && sys::is_file($config_file)) {
        $app->{"config"} = Cannoli::Config::parse_file($config_file);
    }
}

# Add a GET route - handler is a function reference
func Cannoli_App_get(scalar $app, str $pattern, scalar $handler) void {
    Cannoli::Router::get($app->{"router"}, $pattern, $handler);
}

# Add a POST route
func Cannoli_App_post(scalar $app, str $pattern, scalar $handler) void {
    Cannoli::Router::post($app->{"router"}, $pattern, $handler);
}

# Add a PUT route
func Cannoli_App_put(scalar $app, str $pattern, scalar $handler) void {
    Cannoli::Router::put($app->{"router"}, $pattern, $handler);
}

# Add a DELETE route
func Cannoli_App_delete_route(scalar $app, str $pattern, scalar $handler) void {
    Cannoli::Router::delete_route($app->{"router"}, $pattern, $handler);
}

# Add a route for any method
func Cannoli_App_any(scalar $app, str $pattern, scalar $handler) void {
    Cannoli::Router::any($app->{"router"}, $pattern, $handler);
}

#
# Cannoli-style routes (handlers receive Cannoli object)
#

# Add a GET route with Cannoli handler
func Cannoli_App_get_c(scalar $app, str $pattern, scalar $handler) void {
    Cannoli::Router::get_c($app->{"router"}, $pattern, $handler);
}

# Add a POST route with Cannoli handler
func Cannoli_App_post_c(scalar $app, str $pattern, scalar $handler) void {
    Cannoli::Router::post_c($app->{"router"}, $pattern, $handler);
}

# Add a PUT route with Cannoli handler
func Cannoli_App_put_c(scalar $app, str $pattern, scalar $handler) void {
    Cannoli::Router::put_c($app->{"router"}, $pattern, $handler);
}

# Add a DELETE route with Cannoli handler
func Cannoli_App_delete_c(scalar $app, str $pattern, scalar $handler) void {
    Cannoli::Router::delete_c($app->{"router"}, $pattern, $handler);
}

# Add a PATCH route with Cannoli handler
func Cannoli_App_patch_c(scalar $app, str $pattern, scalar $handler) void {
    Cannoli::Router::patch_c($app->{"router"}, $pattern, $handler);
}

# Add a route for any method with Cannoli handler
func Cannoli_App_any_c(scalar $app, str $pattern, scalar $handler) void {
    Cannoli::Router::any_c($app->{"router"}, $pattern, $handler);
}

# Set custom 404 handler
func Cannoli_App_not_found(scalar $app, scalar $handler) void {
    Cannoli::Router::set_not_found($app->{"router"}, $handler);
}

# Set custom error handler (generic catch-all)
func Cannoli_App_error_handler(scalar $app, scalar $handler) void {
    Cannoli::Router::set_error_handler($app->{"router"}, $handler);
}

# Register handler for specific error code (404, 500, etc.)
func Cannoli_App_error(scalar $app, int $code, scalar $handler) void {
    Cannoli::Router::set_error_code_handler($app->{"router"}, $code, $handler);
}

# Run the application
func Cannoli_App_run(scalar $app) int {
    my scalar $config_ref = $app->{"config"};
    my hash %config = %{$config_ref};

    # Initialize logging
    Cannoli::Log::init(%config);

    my scalar $server_ref = Cannoli::Server::new(%config);

    Cannoli::Server::set_router($server_ref, $app->{"router"});

    # Check for FastCGI mode
    my int $fastcgi = Cannoli::Config::get_bool(%config, "fastcgi.enabled", 0);

    if ($fastcgi == 1) {
        my str $socket = Cannoli::Config::get_str(%config, "fastcgi.socket", "/tmp/cannoli.sock");
        my int $workers = Cannoli::Config::get_int(%config, "server.workers", 5);
        return Cannoli::FastCGI::run($socket, $app->{"router"}, $workers);
    }

    return Cannoli::Server::run($server_ref);
}

# Run in single-process mode (for development)
func Cannoli_App_run_dev(scalar $app) int {
    my scalar $config_ref = $app->{"config"};
    my hash %config = %{$config_ref};

    # Initialize logging
    Cannoli::Log::init(%config);

    my scalar $server_ref = Cannoli::Server::new(%config);

    Cannoli::Server::set_router($server_ref, $app->{"router"});

    return Cannoli::Server::run_single($server_ref);
}

# Print all registered routes
func Cannoli_App_dump_routes(scalar $app) void {
    Cannoli::Router::dump_routes($app->{"router"});
}

# ===== Template helpers =====

# Simple template rendering (replace {{variable}} with values)
func Cannoli_App_render_template(str $template, scalar $vars_ref) str {
    my str $result = $template;
    my hash %vars = %{$vars_ref};
    my array @k = keys(%vars);
    my int $i = 0;

    while ($i < scalar(@k)) {
        my str $key = $k[$i];
        my str $value = $vars{$key};
        my str $placeholder = "{{" . $key . "}}";

        # Replace all occurrences
        my int $pos = index($result, $placeholder);
        while ($pos >= 0) {
            my str $before = substr($result, 0, $pos);
            my str $after = substr($result, $pos + length($placeholder), length($result) - $pos - length($placeholder));
            $result = $before . $value . $after;
            $pos = index($result, $placeholder);
        }

        $i = $i + 1;
    }

    return $result;
}

# ===== JSON helpers =====

func Cannoli_App_json_escape(str $s) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        if ($ch eq "\"") {
            $result = $result . "\\\"";
        } elsif ($ch eq "\\") {
            $result = $result . "\\\\";
        } elsif ($ch eq "\n") {
            $result = $result . "\\n";
        } elsif ($ch eq "\r") {
            $result = $result . "\\r";
        } elsif ($ch eq "\t") {
            $result = $result . "\\t";
        } else {
            $result = $result . $ch;
        }

        $i = $i + 1;
    }

    return $result;
}

# Build a simple JSON object from hash
func Cannoli_App_json_object(scalar $data_ref) str {
    my hash %data = %{$data_ref};
    my str $result = "{";
    my array @k = keys(%data);
    my int $i = 0;
    my int $first = 1;

    while ($i < scalar(@k)) {
        my str $key = $k[$i];
        my str $value = $data{$key};

        if ($first == 0) {
            $result = $result . ",";
        }
        $first = 0;

        $result = $result . "\"" . ::json_escape($key) . "\":";
        $result = $result . "\"" . ::json_escape($value) . "\"";

        $i = $i + 1;
    }

    $result = $result . "}";
    return $result;
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package Cannoli::Main;


# cannoli/src/main.strada - Main entry point
#
# Cannoli - A preforking web server and framework for Strada
#
# Usage:
#   cannoli [options]
#
# Options:
#   -c, --config FILE   Load configuration from file
#   -p, --port PORT     Listen on port (default: 8080)
#   -h, --host HOST     Bind to host (default: 0.0.0.0)
#   -w, --workers N     Number of worker processes (default: 5)
#   --fastcgi           Run in FastCGI mode
#   --socket PATH       FastCGI socket path
#   --dev               Run in single-process development mode
#   --help              Show help message
#   --version           Show version

func Cannoli_Main_print_help() void {
    say("Cannoli - Preforking Web Server & Framework for Strada");
    say("");
    say("Usage: cannoli [options]");
    say("");
    say("Options:");
    say("  -c, --config FILE    Load configuration from file");
    say("  -p, --port PORT      Listen on port (default: 8080)");
    say("  -h, --host HOST      Bind to host (default: 0.0.0.0)");
    say("  -w, --workers N      Number of worker processes (default: 5)");
    say("  --max-requests N     Requests per worker before respawn (default: 1000)");
    say("  -l, --library PATH   Load handlers from shared library (.so)");
    say("                       Comma-separated for multiple libraries");
    say("                       Config: path.so:key=val;key2=val2");
    say("  -s, --static PATH    Serve static files from directory");
    say("  --listing            Enable directory listing (with --static)");
    say("  --ssl                Enable SSL/HTTPS");
    say("  --ssl-port PORT      SSL port (default: 443)");
    say("  --ssl-cert FILE      SSL certificate file");
    say("  --ssl-key FILE       SSL private key file");
    say("  --fastcgi            Run in FastCGI mode");
    say("  --socket PATH        FastCGI socket path");
    say("  --dev                Run in single-process development mode");
    say("  --demo               Run with demo routes (/, /hello, /json, etc.)");
    say("  --debug              Enable debug logging to stdout/stderr");
    say("  --log-level LEVEL    Set log level (error, warn, info, debug)");
    say("  --log-format FMT     Log format (default: '%m %p %s %T')");
    say("  --access-log FILE    Write access log to file");
    say("  --error-log FILE     Write error log to file");
    say("  --help               Show this help message");
    say("  --version            Show version information");
    say("");
    say("Dynamic Library Interface:");
    say("  Export: str cannoli_dispatch(scalar $c)");
    say("  - $c: Cannoli object with all request data");
    say("  - Use $c->method(), $c->path(), $c->body(), $c->param(), etc.");
    say("");
    say("  Return values:");
    say("  - Response body (auto-detects JSON/HTML)");
    say("  - Empty string for 404");
    say("  - \"STATUS:code:content\" for custom status");
    say("  - \"REDIRECT:url\" for redirects");
    say("  - \"RESPONSE:status:headers_len:headers:body\" for full control");
    say("");
    say("Configuration file (cannoli.conf):");
    say("  [server]");
    say("  port = 8080");
    say("  workers = 5");
    say("");
    say("  [ssl]");
    say("  enabled = true");
    say("  port = 443");
    say("  cert = /path/to/cert.pem");
    say("  key = /path/to/key.pem");
    say("");
    say("  [app]");
    say("  library = lib1.so, lib2.so");
    say("");
    say("Log format placeholders:");
    say("  %t  Timestamp (Unix epoch)");
    say("  %m  HTTP method (GET, POST, etc.)");
    say("  %p  Request path");
    say("  %s  Response status code");
    say("  %b  Response body size in bytes");
    say("  %T  Processing time in milliseconds");
    say("  %r  Referer header");
    say("  %a  User-Agent header");
    say("  %i  Remote IP address");
    say("  %P  Protocol (HTTP/1.1)");
    say("");
    say("Example:");
    say("  cannoli --library ./myapp.so --dev");
    say("  cannoli --ssl --ssl-cert cert.pem --ssl-key key.pem");
}

func Cannoli_Main_print_version() void {
    say("Cannoli 1.0.0");
    say("A preforking web server and framework for Strada");
    say("Built with Strada");
}

# Handler functions for the demo app

func Cannoli_Main_handle_home(hash %req) hash {
    exists(%req, "__unused__");
    my str $html = "<!DOCTYPE html>\n";
    $html = $html . "<html>\n<head>\n";
    $html = $html . "<title>Welcome to Cannoli</title>\n";
    $html = $html . "<style>\n";
    $html = $html . "body { font-family: sans-serif; max-width: 800px; margin: 50px auto; padding: 20px; }\n";
    $html = $html . "h1 { color: #333; }\n";
    $html = $html . "code { background: #f5f5f5; padding: 2px 6px; border-radius: 3px; }\n";
    $html = $html . "pre { background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; }\n";
    $html = $html . ".route { margin: 10px 0; }\n";
    $html = $html . "</style>\n</head>\n<body>\n";
    $html = $html . "<h1>Welcome to Cannoli!</h1>\n";
    $html = $html . "<p>Cannoli is a preforking web server and framework for Strada.</p>\n";
    $html = $html . "<h2>Demo Routes</h2>\n";
    $html = $html . "<div class=\"route\"><a href=\"/\">/</a> - This page</div>\n";
    $html = $html . "<div class=\"route\"><a href=\"/hello\">/hello</a> - Simple text response</div>\n";
    $html = $html . "<div class=\"route\"><a href=\"/json\">/json</a> - JSON response</div>\n";
    $html = $html . "<div class=\"route\"><a href=\"/user/123\">/user/{id}</a> - Route with parameter</div>\n";
    $html = $html . "<div class=\"route\"><a href=\"/echo?message=Hello\">/echo?message=...</a> - Query parameters</div>\n";
    $html = $html . "<div class=\"route\"><a href=\"/headers\">/headers</a> - HTTP headers demo</div>\n";
    $html = $html . "</body>\n</html>\n";

    return Cannoli::Response::html(200, $html);
}

func Cannoli_Main_handle_hello(hash %req) hash {
    exists(%req, "__unused__");
    return Cannoli::Response::text(200, "Hello, World!");
}

# Global static server config (for static file mode)
my scalar $g_static_server = undef;

func Cannoli_Main_handle_static_request(hash %req) hash {
    my str $method = $req{"method"};
    my str $path = $req{"path"};
    return Cannoli::Static::handle_request($g_static_server, $method, $path);
}

func Cannoli_Main_handle_json(hash %req) hash {
    exists(%req, "__unused__");
    my str $json = "{\"message\":\"Hello from Cannoli\",\"status\":\"ok\",\"version\":\"1.0.0\"}";
    return Cannoli::Response::json(200, $json);
}

func Cannoli_Main_handle_user(hash %req) hash {
    my scalar $captures = $req{"captures"};
    my str $user_id = "unknown";

    if (defined($captures) && scalar(@{$captures}) > 0) {
        $user_id = $captures->[0];
    }

    my str $json = "{\"user_id\":\"" . $user_id . "\",\"name\":\"User " . $user_id . "\"}";
    return Cannoli::Response::json(200, $json);
}

func Cannoli_Main_handle_echo(hash %req) hash {
    my str $message = Cannoli::Request::get_param(%req, "message");

    if (length($message) == 0) {
        $message = "(no message provided)";
    }

    return Cannoli::Response::text(200, "Echo: " . $message);
}

func Cannoli_Main_handle_submit(hash %req) hash {
    my str $body = $req{"body"};
    my str $json = "{\"received\":\"true\",\"body_length\":\"" . length($body) . "\"}";
    return Cannoli::Response::json(200, $json);
}

# Headers demo - shows request headers and sets custom response headers
func Cannoli_Main_handle_headers(hash %req) hash {
    my str $html = "<!DOCTYPE html>\n<html>\n<head>\n";
    $html = $html . "<title>Headers Demo</title>\n";
    $html = $html . "<style>body { font-family: sans-serif; max-width: 800px; margin: 50px auto; }\n";
    $html = $html . "table { border-collapse: collapse; width: 100%; }\n";
    $html = $html . "th, td { text-align: left; padding: 8px; border: 1px solid #ddd; }\n";
    $html = $html . "th { background: #f5f5f5; }</style>\n</head>\n<body>\n";
    $html = $html . "<h1>Headers Demo</h1>\n";

    # Show request headers
    $html = $html . "<h2>Your Request Headers</h2>\n<table>\n";
    $html = $html . "<tr><th>Header</th><th>Value</th></tr>\n";

    my array @names = Cannoli::Request::header_names(%req);
    my int $i = 0;
    while ($i < scalar(@names)) {
        my str $name = $names[$i];
        my str $value = Cannoli::Request::get_header(%req, $name);
        $html = $html . "<tr><td>" . $name . "</td><td>" . Cannoli::Response::html_escape($value) . "</td></tr>\n";
        $i = $i + 1;
    }
    $html = $html . "</table>\n";

    # Show cookies if present
    my str $cookie_header = Cannoli::Request::get_header(%req, "Cookie");
    if (length($cookie_header) > 0) {
        $html = $html . "<h2>Cookies</h2>\n<table>\n";
        $html = $html . "<tr><th>Name</th><th>Value</th></tr>\n";
        my hash %cookies = Cannoli::Request::cookies(%req);
        my array @cookie_names = keys(%cookies);
        my int $j = 0;
        while ($j < scalar(@cookie_names)) {
            my str $cname = $cookie_names[$j];
            $html = $html . "<tr><td>" . $cname . "</td><td>" . $cookies{$cname} . "</td></tr>\n";
            $j = $j + 1;
        }
        $html = $html . "</table>\n";
    }

    # Show convenience function results
    $html = $html . "<h2>Convenience Functions</h2>\n<table>\n";
    $html = $html . "<tr><th>Function</th><th>Result</th></tr>\n";
    $html = $html . "<tr><td>Cannoli::Request::user_agent()</td><td>" . Cannoli::Response::html_escape(Cannoli::Request::user_agent(%req)) . "</td></tr>\n";
    $html = $html . "<tr><td>Cannoli::Request::host()</td><td>" . Cannoli::Request::host(%req) . "</td></tr>\n";
    $html = $html . "<tr><td>Cannoli::Request::accepts_json()</td><td>" . Cannoli::Request::accepts_json(%req) . "</td></tr>\n";
    $html = $html . "<tr><td>Cannoli::Request::is_ajax()</td><td>" . Cannoli::Request::is_ajax(%req) . "</td></tr>\n";
    $html = $html . "</table>\n";

    $html = $html . "<p><em>Check response headers in your browser's dev tools (F12 > Network)</em></p>\n";
    $html = $html . "</body>\n</html>\n";

    my hash %res = Cannoli::Response::html(200, $html);

    # Set custom response headers
    Cannoli::Response::header(%res, "X-Custom-Header", "Hello from Cannoli!");
    Cannoli::Response::header(%res, "X-Powered-By", "Strada");
    Cannoli::Response::set_cookie(%res, "cannoli_demo", "visited", "Path=/; Max-Age=3600");

    return %res;
}

func Cannoli_Main_handle_not_found(hash %req) hash {
    my str $path = $req{"path"};
    return Cannoli::Response::error_page(404, "Page not found: " . $path);
}

# Create the demo application
func Cannoli_Main_create_demo_app() scalar {
    my scalar $app = Cannoli::App::new();

    # Register routes
    Cannoli::App::get($app, "/", \&Cannoli_Main_handle_home);
    Cannoli::App::get($app, "/hello", \&Cannoli_Main_handle_hello);
    Cannoli::App::get($app, "/json", \&Cannoli_Main_handle_json);
    Cannoli::App::get($app, "/user/([0-9]+)", \&Cannoli_Main_handle_user);
    Cannoli::App::get($app, "/echo", \&Cannoli_Main_handle_echo);
    Cannoli::App::get($app, "/headers", \&Cannoli_Main_handle_headers);
    Cannoli::App::post($app, "/submit", \&Cannoli_Main_handle_submit);

    # Custom 404
    Cannoli::App::not_found($app, \&Cannoli_Main_handle_not_found);

    return $app;
}

func Cannoli_Main_main(int $argc, array @argv) int {
    my hash %config = Cannoli::Config::defaults();
    my int $dev_mode = 0;
    my int $demo_mode = 0;
    my int $show_help = 0;
    my int $show_version = 0;

    # Parse command line arguments
    my int $i = 1;
    while ($i < $argc) {
        my str $arg = $argv[$i];

        if ($arg eq "--help") {
            $show_help = 1;
        } elsif ($arg eq "--version") {
            $show_version = 1;
        } elsif ($arg eq "--dev") {
            $dev_mode = 1;
        } elsif ($arg eq "--demo") {
            $demo_mode = 1;
        } elsif ($arg eq "-c" || $arg eq "--config") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                %config = Cannoli::Config::parse_file($argv[$i]);
            }
        } elsif ($arg eq "-p" || $arg eq "--port") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"server.port"} = $argv[$i];
            }
        } elsif ($arg eq "-h" || $arg eq "--host") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"server.host"} = $argv[$i];
            }
        } elsif ($arg eq "-w" || $arg eq "--workers") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"server.workers"} = $argv[$i];
            }
        } elsif ($arg eq "--max-requests") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"server.max_requests"} = $argv[$i];
            }
        } elsif ($arg eq "-l" || $arg eq "--library") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"app.library"} = $argv[$i];
            }
        } elsif ($arg eq "--fastcgi") {
            $config{"fastcgi.enabled"} = "1";
        } elsif ($arg eq "--socket") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"fastcgi.socket"} = $argv[$i];
                $config{"fastcgi.enabled"} = "1";
            }
        } elsif ($arg eq "--ssl") {
            $config{"ssl.enabled"} = "1";
        } elsif ($arg eq "--ssl-port") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"ssl.port"} = $argv[$i];
            }
        } elsif ($arg eq "--ssl-cert") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"ssl.cert"} = $argv[$i];
            }
        } elsif ($arg eq "--ssl-key") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"ssl.key"} = $argv[$i];
            }
        } elsif ($arg eq "-s" || $arg eq "--static") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"static.root"} = $argv[$i];
            }
        } elsif ($arg eq "--listing") {
            $config{"static.listing"} = "1";
        } elsif ($arg eq "--debug") {
            $config{"log.level"} = "debug";
            $config{"log.to_stdout"} = "1";
        } elsif ($arg eq "--log-level") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"log.level"} = $argv[$i];
            }
        } elsif ($arg eq "--log-format") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"log.format"} = $argv[$i];
            }
        } elsif ($arg eq "--access-log") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"log.access_file"} = $argv[$i];
            }
        } elsif ($arg eq "--error-log") {
            if ($i + 1 < $argc) {
                $i = $i + 1;
                $config{"log.error_file"} = $argv[$i];
            }
        } elsif (substr($arg, 0, 1) ne "-") {
            # Positional argument - treat as static directory
            $config{"static.root"} = $arg;
        }

        $i = $i + 1;
    }

    if ($show_help == 1) {
        ::print_help();
        return 0;
    }

    if ($show_version == 1) {
        ::print_version();
        return 0;
    }

    # Check if static file serving mode
    my str $static_root = "";
    if (exists(%config, "static.root")) {
        $static_root = $config{"static.root"};
    }

    my scalar $app = undef;

    if (length($static_root) > 0) {
        # Static file server mode
        $app = Cannoli::App::new();

        # Configure static file serving
        $g_static_server = Cannoli::Static::new();
        $g_static_server->{"document_root"} = $static_root;

        if (exists(%config, "static.listing") && $config{"static.listing"} eq "1") {
            $g_static_server->{"directory_listing"} = 1;
        }

        # Register catch-all route for static files
        Cannoli::App::get($app, "/.*", \&Cannoli_Main_handle_static_request);

        say("Static file server mode");
        say("Document root: " . $static_root);
        if ($g_static_server->{"directory_listing"} == 1) {
            say("Directory listing: enabled");
        }
    } elsif ($demo_mode == 1) {
        # Create demo application
        $app = ::create_demo_app();
        say("Demo mode enabled");
    } else {
        # Empty app - will use libraries if configured, otherwise 404
        $app = Cannoli::App::new();
    }

    # Apply config to app
    $app->{"config"} = \%config;

    # Show registered routes
    Cannoli::App::dump_routes($app);

    # Run the server
    if ($dev_mode == 1) {
        return Cannoli::App::run_dev($app);
    }

    return Cannoli::App::run($app);
}

package main;

# Entry point wrapper for the Cannoli binary
func main(int $argc, array @argv) int {
    return Cannoli::Main::main($argc, @argv);
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# lib/compress.strada - Compression library bindings
#
# Provides gzip compression for HTTP responses
# Uses zlib via inline C code
#
# Compile with:
#   ./strada myapp.strada -lz

package compress;

# C includes
__C__ {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <zlib.h>

/* Get byte length from StradaValue - binary safe */
static size_t compress_get_byte_len(StradaValue *sv) {
    if (!sv) return 0;
    if (sv->type == STRADA_STR) {
        if (sv->struct_size > 0) return sv->struct_size;
        if (sv->value.pv) return strlen(sv->value.pv);
    }
    return 0;
}

/* Get raw byte pointer from StradaValue - binary safe (does not copy) */
static const char* compress_get_bytes(StradaValue *sv) {
    if (!sv) return NULL;
    if (sv->type == STRADA_STR) {
        return sv->value.pv;
    }
    return NULL;
}
}

# Compress data using gzip format
func gzip(str $data) str {
    my str $result = "";
    __C__ {
        size_t input_len = compress_get_byte_len(data);
        if (input_len == 0) {
            result = strada_new_str("");
        } else {
            const char *input = compress_get_bytes(data);

            /* Allocate output buffer (worst case: input + gzip overhead) */
            size_t output_size = compressBound(input_len) + 18;
            char *output = malloc(output_size);
            if (!output) {
                result = data;  /* Return uncompressed if allocation failed */
                strada_incref(result);
            } else {
                /* Initialize zlib stream for gzip (windowBits = 15 + 16 for gzip) */
                z_stream strm;
                memset(&strm, 0, sizeof(strm));

                int ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED,
                                       15 + 16, 8, Z_DEFAULT_STRATEGY);
                if (ret != Z_OK) {
                    free(output);
                    result = data;
                    strada_incref(result);
                } else {
                    strm.next_in = (Bytef*)input;
                    strm.avail_in = input_len;
                    strm.next_out = (Bytef*)output;
                    strm.avail_out = output_size;

                    ret = deflate(&strm, Z_FINISH);
                    deflateEnd(&strm);

                    if (ret != Z_STREAM_END) {
                        free(output);
                        result = data;
                        strada_incref(result);
                    } else {
                        result = strada_new_str_len(output, strm.total_out);
                        free(output);
                    }
                }
            }
        }
    }
    return $result;
}

# Compress data using deflate format (no gzip header)
func deflate(str $data) str {
    my str $result = "";
    __C__ {
        size_t input_len = compress_get_byte_len(data);
        if (input_len == 0) {
            result = strada_new_str("");
        } else {
            const char *input = compress_get_bytes(data);

            size_t output_size = compressBound(input_len);
            char *output = malloc(output_size);
            if (!output) {
                result = data;
                strada_incref(result);
            } else {
                z_stream strm;
                memset(&strm, 0, sizeof(strm));

                int ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED,
                                       -15, 8, Z_DEFAULT_STRATEGY);
                if (ret != Z_OK) {
                    free(output);
                    result = data;
                    strada_incref(result);
                } else {
                    strm.next_in = (Bytef*)input;
                    strm.avail_in = input_len;
                    strm.next_out = (Bytef*)output;
                    strm.avail_out = output_size;

                    ret = deflate(&strm, Z_FINISH);
                    deflateEnd(&strm);

                    if (ret != Z_STREAM_END) {
                        free(output);
                        result = data;
                        strada_incref(result);
                    } else {
                        result = strada_new_str_len(output, strm.total_out);
                        free(output);
                    }
                }
            }
        }
    }
    return $result;
}

# Decompress gzip data
func gunzip(str $data) str {
    my str $result = "";
    __C__ {
        size_t input_len = compress_get_byte_len(data);
        if (input_len == 0) {
            result = strada_new_str("");
        } else {
            const char *input = compress_get_bytes(data);

            /* Start with 4x input size, grow if needed */
            size_t output_size = input_len * 4;
            if (output_size < 1024) output_size = 1024;
            char *output = malloc(output_size);
            if (!output) {
                result = data;
                strada_incref(result);
            } else {
                z_stream strm;
                memset(&strm, 0, sizeof(strm));

                int ret = inflateInit2(&strm, 15 + 16);
                if (ret != Z_OK) {
                    free(output);
                    result = data;
                    strada_incref(result);
                } else {
                    strm.next_in = (Bytef*)input;
                    strm.avail_in = input_len;
                    strm.next_out = (Bytef*)output;
                    strm.avail_out = output_size;

                    int success = 1;
                    while (1) {
                        ret = inflate(&strm, Z_NO_FLUSH);
                        if (ret == Z_STREAM_END) {
                            break;
                        }
                        if (ret != Z_OK && ret != Z_BUF_ERROR) {
                            success = 0;
                            break;
                        }
                        if (strm.avail_out == 0) {
                            size_t new_size = output_size * 2;
                            char *new_output = realloc(output, new_size);
                            if (!new_output) {
                                success = 0;
                                break;
                            }
                            output = new_output;
                            strm.next_out = (Bytef*)(output + output_size);
                            strm.avail_out = new_size - output_size;
                            output_size = new_size;
                        }
                    }

                    inflateEnd(&strm);

                    if (!success) {
                        free(output);
                        result = data;
                        strada_incref(result);
                    } else {
                        result = strada_new_str_len(output, strm.total_out);
                        free(output);
                    }
                }
            }
        }
    }
    return $result;
}

# Check if content should be compressed based on content-type
func should_compress(str $content_type, str $data) int {
    my int $result = 0;
    __C__ {
        size_t data_len = compress_get_byte_len(data);
        const char *ct = strada_to_str(content_type);

        if (!ct) {
            result = strada_new_int(0);
        } else if (data_len < 1024) {
            /* Don't compress if too small (< 1KB) */
            result = strada_new_int(0);
        } else if (strstr(ct, "text/") ||
                   strstr(ct, "application/json") ||
                   strstr(ct, "application/javascript") ||
                   strstr(ct, "application/xml") ||
                   strstr(ct, "application/xhtml") ||
                   strstr(ct, "+xml") ||
                   strstr(ct, "+json")) {
            /* Compress text-based content types */
            result = strada_new_int(1);
        } else if (strstr(ct, "image/") ||
                   strstr(ct, "video/") ||
                   strstr(ct, "audio/") ||
                   strstr(ct, "application/zip") ||
                   strstr(ct, "application/gzip") ||
                   strstr(ct, "application/x-gzip")) {
            /* Don't compress already-compressed formats */
            result = strada_new_int(0);
        } else {
            result = strada_new_int(0);
        }
    }
    return $result;
}
