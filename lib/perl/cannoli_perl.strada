/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# cannoli_perl.strada - Perl dispatch handler for Cannoli (written in Strada)
#
# This library dispatches HTTP requests to Perl handlers using the Cannoli object.
# It uses perl_bridge.so for low-level Perl API access.
#
# Usage:
#   cannoli --library ./cannoli_perl.so:handler=MyApp::handle;script=app.pl --dev
#
# Config options (semicolon-separated):
#   handler=Sub::Name   - Perl sub to call (required)
#   script=/path/to.pl  - Load Perl script
#   lib=/path           - Add to @INC (repeatable)
#   use=Module          - Use a Perl module

# Global state
my int $g_perl_bridge = 0;
my str $g_handler_sub = "";
my str $g_cannoli_pm_path = "";

# Bridge function pointers
my int $g_init_fn = 0;
my int $g_add_inc_fn = 0;
my int $g_use_fn = 0;
my int $g_do_fn = 0;
my int $g_load_cannoli_fn = 0;
my int $g_call_handler_fn = 0;

# Parse config string to get value for a key
func config_get(str $config, str $key) str {
    my int $key_len = length($key);
    my int $config_len = length($config);
    my int $i = 0;

    while ($i < $config_len) {
        # Skip semicolons and whitespace
        while ($i < $config_len) {
            my str $ch = substr($config, $i, 1);
            if ($ch ne ";" && $ch ne " " && $ch ne "\t") {
                last;
            }
            $i = $i + 1;
        }

        if ($i >= $config_len) {
            last;
        }

        # Check if this position starts with our key
        if ($i + $key_len < $config_len) {
            my str $maybe_key = substr($config, $i, $key_len);
            my str $after_key = substr($config, $i + $key_len, 1);

            if ($maybe_key eq $key && $after_key eq "=") {
                # Found the key, extract value
                my int $value_start = $i + $key_len + 1;
                my int $value_end = $value_start;

                while ($value_end < $config_len) {
                    my str $ch = substr($config, $value_end, 1);
                    if ($ch eq ";") {
                        last;
                    }
                    $value_end = $value_end + 1;
                }

                return substr($config, $value_start, $value_end - $value_start);
            }
        }

        # Skip to next semicolon
        while ($i < $config_len) {
            my str $ch = substr($config, $i, 1);
            if ($ch eq ";") {
                last;
            }
            $i = $i + 1;
        }
    }

    return "";
}

# Get all values for a key (returns array)
func config_get_all(str $config, str $key) array {
    my array @values = ();
    my int $key_len = length($key);
    my int $config_len = length($config);
    my int $i = 0;

    while ($i < $config_len) {
        # Skip semicolons and whitespace
        while ($i < $config_len) {
            my str $ch = substr($config, $i, 1);
            if ($ch ne ";" && $ch ne " " && $ch ne "\t") {
                last;
            }
            $i = $i + 1;
        }

        if ($i >= $config_len) {
            last;
        }

        # Check if this position starts with our key
        if ($i + $key_len < $config_len) {
            my str $maybe_key = substr($config, $i, $key_len);
            my str $after_key = substr($config, $i + $key_len, 1);

            if ($maybe_key eq $key && $after_key eq "=") {
                # Found the key, extract value
                my int $value_start = $i + $key_len + 1;
                my int $value_end = $value_start;

                while ($value_end < $config_len) {
                    my str $ch = substr($config, $value_end, 1);
                    if ($ch eq ";") {
                        last;
                    }
                    $value_end = $value_end + 1;
                }

                my str $value = substr($config, $value_start, $value_end - $value_start);
                push(\@values, $value);
            }
        }

        # Skip to next semicolon
        while ($i < $config_len) {
            my str $ch = substr($config, $i, 1);
            if ($ch eq ";") {
                last;
            }
            $i = $i + 1;
        }
    }

    return @values;
}

# Find the bridge library path (same directory as this .so)
func find_bridge_path() str {
    if (sys::is_file("./lib/perl/libperl_bridge.so")) {
        return "./lib/perl/libperl_bridge.so";
    }
    if (sys::is_file("./cannoli/lib/perl/libperl_bridge.so")) {
        return "./cannoli/lib/perl/libperl_bridge.so";
    }
    if (sys::is_file("/usr/local/lib/cannoli/libperl_bridge.so")) {
        return "/usr/local/lib/cannoli/libperl_bridge.so";
    }
    return "libperl_bridge.so";
}

# Find Cannoli.pm path
func find_cannoli_pm_path() str {
    if (sys::is_file("./lib/perl/Cannoli.pm")) {
        return "./lib/perl/Cannoli.pm";
    }
    if (sys::is_file("./cannoli/lib/perl/Cannoli.pm")) {
        return "./cannoli/lib/perl/Cannoli.pm";
    }
    if (sys::is_file("/usr/local/lib/cannoli/Cannoli.pm")) {
        return "/usr/local/lib/cannoli/Cannoli.pm";
    }
    return "";  # Will try 'use Cannoli' from @INC
}

# Initialize Perl with config
func cannoli_init(str $config) int {
    # Get handler name (required)
    $g_handler_sub = config_get($config, "handler");
    if (length($g_handler_sub) == 0) {
        say("cannoli_perl: ERROR - Missing required 'handler' parameter");
        say("Usage: --library ./cannoli_perl.so:handler=MyApp::handle");
        return 0;
    }

    # Load the Perl bridge library
    my str $bridge_path = find_bridge_path();

    $g_perl_bridge = sys::dl_open($bridge_path);
    if ($g_perl_bridge == 0) {
        say("cannoli_perl: ERROR - Could not load " . $bridge_path);
        say("  Make sure libperl_bridge.so is built and accessible");
        return 0;
    }

    # Get function pointers
    $g_init_fn = sys::dl_sym($g_perl_bridge, "perl_bridge_init");
    $g_add_inc_fn = sys::dl_sym($g_perl_bridge, "perl_bridge_add_inc");
    $g_use_fn = sys::dl_sym($g_perl_bridge, "perl_bridge_use");
    $g_do_fn = sys::dl_sym($g_perl_bridge, "perl_bridge_do");
    $g_load_cannoli_fn = sys::dl_sym($g_perl_bridge, "perl_bridge_load_cannoli");
    $g_call_handler_fn = sys::dl_sym($g_perl_bridge, "perl_bridge_call_handler");

    if ($g_init_fn == 0 || $g_call_handler_fn == 0) {
        say("cannoli_perl: ERROR - Bridge functions not found");
        return 0;
    }

    # Initialize Perl (pass dummy arg - bridge function ignores it)
    my int $init_result = sys::dl_call_int($g_init_fn, "init");
    if ($init_result == 0) {
        say("cannoli_perl: ERROR - Perl initialization failed");
        return 0;
    }

    # Add library paths
    my array @lib_paths = config_get_all($config, "lib");
    my int $i = 0;
    while ($i < scalar(@lib_paths)) {
        my str $lib_path = $lib_paths[$i];
        sys::dl_call_int_sv($g_add_inc_fn, [$lib_path]);
        $i = $i + 1;
    }

    # Load Cannoli.pm module
    $g_cannoli_pm_path = find_cannoli_pm_path();
    if ($g_load_cannoli_fn != 0) {
        my int $load_result = sys::dl_call_int_sv($g_load_cannoli_fn, [$g_cannoli_pm_path]);
        if ($load_result == 0) {
            say("cannoli_perl: ERROR - Failed to load Cannoli.pm");
            return 0;
        }
    }

    # Use modules
    my array @modules = config_get_all($config, "use");
    $i = 0;
    while ($i < scalar(@modules)) {
        my str $module = $modules[$i];
        my int $use_result = sys::dl_call_int_sv($g_use_fn, [$module]);
        if ($use_result == 0) {
            say("cannoli_perl: ERROR - Failed to use " . $module);
            return 0;
        }
        $i = $i + 1;
    }

    # Load scripts
    my str $script = config_get($config, "script");
    if (length($script) > 0) {
        my int $do_result = sys::dl_call_int_sv($g_do_fn, [$script]);
        if ($do_result == 0) {
            say("cannoli_perl: ERROR - Failed to load " . $script);
            return 0;
        }
    }

    return 1;
}

# Dispatch HTTP request to Perl handler (internal impl - called by C wrapper)
# New signature with all request data
func strada_dispatch_impl(
    str $method,
    str $path,
    str $path_info,
    str $query_string,
    str $body,
    str $headers,
    str $remote_addr,
    str $content_type
) str {
    if ($g_call_handler_fn == 0 || length($g_handler_sub) == 0) {
        return "";
    }

    # Call perl_bridge_call_handler with all request data
    my str $result = sys::dl_call_str_sv($g_call_handler_fn, [
        $g_handler_sub,
        $method,
        $path,
        $path_info,
        $query_string,
        $body,
        $headers,
        $remote_addr,
        $content_type
    ]);

    return $result;
}
